/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => GptTaskManagerPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian8 = require("obsidian");

// src/settings.ts
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  openAIApiKey: "",
  gptModel: "gpt-4o-mini",
  whisperModel: "whisper-1",
  gptMaxTokens: 2e3,
  gptTemperature: 0.7,
  // API Reliability defaults
  apiTimeoutSeconds: 60,
  apiMaxRetries: 3,
  rateLimitPerMinute: 10,
  tasksFolder: "500 Plan & Reflect/520 Tasks",
  epicsFolder: "500 Plan & Reflect/510 Epics",
  goalsFolder: "300 Goals & Milestone/Goals",
  projectsFolder: "400 Projects",
  milestonesFolder: "300 Goals & Milestone/Milestones",
  templatesFolder: "900 Templates",
  taskTemplatePath: "900 Templates/4 Task Template.md",
  epicTemplatePath: "900 Templates/4 Epic Template.md",
  enableVoiceInput: true,
  enableSmartSuggestions: true,
  enableAutoBreakdown: true,
  enableContextCache: true,
  showConfirmationDialogs: true,
  defaultLanguage: "ko",
  // UI/Locale
  uiLocale: "en",
  // Logging
  logLevel: "info",
  enableDebugNotices: false,
  defaultStatus: "backlog",
  defaultPriority: "medium",
  taskCreationPrompt: `You are an expert task manager assistant. Based on the user's input and their current goals/projects context, help create well-structured tasks.

USER CONTEXT:
Goals: {{goals}}
Projects: {{projects}}
Current Epics: {{epics}}

USER INPUT: {{input}}

Create a task with:
1. A clear, actionable title
2. Specific objectives (what needs to be accomplished)
3. Why it matters (connection to goals)
4. Suggested Epic/Project association
5. Priority recommendation (low/medium/high/critical)
6. Estimated complexity (simple/moderate/complex)

Respond in JSON format:
{
  "title": "Task title",
  "objective": "What needs to be accomplished",
  "importance": "Why it matters",
  "suggestedEpic": "Epic name or null",
  "suggestedProject": "Project name or null",
  "priority": "medium",
  "complexity": "moderate",
  "subtasks": ["subtask 1", "subtask 2"] // if complex
}`,
  taskBreakdownPrompt: `You are an expert project manager. Break down the following epic/task into smaller, actionable tasks.

EPIC/TASK: {{title}}
DESCRIPTION: {{description}}
OBJECTIVE: {{objective}}

Context:
- Goal: {{goal}}
- Project: {{project}}
- Area: {{area}}

Create 3-8 well-structured subtasks that:
1. Are specific and actionable
2. Can be completed in 1-4 hours each
3. Have clear dependencies (if any)
4. Lead to completing the parent task/epic

Respond in JSON format:
{
  "tasks": [
    {
      "title": "Task title",
      "objective": "What this task accomplishes",
      "priority": "medium",
      "dependsOn": null // or task index
    }
  ]
}`,
  prioritizationPrompt: `You are a productivity expert. Analyze the following tasks and suggest optimal prioritization.

TASKS:
{{tasks}}

USER'S CURRENT FOCUS:
- Active Goals: {{goals}}
- Deadlines: {{deadlines}}
- Available Time: {{availableTime}}

Provide prioritization recommendations considering:
1. Urgency and deadlines
2. Alignment with current goals
3. Dependencies between tasks
4. Effort vs impact ratio

Respond in JSON format:
{
  "prioritizedTasks": [
    {
      "title": "Task title",
      "suggestedPriority": "high",
      "reasoning": "Why this priority",
      "suggestedOrder": 1
    }
  ],
  "insights": "Overall productivity insights"
}`
};
var GptTaskManagerSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.addClass("gpt-task-manager-settings");
    containerEl.createEl("h1", { text: "GPT Task Manager Settings" });
    containerEl.createEl("h2", { text: "\u{1F511} API Configuration" });
    new import_obsidian.Setting(containerEl).setName("OpenAI API Key").setDesc("Your OpenAI API key for GPT and Whisper.").addText(
      (text) => text.setPlaceholder("sk-...").setValue(this.plugin.settings.openAIApiKey).onChange(async (value) => {
        this.plugin.settings.openAIApiKey = value;
        await this.plugin.saveSettings();
      })
    ).then((setting) => {
      const inputEl = setting.controlEl.querySelector("input");
      if (inputEl) {
        inputEl.type = "password";
        inputEl.style.width = "300px";
      }
    });
    new import_obsidian.Setting(containerEl).setName("GPT Model").setDesc("The OpenAI model to use for task assistance (gpt-4o-mini, gpt-4o, gpt-4-turbo).").addDropdown(
      (dropdown) => dropdown.addOption("gpt-4o-mini", "GPT-4o Mini (Fast, Cheap)").addOption("gpt-4o", "GPT-4o (Powerful)").addOption("gpt-4-turbo", "GPT-4 Turbo").addOption("gpt-3.5-turbo", "GPT-3.5 Turbo (Legacy)").setValue(this.plugin.settings.gptModel).onChange(async (value) => {
        this.plugin.settings.gptModel = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("GPT Max Tokens").setDesc("Maximum tokens for GPT responses (500-4000).").addText(
      (text) => text.setPlaceholder("2000").setValue(String(this.plugin.settings.gptMaxTokens)).onChange(async (value) => {
        const parsed = parseInt(value, 10);
        this.plugin.settings.gptMaxTokens = isNaN(parsed) ? 2e3 : Math.max(500, Math.min(4e3, parsed));
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("GPT Temperature").setDesc("Creativity level (0.0-1.0). Lower = more focused, Higher = more creative.").addText(
      (text) => text.setPlaceholder("0.7").setValue(String(this.plugin.settings.gptTemperature)).onChange(async (value) => {
        const parsed = parseFloat(value);
        this.plugin.settings.gptTemperature = isNaN(parsed) ? 0.7 : Math.max(0, Math.min(1, parsed));
        await this.plugin.saveSettings();
      })
    );
    containerEl.createEl("h2", { text: "\u{1F504} API Reliability" });
    new import_obsidian.Setting(containerEl).setName("Request Timeout").setDesc("Timeout for API requests in seconds (10-120).").addText(
      (text) => text.setPlaceholder("60").setValue(String(this.plugin.settings.apiTimeoutSeconds)).onChange(async (value) => {
        const parsed = parseInt(value, 10);
        this.plugin.settings.apiTimeoutSeconds = isNaN(parsed) ? 60 : Math.max(10, Math.min(120, parsed));
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Max Retries").setDesc("Maximum retry attempts for failed requests (0-5).").addText(
      (text) => text.setPlaceholder("3").setValue(String(this.plugin.settings.apiMaxRetries)).onChange(async (value) => {
        const parsed = parseInt(value, 10);
        this.plugin.settings.apiMaxRetries = isNaN(parsed) ? 3 : Math.max(0, Math.min(5, parsed));
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Rate Limit (per minute)").setDesc("Maximum API requests per minute to prevent abuse (5-30).").addText(
      (text) => text.setPlaceholder("10").setValue(String(this.plugin.settings.rateLimitPerMinute)).onChange(async (value) => {
        const parsed = parseInt(value, 10);
        this.plugin.settings.rateLimitPerMinute = isNaN(parsed) ? 10 : Math.max(5, Math.min(30, parsed));
        await this.plugin.saveSettings();
      })
    );
    containerEl.createEl("h2", { text: "\u{1F4C1} Vault Paths" });
    new import_obsidian.Setting(containerEl).setName("Tasks Folder").setDesc("Path to your tasks folder (e.g., 500 Plan & Reflect/520 Tasks).").addText(
      (text) => text.setPlaceholder("500 Plan & Reflect/520 Tasks").setValue(this.plugin.settings.tasksFolder).onChange(async (value) => {
        this.plugin.settings.tasksFolder = (0, import_obsidian.normalizePath)(value.trim());
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Epics Folder").setDesc("Path to your epics folder.").addText(
      (text) => text.setPlaceholder("500 Plan & Reflect/510 Epics").setValue(this.plugin.settings.epicsFolder).onChange(async (value) => {
        this.plugin.settings.epicsFolder = (0, import_obsidian.normalizePath)(value.trim());
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Goals Folder").setDesc("Path to your goals folder.").addText(
      (text) => text.setPlaceholder("300 Goals & Milestone/Goals").setValue(this.plugin.settings.goalsFolder).onChange(async (value) => {
        this.plugin.settings.goalsFolder = (0, import_obsidian.normalizePath)(value.trim());
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Projects Folder").setDesc("Path to your projects folder.").addText(
      (text) => text.setPlaceholder("400 Projects").setValue(this.plugin.settings.projectsFolder).onChange(async (value) => {
        this.plugin.settings.projectsFolder = (0, import_obsidian.normalizePath)(value.trim());
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Task Template Path").setDesc("Path to your task template file.").addText(
      (text) => text.setPlaceholder("900 Templates/4 Task Template.md").setValue(this.plugin.settings.taskTemplatePath).onChange(async (value) => {
        this.plugin.settings.taskTemplatePath = (0, import_obsidian.normalizePath)(value.trim());
        await this.plugin.saveSettings();
      })
    );
    containerEl.createEl("h2", { text: "\u26A1 Features" });
    new import_obsidian.Setting(containerEl).setName("Enable Voice Input").setDesc("Allow creating tasks via voice recording (requires microphone access).").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.enableVoiceInput).onChange(async (value) => {
        this.plugin.settings.enableVoiceInput = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Enable Smart Suggestions").setDesc("Use GPT to suggest task details based on your goals and context.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.enableSmartSuggestions).onChange(async (value) => {
        this.plugin.settings.enableSmartSuggestions = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Enable Auto Breakdown").setDesc("Automatically suggest breaking down complex tasks into subtasks.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.enableAutoBreakdown).onChange(async (value) => {
        this.plugin.settings.enableAutoBreakdown = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Default Language").setDesc("Default language for voice transcription and GPT responses.").addDropdown(
      (dropdown) => dropdown.addOption("ko", "\uD55C\uAD6D\uC5B4 (Korean)").addOption("en", "English").addOption("auto", "Auto-detect").setValue(this.plugin.settings.defaultLanguage).onChange(async (value) => {
        this.plugin.settings.defaultLanguage = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("UI Language").setDesc("Language for plugin interface elements.").addDropdown(
      (dropdown) => dropdown.addOption("en", "English").addOption("ko", "\uD55C\uAD6D\uC5B4 (Korean)").addOption("ja", "\u65E5\u672C\u8A9E (Japanese)").addOption("zh", "\u4E2D\u6587 (Chinese)").setValue(this.plugin.settings.uiLocale).onChange(async (value) => {
        this.plugin.settings.uiLocale = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Enable Context Cache").setDesc("Cache vault context (goals, projects, epics) for faster performance.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.enableContextCache).onChange(async (value) => {
        this.plugin.settings.enableContextCache = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Show Confirmation Dialogs").setDesc("Show confirmation before creating tasks.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.showConfirmationDialogs).onChange(async (value) => {
        this.plugin.settings.showConfirmationDialogs = value;
        await this.plugin.saveSettings();
      })
    );
    containerEl.createEl("h2", { text: "\u{1F50D} Logging & Debugging" });
    new import_obsidian.Setting(containerEl).setName("Log Level").setDesc("Minimum log level for console output.").addDropdown(
      (dropdown) => dropdown.addOption("debug", "Debug (Verbose)").addOption("info", "Info (Normal)").addOption("warn", "Warnings Only").addOption("error", "Errors Only").addOption("none", "Disabled").setValue(this.plugin.settings.logLevel).onChange(async (value) => {
        this.plugin.settings.logLevel = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Show Debug Notices").setDesc("Show debug information in Obsidian notices (useful for troubleshooting).").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.enableDebugNotices).onChange(async (value) => {
        this.plugin.settings.enableDebugNotices = value;
        await this.plugin.saveSettings();
      })
    );
    containerEl.createEl("h2", { text: "\u{1F4CB} Task Defaults" });
    new import_obsidian.Setting(containerEl).setName("Default Status").setDesc("Default status for new tasks.").addDropdown(
      (dropdown) => dropdown.addOption("backlog", "Backlog").addOption("todo", "To Do").addOption("in-progress", "In Progress").setValue(this.plugin.settings.defaultStatus).onChange(async (value) => {
        this.plugin.settings.defaultStatus = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Default Priority").setDesc("Default priority for new tasks.").addDropdown(
      (dropdown) => dropdown.addOption("low", "Low").addOption("medium", "Medium").addOption("high", "High").addOption("critical", "Critical").setValue(this.plugin.settings.defaultPriority).onChange(async (value) => {
        this.plugin.settings.defaultPriority = value;
        await this.plugin.saveSettings();
      })
    );
    containerEl.createEl("h2", { text: "\u{1F916} GPT Prompts" });
    containerEl.createEl("p", {
      text: "Customize the prompts used for GPT-powered features. Use {{placeholders}} for dynamic content.",
      cls: "setting-item-description"
    });
    new import_obsidian.Setting(containerEl).setName("Task Creation Prompt").setDesc("Prompt used when creating new tasks with GPT assistance.").addTextArea((text) => {
      text.setPlaceholder("Enter your task creation prompt...").setValue(this.plugin.settings.taskCreationPrompt).onChange(async (value) => {
        this.plugin.settings.taskCreationPrompt = value;
        await this.plugin.saveSettings();
      });
      text.inputEl.rows = 10;
      text.inputEl.style.width = "100%";
      text.inputEl.style.fontFamily = "monospace";
      text.inputEl.style.fontSize = "12px";
    });
    new import_obsidian.Setting(containerEl).setName("Task Breakdown Prompt").setDesc("Prompt used when breaking down tasks/epics into subtasks.").addTextArea((text) => {
      text.setPlaceholder("Enter your task breakdown prompt...").setValue(this.plugin.settings.taskBreakdownPrompt).onChange(async (value) => {
        this.plugin.settings.taskBreakdownPrompt = value;
        await this.plugin.saveSettings();
      });
      text.inputEl.rows = 10;
      text.inputEl.style.width = "100%";
      text.inputEl.style.fontFamily = "monospace";
      text.inputEl.style.fontSize = "12px";
    });
    containerEl.createEl("h2", { text: "\u{1F504} Reset" });
    new import_obsidian.Setting(containerEl).setName("Reset to Defaults").setDesc("Reset all settings to their default values.").addButton(
      (button) => button.setButtonText("Reset All Settings").setWarning().onClick(async () => {
        const apiKey = this.plugin.settings.openAIApiKey;
        this.plugin.settings = { ...DEFAULT_SETTINGS, openAIApiKey: apiKey };
        await this.plugin.saveSettings();
        this.display();
      })
    );
  }
};

// src/api-client.ts
var import_obsidian2 = require("obsidian");

// src/logger.ts
var SENSITIVE_PATTERNS = [
  /sk-[a-zA-Z0-9]{20,}/g,
  // OpenAI API keys
  /Bearer\s+[a-zA-Z0-9._-]+/gi,
  // Bearer tokens
  /api[_-]?key["\s:=]+[^\s"',}]+/gi,
  // Generic API key patterns
  /password["\s:=]+[^\s"',}]+/gi
  // Passwords
];
var PLUGIN_PREFIX = "[GPT Task Manager]";
var Logger = class {
  constructor() {
    this.logLevel = 1 /* INFO */;
    this.logHistory = [];
    this.maxHistorySize = 100;
    this.listeners = [];
  }
  /**
   * Set the current log level
   */
  setLogLevel(level) {
    this.logLevel = level;
  }
  /**
   * Get current log level
   */
  getLogLevel() {
    return this.logLevel;
  }
  /**
   * Add a listener for log entries (for telemetry/UI)
   */
  addListener(listener) {
    this.listeners.push(listener);
    return () => {
      this.listeners = this.listeners.filter((listenerItem) => listenerItem !== listener);
    };
  }
  /**
   * Get recent log history
   */
  getHistory(limit) {
    const historyLimit = limit || this.maxHistorySize;
    return this.logHistory.slice(-historyLimit);
  }
  /**
   * Clear log history
   */
  clearHistory() {
    this.logHistory = [];
  }
  /**
   * Sanitize text to remove sensitive information
   */
  sanitize(text) {
    let sanitized = text;
    for (const pattern of SENSITIVE_PATTERNS) {
      sanitized = sanitized.replace(pattern, "[REDACTED]");
    }
    return sanitized;
  }
  /**
   * Sanitize an object recursively
   */
  sanitizeObject(obj) {
    if (obj === null || obj === void 0) {
      return obj;
    }
    if (typeof obj === "string") {
      return this.sanitize(obj);
    }
    if (Array.isArray(obj)) {
      return obj.map((item) => this.sanitizeObject(item));
    }
    if (typeof obj === "object") {
      const sanitized = {};
      for (const [key, value] of Object.entries(obj)) {
        const lowerKey = key.toLowerCase();
        if (lowerKey.includes("apikey") || lowerKey.includes("api_key") || lowerKey.includes("password") || lowerKey.includes("secret") || lowerKey.includes("token") || lowerKey.includes("authorization")) {
          sanitized[key] = "[REDACTED]";
        } else {
          sanitized[key] = this.sanitizeObject(value);
        }
      }
      return sanitized;
    }
    return obj;
  }
  /**
   * Create a log entry
   */
  log(level, category, message, data) {
    if (level < this.logLevel) {
      return;
    }
    const entry = {
      timestamp: (/* @__PURE__ */ new Date()).toISOString(),
      level,
      category,
      message: this.sanitize(message),
      data: data ? this.sanitizeObject(data) : void 0
    };
    this.logHistory.push(entry);
    if (this.logHistory.length > this.maxHistorySize) {
      this.logHistory.shift();
    }
    for (const listener of this.listeners) {
      try {
        listener(entry);
      } catch (e) {
      }
    }
    const prefix = `${PLUGIN_PREFIX} [${category}]`;
    const dataStr = data ? ` ${JSON.stringify(this.sanitizeObject(data))}` : "";
    switch (level) {
      case 0 /* DEBUG */:
        console.debug(`${prefix} ${message}${dataStr}`);
        break;
      case 1 /* INFO */:
        console.log(`${prefix} ${message}${dataStr}`);
        break;
      case 2 /* WARN */:
        console.warn(`${prefix} ${message}${dataStr}`);
        break;
      case 3 /* ERROR */:
        console.error(`${prefix} ${message}${dataStr}`);
        break;
    }
  }
  debug(category, message, data) {
    this.log(0 /* DEBUG */, category, message, data);
  }
  info(category, message, data) {
    this.log(1 /* INFO */, category, message, data);
  }
  warn(category, message, data) {
    this.log(2 /* WARN */, category, message, data);
  }
  error(category, message, data) {
    this.log(3 /* ERROR */, category, message, data);
  }
};
var logger = new Logger();
function scopeTextForApi(text, maxLength = 4e3) {
  const sanitized = logger.sanitize(text);
  if (sanitized.length <= maxLength) {
    return sanitized;
  }
  return sanitized.substring(0, maxLength - 3) + "...";
}

// src/api-client.ts
var CATEGORY = "APIClient";
var CancellationToken = class {
  constructor() {
    this._isCancelled = false;
    this._reason = "";
    this._callbacks = [];
  }
  get isCancelled() {
    return this._isCancelled;
  }
  get reason() {
    return this._reason;
  }
  cancel(reason = "User cancelled") {
    if (this._isCancelled)
      return;
    this._isCancelled = true;
    this._reason = reason;
    for (const callback of this._callbacks) {
      try {
        callback();
      } catch (e) {
      }
    }
  }
  onCancel(callback) {
    if (this._isCancelled) {
      callback();
    } else {
      this._callbacks.push(callback);
    }
  }
  throwIfCancelled() {
    if (this._isCancelled) {
      throw new CancellationError(this._reason);
    }
  }
};
var CancellationError = class extends Error {
  constructor(reason) {
    super(reason);
    this.name = "CancellationError";
  }
};
var RateLimiter = class {
  constructor(maxRequests = 10, windowMs = 6e4) {
    this.requests = [];
    this.maxRequests = maxRequests;
    this.windowMs = windowMs;
  }
  canMakeRequest() {
    this.cleanup();
    return this.requests.length < this.maxRequests;
  }
  recordRequest() {
    this.requests.push(Date.now());
  }
  getWaitTime() {
    this.cleanup();
    if (this.requests.length < this.maxRequests) {
      return 0;
    }
    const oldestRequest = this.requests[0];
    return oldestRequest + this.windowMs - Date.now();
  }
  cleanup() {
    const cutoff = Date.now() - this.windowMs;
    this.requests = this.requests.filter((timestamp) => timestamp > cutoff);
  }
};
var rateLimiter = new RateLimiter(10, 6e4);
function calculateBackoffDelay(retryCount, baseDelayMs) {
  const exponentialDelay = baseDelayMs * Math.pow(2, retryCount);
  const jitter = Math.random() * 1e3;
  return Math.min(exponentialDelay + jitter, 3e4);
}
function isRetryableError(statusCode) {
  return statusCode === 429 || statusCode >= 500 && statusCode < 600;
}
function extractErrorMessage(response) {
  var _a, _b;
  try {
    const body = response.json || response.text;
    if (typeof body === "object" && ((_a = body == null ? void 0 : body.error) == null ? void 0 : _a.message)) {
      return body.error.message;
    }
    if (typeof body === "string" && body.length < 200) {
      try {
        const parsed = JSON.parse(body);
        if ((_b = parsed == null ? void 0 : parsed.error) == null ? void 0 : _b.message) {
          return parsed.error.message;
        }
      } catch (e) {
        return body;
      }
    }
  } catch (e) {
  }
  return `HTTP ${response.status}`;
}
function getErrorWithRecovery(statusCode, message) {
  switch (statusCode) {
    case 401:
      return `Authentication failed: ${message}. Please check your API key in settings.`;
    case 403:
      return `Access denied: ${message}. Your API key may lack required permissions.`;
    case 429:
      return `Rate limited: ${message}. Please wait a moment before trying again.`;
    case 500:
    case 502:
    case 503:
    case 504:
      return `Server error: ${message}. The API is temporarily unavailable. Please try again later.`;
    default:
      return message;
  }
}
function sleep(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}
async function makeApiRequest(config, cancellationToken) {
  const {
    url,
    method,
    headers = {},
    body,
    timeout = 3e4,
    maxRetries = 3,
    retryDelayMs = 1e3
  } = config;
  if (!rateLimiter.canMakeRequest()) {
    const waitTime = rateLimiter.getWaitTime();
    logger.warn(CATEGORY, `Rate limit reached, need to wait ${waitTime}ms`);
    return {
      success: false,
      data: null,
      error: `Rate limited. Please wait ${Math.ceil(waitTime / 1e3)} seconds.`,
      statusCode: 429,
      retryCount: 0,
      cancelled: false
    };
  }
  let retryCount = 0;
  let lastError = "";
  let lastStatusCode = 0;
  while (retryCount <= maxRetries) {
    if (cancellationToken == null ? void 0 : cancellationToken.isCancelled) {
      logger.info(CATEGORY, "Request cancelled by user");
      return {
        success: false,
        data: null,
        error: cancellationToken.reason,
        statusCode: 0,
        retryCount,
        cancelled: true
      };
    }
    try {
      logger.debug(CATEGORY, `Making request attempt ${retryCount + 1}/${maxRetries + 1}`, {
        url,
        method,
        timeout
      });
      rateLimiter.recordRequest();
      const timeoutPromise = new Promise((_, reject) => {
        setTimeout(() => reject(new Error("Request timeout")), timeout);
      });
      const requestPromise = (0, import_obsidian2.requestUrl)({
        url,
        method,
        headers,
        body,
        throw: false
      });
      const response = await Promise.race([requestPromise, timeoutPromise]);
      lastStatusCode = response.status;
      if (response.status >= 200 && response.status < 300) {
        logger.info(CATEGORY, `Request successful`, { statusCode: response.status });
        return {
          success: true,
          data: response.json,
          error: null,
          statusCode: response.status,
          retryCount,
          cancelled: false
        };
      }
      lastError = extractErrorMessage(response);
      logger.warn(CATEGORY, `Request failed`, { statusCode: response.status, error: lastError });
      if (isRetryableError(response.status) && retryCount < maxRetries) {
        const delay = calculateBackoffDelay(retryCount, retryDelayMs);
        logger.info(CATEGORY, `Retrying in ${delay}ms (attempt ${retryCount + 2}/${maxRetries + 1})`);
        const startWait = Date.now();
        while (Date.now() - startWait < delay) {
          if (cancellationToken == null ? void 0 : cancellationToken.isCancelled) {
            return {
              success: false,
              data: null,
              error: cancellationToken.reason,
              statusCode: 0,
              retryCount,
              cancelled: true
            };
          }
          await sleep(100);
        }
        retryCount++;
        continue;
      }
      break;
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : "Unknown error";
      lastError = errorMessage;
      logger.error(CATEGORY, `Request exception`, { error: errorMessage });
      if (errorMessage === "Request timeout" && retryCount < maxRetries) {
        const delay = calculateBackoffDelay(retryCount, retryDelayMs);
        logger.info(CATEGORY, `Timeout, retrying in ${delay}ms`);
        await sleep(delay);
        retryCount++;
        continue;
      }
      break;
    }
  }
  const finalError = getErrorWithRecovery(lastStatusCode, lastError);
  return {
    success: false,
    data: null,
    error: finalError,
    statusCode: lastStatusCode,
    retryCount,
    cancelled: false
  };
}
async function callOpenAIChatApi(prompt, systemPrompt, config, cancellationToken) {
  var _a, _b, _c, _d;
  const scopedPrompt = scopeTextForApi(prompt, 8e3);
  const scopedSystem = scopeTextForApi(systemPrompt, 2e3);
  const response = await makeApiRequest({
    url: "https://api.openai.com/v1/chat/completions",
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      "Authorization": `Bearer ${config.apiKey}`
    },
    body: JSON.stringify({
      model: config.model,
      messages: [
        { role: "system", content: scopedSystem },
        { role: "user", content: scopedPrompt }
      ],
      max_tokens: config.maxTokens,
      temperature: config.temperature
    }),
    timeout: config.timeout || 6e4,
    maxRetries: config.maxRetries || 3
  }, cancellationToken);
  if (!response.success) {
    return {
      ...response,
      data: null
    };
  }
  const content = (_d = (_c = (_b = (_a = response.data) == null ? void 0 : _a.choices) == null ? void 0 : _b[0]) == null ? void 0 : _c.message) == null ? void 0 : _d.content;
  if (!content) {
    return {
      success: false,
      data: null,
      error: "Empty response from API",
      statusCode: response.statusCode,
      retryCount: response.retryCount,
      cancelled: false
    };
  }
  return {
    success: true,
    data: { content },
    error: null,
    statusCode: response.statusCode,
    retryCount: response.retryCount,
    cancelled: false
  };
}
async function callWhisperApi(audioBlob, apiKey, model = "whisper-1", language, cancellationToken) {
  var _a;
  if (cancellationToken == null ? void 0 : cancellationToken.isCancelled) {
    return {
      success: false,
      data: null,
      error: cancellationToken.reason,
      statusCode: 0,
      retryCount: 0,
      cancelled: true
    };
  }
  const formData = new FormData();
  formData.append("file", audioBlob, "audio.webm");
  formData.append("model", model);
  if (language && language !== "auto") {
    formData.append("language", language);
  }
  try {
    const controller = new AbortController();
    cancellationToken == null ? void 0 : cancellationToken.onCancel(() => {
      controller.abort();
    });
    const response = await fetch("https://api.openai.com/v1/audio/transcriptions", {
      method: "POST",
      headers: {
        "Authorization": `Bearer ${apiKey}`
      },
      body: formData,
      signal: controller.signal
    });
    if (!response.ok) {
      const errorText = await response.text();
      let errorMessage = `HTTP ${response.status}`;
      try {
        const errorJson = JSON.parse(errorText);
        errorMessage = ((_a = errorJson == null ? void 0 : errorJson.error) == null ? void 0 : _a.message) || errorMessage;
      } catch (e) {
        if (errorText.length < 200) {
          errorMessage = errorText;
        }
      }
      return {
        success: false,
        data: null,
        error: getErrorWithRecovery(response.status, errorMessage),
        statusCode: response.status,
        retryCount: 0,
        cancelled: false
      };
    }
    const data = await response.json();
    return {
      success: true,
      data: { text: data.text },
      error: null,
      statusCode: response.status,
      retryCount: 0,
      cancelled: false
    };
  } catch (error) {
    if (error instanceof Error && error.name === "AbortError") {
      return {
        success: false,
        data: null,
        error: "Request cancelled",
        statusCode: 0,
        retryCount: 0,
        cancelled: true
      };
    }
    const errorMessage = error instanceof Error ? error.message : "Unknown error";
    logger.error(CATEGORY, "Whisper API error", { error: errorMessage });
    return {
      success: false,
      data: null,
      error: errorMessage,
      statusCode: 0,
      retryCount: 0,
      cancelled: false
    };
  }
}
function setRateLimitConfig(maxRequests, windowMs) {
  Object.assign(rateLimiter, new RateLimiter(maxRequests, windowMs));
}

// src/gpt-service.ts
var CATEGORY2 = "GPTService";
async function callGptApi(prompt, systemPrompt, apiKey, model, maxTokens, temperature, cancellationToken, timeoutSeconds = 60, maxRetries = 3) {
  var _a;
  if (!apiKey) {
    logger.warn(CATEGORY2, "No API key configured");
    return { success: false, content: null, errorMessage: "No API key configured" };
  }
  logger.info(CATEGORY2, `Calling GPT API`, { model, maxTokens, temperature });
  const config = {
    apiKey,
    model,
    maxTokens,
    temperature,
    timeout: timeoutSeconds * 1e3,
    maxRetries
  };
  const response = await callOpenAIChatApi(
    prompt,
    systemPrompt,
    config,
    cancellationToken
  );
  if (response.cancelled) {
    logger.info(CATEGORY2, "GPT API call was cancelled");
    return {
      success: false,
      content: null,
      errorMessage: "Request cancelled",
      cancelled: true
    };
  }
  if (!response.success) {
    logger.error(CATEGORY2, "GPT API call failed", { error: response.error });
    return {
      success: false,
      content: null,
      errorMessage: response.error || "Unknown error"
    };
  }
  const content = (_a = response.data) == null ? void 0 : _a.content;
  if (!content) {
    logger.warn(CATEGORY2, "GPT API returned empty content");
    return {
      success: false,
      content: null,
      errorMessage: "Empty response from API"
    };
  }
  logger.info(CATEGORY2, `GPT response received`, { contentLength: content.length });
  return { success: true, content, errorMessage: null };
}
function extractJsonFromResponse(response) {
  const codeBlockMatch = response.match(/```(?:json)?\s*([\s\S]*?)```/);
  if (codeBlockMatch) {
    return codeBlockMatch[1].trim();
  }
  const jsonMatch = response.match(/\{[\s\S]*\}/);
  if (jsonMatch) {
    return jsonMatch[0];
  }
  return response;
}
function generateFallbackTitle() {
  const now = /* @__PURE__ */ new Date();
  return `Task-${now.getFullYear()}${String(now.getMonth() + 1).padStart(2, "0")}${String(now.getDate()).padStart(2, "0")}-${String(now.getHours()).padStart(2, "0")}${String(now.getMinutes()).padStart(2, "0")}`;
}
function ensureValidTitle(title, fallbackSource) {
  const trimmedTitle = (title || "").trim();
  if (trimmedTitle.length > 0) {
    return trimmedTitle;
  }
  const trimmedFallback = (fallbackSource || "").trim();
  if (trimmedFallback.length > 0) {
    return trimmedFallback.substring(0, 50);
  }
  return generateFallbackTitle();
}
function parseTaskSuggestion(response) {
  try {
    const jsonStr = extractJsonFromResponse(response);
    const parsed = JSON.parse(jsonStr);
    return {
      title: ensureValidTitle(parsed.title, parsed.objective),
      objective: parsed.objective || "",
      importance: parsed.importance || "",
      suggestedEpic: parsed.suggestedEpic || null,
      suggestedProject: parsed.suggestedProject || null,
      priority: parsed.priority || "medium",
      complexity: parsed.complexity || "moderate",
      subtasks: Array.isArray(parsed.subtasks) ? parsed.subtasks : []
    };
  } catch (error) {
    console.error("[GPT Task Manager] Failed to parse task suggestion:", error);
    return null;
  }
}
function parseTaskBreakdown(response) {
  try {
    const jsonStr = extractJsonFromResponse(response);
    const parsed = JSON.parse(jsonStr);
    if (!Array.isArray(parsed.tasks)) {
      return null;
    }
    return {
      tasks: parsed.tasks.map((task, taskIndex) => {
        var _a;
        return {
          title: ensureValidTitle(task.title, task.objective) || `Subtask-${taskIndex + 1}`,
          objective: task.objective || "",
          priority: task.priority || "medium",
          dependsOn: (_a = task.dependsOn) != null ? _a : null
        };
      })
    };
  } catch (error) {
    console.error("[GPT Task Manager] Failed to parse task breakdown:", error);
    return null;
  }
}
function fillPromptTemplate(template, values) {
  let result = template;
  for (const [key, value] of Object.entries(values)) {
    result = result.replace(
      new RegExp(`\\{\\{${key}\\}\\}`, "g"),
      () => value
    );
  }
  return result;
}

// src/voice.ts
var import_obsidian3 = require("obsidian");
var CATEGORY3 = "Voice";
var VoiceRecordingModal = class extends import_obsidian3.Modal {
  constructor(app, onComplete, onCancel) {
    super(app);
    this.mediaRecorder = null;
    this.audioChunks = [];
    this.stream = null;
    this.timerInterval = null;
    this.startTime = 0;
    this.timerEl = null;
    this.statusEl = null;
    this.startBtn = null;
    this.stopBtn = null;
    this.recordingDot = null;
    this.onComplete = onComplete;
    this.onCancel = onCancel;
  }
  async onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("gpt-task-manager-recording-modal");
    contentEl.createEl("h3", { text: "\u{1F3A4} Voice Task Capture" });
    const indicatorEl = contentEl.createDiv({ cls: "recording-indicator" });
    this.recordingDot = indicatorEl.createDiv({ cls: "recording-dot" });
    this.statusEl = indicatorEl.createSpan({ text: "Ready to record" });
    this.timerEl = contentEl.createDiv({ cls: "recording-timer", text: "00:00" });
    const instructionsEl = contentEl.createDiv({ cls: "recording-instructions" });
    instructionsEl.createEl("p", { text: "Speak your task naturally. Examples:" });
    const examplesList = instructionsEl.createEl("ul");
    examplesList.createEl("li", { text: '"Create login page for the app"' });
    examplesList.createEl("li", { text: '"High priority: Fix payment bug by Friday"' });
    examplesList.createEl("li", { text: '"Add user profile settings to Freedom Runway project"' });
    const buttonsEl = contentEl.createDiv({ cls: "recording-buttons" });
    this.startBtn = buttonsEl.createEl("button", {
      text: "\u{1F399}\uFE0F Start Recording",
      cls: "mod-cta"
    });
    this.startBtn.onclick = () => {
      this.initiateRecording();
    };
    this.stopBtn = buttonsEl.createEl("button", {
      text: "\u23F9\uFE0F Stop & Process",
      cls: "mod-warning"
    });
    this.stopBtn.style.display = "none";
    this.stopBtn.onclick = () => this.stopRecording();
    const cancelBtn = buttonsEl.createEl("button", { text: "Cancel" });
    cancelBtn.onclick = () => this.cancelRecording();
  }
  async initiateRecording() {
    if (this.startBtn)
      this.startBtn.style.display = "none";
    if (this.stopBtn)
      this.stopBtn.style.display = "inline-block";
    if (this.statusEl)
      this.statusEl.textContent = "Recording...";
    if (this.recordingDot)
      this.recordingDot.addClass("active");
    await this.startRecording();
  }
  async startRecording() {
    try {
      this.stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      const mimeType = this.getSupportedMimeType();
      const options = {};
      if (mimeType) {
        options.mimeType = mimeType;
      }
      this.mediaRecorder = new MediaRecorder(this.stream, options);
      this.audioChunks = [];
      this.mediaRecorder.ondataavailable = (event) => {
        if (event.data.size > 0) {
          this.audioChunks.push(event.data);
        }
      };
      this.mediaRecorder.onstop = async () => {
        var _a;
        const mimeType2 = ((_a = this.mediaRecorder) == null ? void 0 : _a.mimeType) || "audio/webm";
        const audioBlob = new Blob(this.audioChunks, { type: mimeType2 });
        this.cleanup();
        try {
          await this.onComplete(audioBlob);
        } catch (error) {
          console.error("[GPT Task Manager] Recording processing failed:", error);
          new import_obsidian3.Notice("Processing failed");
        }
        this.close();
      };
      this.mediaRecorder.onerror = () => {
        console.error("[GPT Task Manager] MediaRecorder error");
        new import_obsidian3.Notice("Recording error occurred");
        this.cancelRecording();
      };
      this.mediaRecorder.start(1e3);
      this.startTime = Date.now();
      this.startTimer();
    } catch (error) {
      console.error("[GPT Task Manager] Failed to start recording:", error);
      new import_obsidian3.Notice("Failed to access microphone. Please check permissions.");
      this.close();
      this.onCancel();
    }
  }
  getSupportedMimeType() {
    const mimeTypes = [
      "audio/mp4",
      "audio/webm;codecs=opus",
      "audio/webm",
      "audio/ogg;codecs=opus",
      "audio/ogg",
      "audio/mpeg"
    ];
    for (const mimeType of mimeTypes) {
      if (MediaRecorder.isTypeSupported(mimeType)) {
        return mimeType;
      }
    }
    return null;
  }
  startTimer() {
    this.timerInterval = window.setInterval(() => {
      const elapsed = Math.floor((Date.now() - this.startTime) / 1e3);
      const minutes = Math.floor(elapsed / 60).toString().padStart(2, "0");
      const seconds = (elapsed % 60).toString().padStart(2, "0");
      if (this.timerEl) {
        this.timerEl.textContent = `${minutes}:${seconds}`;
      }
    }, 1e3);
  }
  stopRecording() {
    if (this.mediaRecorder && this.mediaRecorder.state === "recording") {
      if (this.statusEl)
        this.statusEl.textContent = "Processing...";
      if (this.stopBtn) {
        this.stopBtn.disabled = true;
        this.stopBtn.textContent = "Processing...";
      }
      if (this.recordingDot)
        this.recordingDot.removeClass("active");
      this.mediaRecorder.stop();
    }
  }
  cancelRecording() {
    this.cleanup();
    this.close();
    this.onCancel();
  }
  cleanup() {
    if (this.timerInterval) {
      window.clearInterval(this.timerInterval);
      this.timerInterval = null;
    }
    if (this.stream) {
      this.stream.getTracks().forEach((track) => track.stop());
      this.stream = null;
    }
  }
  onClose() {
    this.cleanup();
    const { contentEl } = this;
    contentEl.empty();
  }
};
async function transcribeAudio(audioBlob, apiKey, model = "whisper-1", language, cancellationToken) {
  var _a;
  logger.info(CATEGORY3, "Starting audio transcription", {
    blobSize: audioBlob.size,
    model,
    language: language || "auto"
  });
  const response = await callWhisperApi(
    audioBlob,
    apiKey,
    model,
    language,
    cancellationToken
  );
  if (response.cancelled) {
    logger.info(CATEGORY3, "Transcription was cancelled");
    throw new Error("Transcription cancelled");
  }
  if (!response.success) {
    logger.error(CATEGORY3, "Transcription failed", { error: response.error });
    throw new Error(response.error || "Transcription failed");
  }
  const text = (_a = response.data) == null ? void 0 : _a.text;
  if (!text) {
    logger.warn(CATEGORY3, "Transcription returned empty text");
    throw new Error("Transcription returned empty result");
  }
  logger.info(CATEGORY3, "Transcription successful", { textLength: text.length });
  return text.trim();
}
function parseVoiceTaskInput(transcription) {
  const result = {
    rawText: transcription,
    taskTitle: "",
    description: "",
    epic: "",
    project: "",
    priority: ""
  };
  const cleanedText = transcription.trim();
  const priorityPatterns = [
    { pattern: /(?:high|높은|urgent|긴급)\s*priority/i, priority: "high" },
    { pattern: /priority[:\s]*(high|높음|urgent|긴급)/i, priority: "high" },
    { pattern: /(?:critical|크리티컬|매우\s*중요)/i, priority: "critical" },
    { pattern: /(?:low|낮은)\s*priority/i, priority: "low" },
    { pattern: /priority[:\s]*(low|낮음)/i, priority: "low" }
  ];
  for (const { pattern, priority } of priorityPatterns) {
    if (pattern.test(cleanedText)) {
      result.priority = priority;
      break;
    }
  }
  const projectPatterns = [
    /(?:for|in|to)\s+(?:the\s+)?(.+?)\s+(?:project|프로젝트)/i,
    /(?:project|프로젝트)[:\s]+(.+?)(?:\.|,|$)/i
  ];
  for (const pattern of projectPatterns) {
    const match = cleanedText.match(pattern);
    if (match) {
      result.project = match[1].trim();
      break;
    }
  }
  const epicPatterns = [
    /(?:for|in|to)\s+(?:the\s+)?(.+?)\s+(?:epic|에픽)/i,
    /(?:epic|에픽)[:\s]+(.+?)(?:\.|,|$)/i
  ];
  for (const pattern of epicPatterns) {
    const match = cleanedText.match(pattern);
    if (match) {
      result.epic = match[1].trim();
      break;
    }
  }
  let taskText = cleanedText.replace(/(?:high|low|critical|높은|낮은|긴급|urgent)\s*priority[:\s]*/gi, "").replace(/priority[:\s]*(?:high|low|critical|medium|높음|낮음|중간)/gi, "").replace(/(?:for|in|to)\s+(?:the\s+)?.+?\s+(?:project|epic|프로젝트|에픽)/gi, "").replace(/(?:project|epic|프로젝트|에픽)[:\s]+.+?(?:\.|,|$)/gi, "").trim();
  taskText = taskText.replace(/\s+/g, " ").replace(/^[,.\s]+|[,.\s]+$/g, "").trim();
  result.taskTitle = taskText;
  return result;
}

// src/context-loader.ts
var import_obsidian4 = require("obsidian");
function loadGoals(app, goalsFolder) {
  const goals = [];
  const folder = app.vault.getAbstractFileByPath(goalsFolder);
  if (!folder || !(folder instanceof import_obsidian4.TFolder)) {
    return goals;
  }
  for (const child of folder.children) {
    if (child instanceof import_obsidian4.TFile && child.extension === "md") {
      const cache = app.metadataCache.getFileCache(child);
      if (!(cache == null ? void 0 : cache.frontmatter))
        continue;
      const frontmatter = cache.frontmatter;
      const type = extractFrontmatterString(frontmatter.Type);
      if (type.toLowerCase().includes("goal")) {
        goals.push({
          name: child.basename,
          path: child.path,
          area: extractFrontmatterString(frontmatter.Area),
          status: extractFrontmatterString(frontmatter.Status),
          milestones: []
        });
      }
    }
  }
  return goals;
}
function loadProjects(app, projectsFolder) {
  const projects = [];
  const folder = app.vault.getAbstractFileByPath(projectsFolder);
  if (!folder || !(folder instanceof import_obsidian4.TFolder)) {
    return projects;
  }
  const processFolder = (currentFolder) => {
    for (const child of currentFolder.children) {
      if (child instanceof import_obsidian4.TFile && child.extension === "md") {
        const cache = app.metadataCache.getFileCache(child);
        if (!(cache == null ? void 0 : cache.frontmatter))
          continue;
        const frontmatter = cache.frontmatter;
        const type = extractFrontmatterString(frontmatter.Type);
        if (type.toLowerCase().includes("project")) {
          projects.push({
            name: child.basename,
            path: child.path,
            area: extractFrontmatterString(frontmatter.Area),
            goal: extractFrontmatterString(frontmatter.Goal),
            status: extractFrontmatterString(frontmatter.Status)
          });
        }
      } else if (child instanceof import_obsidian4.TFolder) {
        processFolder(child);
      }
    }
  };
  processFolder(folder);
  return projects;
}
function loadEpics(app, epicsFolder) {
  const epics = [];
  const folder = app.vault.getAbstractFileByPath(epicsFolder);
  if (!folder || !(folder instanceof import_obsidian4.TFolder)) {
    return epics;
  }
  for (const child of folder.children) {
    if (child instanceof import_obsidian4.TFile && child.extension === "md") {
      const cache = app.metadataCache.getFileCache(child);
      if (!(cache == null ? void 0 : cache.frontmatter))
        continue;
      const frontmatter = cache.frontmatter;
      const type = extractFrontmatterString(frontmatter.Type);
      if (type.toLowerCase().includes("epic")) {
        epics.push({
          name: child.basename,
          path: child.path,
          area: extractFrontmatterString(frontmatter.Area),
          goal: extractFrontmatterString(frontmatter.Goal),
          project: extractFrontmatterString(frontmatter.Project),
          milestone: extractFrontmatterString(frontmatter.Milestone),
          status: extractFrontmatterString(frontmatter.Status),
          description: extractFrontmatterString(frontmatter.Description)
        });
      }
    }
  }
  return epics;
}
function loadActiveTasks(app, tasksFolder) {
  const tasks = [];
  const folder = app.vault.getAbstractFileByPath(tasksFolder);
  if (!folder || !(folder instanceof import_obsidian4.TFolder)) {
    return tasks;
  }
  const processFolder = (currentFolder) => {
    for (const child of currentFolder.children) {
      if (child instanceof import_obsidian4.TFile && child.extension === "md") {
        const cache = app.metadataCache.getFileCache(child);
        if (!(cache == null ? void 0 : cache.frontmatter))
          continue;
        const frontmatter = cache.frontmatter;
        const type = extractFrontmatterString(frontmatter.Type);
        const status = extractFrontmatterString(frontmatter.Status);
        if (type.toLowerCase().includes("task") && !status.toLowerCase().includes("completed")) {
          tasks.push({
            name: child.basename,
            path: child.path,
            area: extractFrontmatterString(frontmatter.Area),
            goal: extractFrontmatterString(frontmatter.Goal),
            project: extractFrontmatterString(frontmatter.Project),
            epic: extractFrontmatterString(frontmatter.Epic),
            status,
            priority: extractFrontmatterString(frontmatter.Priority),
            due: extractFrontmatterString(frontmatter.Due)
          });
        }
      } else if (child instanceof import_obsidian4.TFolder) {
        processFolder(child);
      }
    }
  };
  processFolder(folder);
  return tasks;
}
function loadUserContext(app, goalsFolder, projectsFolder, epicsFolder, tasksFolder) {
  return {
    goals: loadGoals(app, goalsFolder),
    projects: loadProjects(app, projectsFolder),
    epics: loadEpics(app, epicsFolder),
    activeTasks: loadActiveTasks(app, tasksFolder)
  };
}
function formatContextForPrompt(context) {
  const goals = context.goals.map((goal) => `- ${goal.name} (${goal.status || "active"}) - Area: ${goal.area || "none"}`).join("\n") || "No goals defined";
  const projects = context.projects.map((project) => `- ${project.name} (${project.status || "active"}) - Goal: ${project.goal || "none"}`).join("\n") || "No projects defined";
  const epics = context.epics.map((epic) => `- ${epic.name} (${epic.status || "backlog"}) - Project: ${epic.project || "none"}, Goal: ${epic.goal || "none"}`).join("\n") || "No epics defined";
  const tasks = context.activeTasks.slice(0, 20).map((task) => `- ${task.name} (${task.status || "backlog"}, ${task.priority || "medium"}) - Epic: ${task.epic || "none"}`).join("\n") || "No active tasks";
  return { goals, projects, epics, tasks };
}
function extractFrontmatterString(value) {
  if (!value)
    return "";
  if (typeof value === "string") {
    return value.replace(/\[\[([^\]|]+)(?:\|[^\]]+)?\]\]/g, "$1").trim();
  }
  if (Array.isArray(value)) {
    return value.map((item) => extractFrontmatterString(item)).filter(Boolean).join(", ");
  }
  return String(value);
}
async function getEpicMetadata(app, epicName, epicsFolder) {
  const epicPath = `${epicsFolder}/${epicName}.md`;
  const epicFile = app.vault.getAbstractFileByPath(epicPath);
  if (!epicFile || !(epicFile instanceof import_obsidian4.TFile)) {
    return null;
  }
  const cache = app.metadataCache.getFileCache(epicFile);
  if (!(cache == null ? void 0 : cache.frontmatter)) {
    return null;
  }
  const frontmatter = cache.frontmatter;
  return {
    area: extractFrontmatterString(frontmatter.Area),
    goal: extractFrontmatterString(frontmatter.Goal),
    project: extractFrontmatterString(frontmatter.Project),
    milestone: extractFrontmatterString(frontmatter.Milestone)
  };
}

// src/task-creator.ts
var import_obsidian5 = require("obsidian");
async function ensureFolderExists(app, folderPath) {
  const normalizedPath = (0, import_obsidian5.normalizePath)(folderPath);
  const existingFolder = app.vault.getAbstractFileByPath(normalizedPath);
  if (existingFolder && existingFolder instanceof import_obsidian5.TFolder) {
    return;
  }
  const pathParts = normalizedPath.split("/").filter((part) => part.length > 0);
  const foldersToCreate = [];
  let currentPath = "";
  for (const part of pathParts) {
    currentPath = currentPath ? `${currentPath}/${part}` : part;
    const existing = app.vault.getAbstractFileByPath(currentPath);
    if (!existing) {
      foldersToCreate.push(currentPath);
    } else if (existing instanceof import_obsidian5.TFile) {
      throw new Error(`Cannot create folder "${currentPath}": a file exists at this path`);
    }
  }
  for (const folderToCreate of foldersToCreate) {
    try {
      const recheck = app.vault.getAbstractFileByPath(folderToCreate);
      if (!recheck) {
        await app.vault.createFolder(folderToCreate);
      }
    } catch (error) {
      const afterError = app.vault.getAbstractFileByPath(folderToCreate);
      if (afterError && afterError instanceof import_obsidian5.TFolder) {
        continue;
      }
      const errorMessage = error instanceof Error ? error.message : String(error);
      throw new Error(`Failed to create folder "${folderToCreate}": ${errorMessage}`);
    }
  }
}
function sanitizeFilename(filename, fallbackDefault = "Untitled Task") {
  const sanitized = filename.replace(/[\\/:*?"<>|]/g, "-").replace(/\s+/g, " ").trim().substring(0, 100);
  if (!sanitized || sanitized.length === 0) {
    const rawTrimmed = filename.trim().substring(0, 100);
    if (rawTrimmed && rawTrimmed.length > 0) {
      return rawTrimmed.replace(/[\\/:]/g, "-");
    }
    return fallbackDefault;
  }
  return sanitized;
}
function generateTaskContent(params, settings) {
  const timestamp = /* @__PURE__ */ new Date();
  const createdAt = formatDateTime(timestamp);
  const updatedAt = formatDateTime(timestamp);
  const formatLink = (value) => {
    if (!value)
      return "Empty";
    if (value.startsWith("[[") && value.endsWith("]]")) {
      return `"${value}"`;
    }
    return `"[[${value}]]"`;
  };
  const formatString = (value) => {
    if (!value)
      return "";
    return value.replace(/"/g, '\\"').replace(/\n/g, " ");
  };
  const formatTags = (tags) => {
    const YAML_INDENT = "  ";
    if (!tags || tags.length === 0) {
      return `${YAML_INDENT}- tasks`;
    }
    return tags.map((tag) => `${YAML_INDENT}- ${tag.startsWith("#") ? tag.substring(1) : tag}`).join("\n");
  };
  const frontmatterLines = [
    "---",
    'Type: "[[Tasks]]"',
    `Area: ${formatLink(params.area)}`,
    `Goal: ${formatLink(params.goal)}`,
    `Project: ${formatLink(params.project)}`,
    `Epic: ${formatLink(params.epic)}`,
    `Status: ${params.status || settings.defaultStatus}`,
    `Priority: ${params.priority || settings.defaultPriority}`,
    `Due: ${params.due || ""}`,
    `Created: "${createdAt}"`,
    `Updated: "${updatedAt}"`,
    "tags:",
    formatTags(params.tags),
    "Cover: ",
    `Description: "${formatString(params.objective)}"`,
    "Topics: ",
    `Parent: ${params.parent ? formatLink(params.parent) : "Empty"}`,
    "---"
  ];
  const frontmatter = frontmatterLines.join("\n");
  const body = `
## \u{1F504} Sync
- [ ] ${params.title}

## \u{1F3AF} Objective
> What needs to be accomplished:
- ${params.objective || ""}

> Why it matters:
- ${params.importance || ""}


## \u2699\uFE0F Progress Log

> **Updates / checkpoints:**
> Date - 


## \u{1F9E0} Notes / Insights
>


## \u{1F4A1} Reflection
> What was learned or decided:
- 

> What to improve next time:
- 
  
  

---
### \u{1F517} Related Notes
- 
`;
  return frontmatter + body;
}
function generateTaskFromSuggestion(suggestion, epicMetadata, settings) {
  const params = {
    title: suggestion.title,
    objective: suggestion.objective,
    importance: suggestion.importance,
    area: (epicMetadata == null ? void 0 : epicMetadata.area) || "",
    goal: (epicMetadata == null ? void 0 : epicMetadata.goal) || "",
    project: suggestion.suggestedProject || (epicMetadata == null ? void 0 : epicMetadata.project) || "",
    epic: suggestion.suggestedEpic || "",
    priority: suggestion.priority,
    tags: ["tasks"]
  };
  return generateTaskContent(params, settings);
}
async function createTaskFile(app, content, title, epicName, settings) {
  const sanitizedTitle = sanitizeFilename(title, `Task-${Date.now()}`);
  let taskPath;
  await ensureFolderExists(app, settings.tasksFolder);
  if (epicName) {
    const sanitizedEpicName = sanitizeFilename(epicName, "Untitled Epic");
    const epicFolder = `${settings.tasksFolder}/active epic folder/${sanitizedEpicName}`;
    await ensureFolderExists(app, `${settings.tasksFolder}/active epic folder`);
    await ensureFolderExists(app, epicFolder);
    taskPath = `${epicFolder}/${sanitizedTitle}.md`;
  } else {
    taskPath = `${settings.tasksFolder}/${sanitizedTitle}.md`;
  }
  const normalizedPath = (0, import_obsidian5.normalizePath)(taskPath);
  const existingFile = app.vault.getAbstractFileByPath(normalizedPath);
  if (existingFile instanceof import_obsidian5.TFile) {
    let counter = 1;
    let newPath = taskPath;
    while (app.vault.getAbstractFileByPath(newPath)) {
      newPath = taskPath.replace(".md", ` (${counter}).md`);
      counter++;
    }
    taskPath = newPath;
  }
  const file = await app.vault.create((0, import_obsidian5.normalizePath)(taskPath), content);
  return file;
}
async function createTasksFromBreakdown(app, breakdown, epicName, epicMetadata, settings) {
  const createdFiles = [];
  const indexToFile = /* @__PURE__ */ new Map();
  const forwardDependencies = [];
  await ensureFolderExists(app, settings.tasksFolder);
  if (epicName) {
    const sanitizedEpicName = sanitizeFilename(epicName, "Untitled Epic");
    await ensureFolderExists(app, `${settings.tasksFolder}/active epic folder`);
    await ensureFolderExists(app, `${settings.tasksFolder}/active epic folder/${sanitizedEpicName}`);
  }
  for (let taskIndex = 0; taskIndex < breakdown.tasks.length; taskIndex++) {
    const task = breakdown.tasks[taskIndex];
    let parentBasename = void 0;
    if (task.dependsOn !== null && task.dependsOn !== void 0) {
      const dependsOnIndex = task.dependsOn;
      if (dependsOnIndex >= 0 && dependsOnIndex < breakdown.tasks.length) {
        if (dependsOnIndex < taskIndex) {
          const dependsOnFile = indexToFile.get(dependsOnIndex);
          if (dependsOnFile) {
            parentBasename = dependsOnFile.basename;
          }
        } else if (dependsOnIndex > taskIndex) {
          forwardDependencies.push({ taskIndex, dependsOnIndex });
        }
      }
    }
    const params = {
      title: task.title,
      objective: task.objective,
      area: (epicMetadata == null ? void 0 : epicMetadata.area) || "",
      goal: (epicMetadata == null ? void 0 : epicMetadata.goal) || "",
      project: (epicMetadata == null ? void 0 : epicMetadata.project) || "",
      epic: epicName,
      priority: task.priority,
      parent: parentBasename,
      tags: ["tasks"]
    };
    const content = generateTaskContent(params, settings);
    try {
      const file = await createTaskFile(app, content, task.title, epicName, settings);
      createdFiles.push(file);
      indexToFile.set(taskIndex, file);
    } catch (error) {
      console.error(`[GPT Task Manager] Failed to create task: ${task.title}`, error);
      new import_obsidian5.Notice(`Failed to create task: ${task.title}`);
    }
  }
  for (const { taskIndex, dependsOnIndex } of forwardDependencies) {
    const file = indexToFile.get(taskIndex);
    const dependsOnFile = indexToFile.get(dependsOnIndex);
    if (file && dependsOnFile) {
      try {
        await updateTaskParent(app, file, dependsOnFile.basename);
      } catch (error) {
        console.error(`[GPT Task Manager] Failed to update dependency for: ${file.basename}`, error);
      }
    }
  }
  return createdFiles;
}
async function updateTaskParent(app, file, parentBasename) {
  const content = await app.vault.read(file);
  const frontmatterMatch = content.match(/^---\n([\s\S]*?)\n---/);
  if (!frontmatterMatch) {
    return;
  }
  const frontmatter = frontmatterMatch[1];
  const parentPattern = /^Parent:\s*.*/m;
  if (parentPattern.test(frontmatter)) {
    const newFrontmatter = frontmatter.replace(
      parentPattern,
      `Parent: "[[${parentBasename}]]"`
    );
    const newContent = content.replace(
      /^---\n[\s\S]*?\n---/,
      `---
${newFrontmatter}
---`
    );
    await app.vault.modify(file, newContent);
  }
}
function buildBreakdownSummaries(breakdown, epicName, settings) {
  const summaries = [];
  const sanitizedEpicName = sanitizeFilename(epicName, "Untitled Epic");
  const targetFolder = `${settings.tasksFolder}/active epic folder/${sanitizedEpicName}`;
  const indexToTitle = /* @__PURE__ */ new Map();
  breakdown.tasks.forEach((task, index) => {
    indexToTitle.set(index, task.title);
  });
  for (let taskIndex = 0; taskIndex < breakdown.tasks.length; taskIndex++) {
    const task = breakdown.tasks[taskIndex];
    let dependsOnTask = null;
    if (task.dependsOn !== null && task.dependsOn !== void 0) {
      const dependsOnIndex = task.dependsOn;
      if (dependsOnIndex >= 0 && dependsOnIndex < breakdown.tasks.length && indexToTitle.has(dependsOnIndex)) {
        dependsOnTask = indexToTitle.get(dependsOnIndex) || null;
      }
    }
    summaries.push({
      title: task.title,
      targetFolder,
      epic: epicName,
      priority: task.priority || settings.defaultPriority,
      dependsOnTask
    });
  }
  return summaries;
}
function buildSuggestionSummary(suggestion, epicName, settings) {
  let targetFolder;
  if (epicName) {
    const sanitizedEpicName = sanitizeFilename(epicName, "Untitled Epic");
    targetFolder = `${settings.tasksFolder}/active epic folder/${sanitizedEpicName}`;
  } else {
    targetFolder = settings.tasksFolder;
  }
  return {
    title: suggestion.title,
    targetFolder,
    epic: epicName,
    priority: suggestion.priority || settings.defaultPriority,
    dependsOnTask: null
  };
}
function formatDateTime(date) {
  const year = date.getFullYear();
  const month = String(date.getMonth() + 1).padStart(2, "0");
  const day = String(date.getDate()).padStart(2, "0");
  const hours = String(date.getHours()).padStart(2, "0");
  const minutes = String(date.getMinutes()).padStart(2, "0");
  return `${year}-${month}-${day} ${hours}:${minutes}`;
}
var TaskConfirmationModal = class extends import_obsidian5.Modal {
  constructor(app, summaries, operationType, epicName, onConfirm, onCancel) {
    super(app);
    this.resolved = false;
    this.summaries = summaries;
    this.operationType = operationType;
    this.epicName = epicName;
    this.onConfirm = onConfirm;
    this.onCancel = onCancel;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("gpt-task-manager-confirmation-modal");
    const headerText = this.operationType === "breakdown" ? `\u{1F4CB} Confirm Task Creation (${this.summaries.length} tasks)` : "\u{1F4CB} Confirm Task Creation";
    contentEl.createEl("h2", { text: headerText });
    const descText = this.operationType === "breakdown" ? "The following tasks will be created:" : "The following task will be created:";
    contentEl.createEl("p", { text: descText, cls: "modal-description" });
    const listEl = contentEl.createDiv({ cls: "confirmation-task-list" });
    for (let summaryIndex = 0; summaryIndex < this.summaries.length; summaryIndex++) {
      const summary = this.summaries[summaryIndex];
      const itemEl = listEl.createDiv({ cls: "confirmation-task-item" });
      const titleRow = itemEl.createDiv({ cls: "task-title-row" });
      if (this.operationType === "breakdown") {
        titleRow.createEl("span", {
          text: `${summaryIndex + 1}. `,
          cls: "task-number"
        });
      }
      titleRow.createEl("span", { text: summary.title, cls: "task-title" });
      const detailsEl = itemEl.createDiv({ cls: "task-details" });
      detailsEl.createEl("span", {
        text: summary.priority,
        cls: `priority-badge priority-${summary.priority}`
      });
      if (summary.epic) {
        detailsEl.createEl("span", {
          text: `Epic: ${summary.epic}`,
          cls: "task-epic"
        });
      }
      if (summary.dependsOnTask) {
        detailsEl.createEl("span", {
          text: `\u2192 Depends on: ${summary.dependsOnTask}`,
          cls: "task-dependency"
        });
      }
      const folderEl = itemEl.createDiv({ cls: "task-folder" });
      folderEl.createEl("span", {
        text: `\u{1F4C1} ${summary.targetFolder}`,
        cls: "folder-path"
      });
    }
    const buttonsEl = contentEl.createDiv({ cls: "modal-button-container" });
    const cancelBtn = buttonsEl.createEl("button", { text: "Cancel" });
    cancelBtn.onclick = () => {
      this.resolved = true;
      this.close();
      this.onCancel();
    };
    const confirmText = this.operationType === "breakdown" ? `\u2713 Create ${this.summaries.length} Tasks` : "\u2713 Create Task";
    const confirmBtn = buttonsEl.createEl("button", {
      text: confirmText,
      cls: "mod-cta"
    });
    confirmBtn.onclick = () => {
      this.resolved = true;
      this.close();
      this.onConfirm();
    };
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
    if (!this.resolved) {
      this.resolved = true;
      this.onCancel();
    }
  }
};
function showTaskConfirmation(app, summaries, operationType, epicName) {
  return new Promise((resolve) => {
    new TaskConfirmationModal(
      app,
      summaries,
      operationType,
      epicName,
      () => resolve(true),
      () => resolve(false)
    ).open();
  });
}

// src/cache.ts
var import_obsidian6 = require("obsidian");
var CATEGORY4 = "Cache";
var DEFAULT_CONFIG = {
  ttlMs: 6e4,
  // 1 minute
  maxEntries: 50,
  debounceMs: 500
};
var Cache = class {
  constructor(config = {}) {
    this.entries = /* @__PURE__ */ new Map();
    this.accessOrder = [];
    this.globalVersion = 0;
    this.config = { ...DEFAULT_CONFIG, ...config };
  }
  /**
   * Get a cached value
   */
  get(key) {
    const entry = this.entries.get(key);
    if (!entry) {
      return null;
    }
    if (Date.now() - entry.timestamp > this.config.ttlMs) {
      this.entries.delete(key);
      this.removeFromAccessOrder(key);
      logger.debug(CATEGORY4, `Cache expired: ${key}`);
      return null;
    }
    if (entry.version !== this.globalVersion) {
      this.entries.delete(key);
      this.removeFromAccessOrder(key);
      logger.debug(CATEGORY4, `Cache invalidated (version mismatch): ${key}`);
      return null;
    }
    this.removeFromAccessOrder(key);
    this.accessOrder.push(key);
    logger.debug(CATEGORY4, `Cache hit: ${key}`);
    return entry.data;
  }
  /**
   * Set a cached value
   */
  set(key, data) {
    while (this.entries.size >= this.config.maxEntries && this.accessOrder.length > 0) {
      const oldestKey = this.accessOrder.shift();
      if (oldestKey) {
        this.entries.delete(oldestKey);
        logger.debug(CATEGORY4, `Cache evicted (LRU): ${oldestKey}`);
      }
    }
    this.entries.set(key, {
      data,
      timestamp: Date.now(),
      version: this.globalVersion
    });
    this.removeFromAccessOrder(key);
    this.accessOrder.push(key);
    logger.debug(CATEGORY4, `Cache set: ${key}`);
  }
  /**
   * Check if key exists and is valid
   */
  has(key) {
    return this.get(key) !== null;
  }
  /**
   * Delete a specific key
   */
  delete(key) {
    this.entries.delete(key);
    this.removeFromAccessOrder(key);
  }
  /**
   * Invalidate all entries (cheap operation - just bump version)
   */
  invalidateAll() {
    this.globalVersion++;
    logger.debug(CATEGORY4, `Cache invalidated all (version: ${this.globalVersion})`);
  }
  /**
   * Clear all entries
   */
  clear() {
    this.entries.clear();
    this.accessOrder = [];
    this.globalVersion++;
    logger.debug(CATEGORY4, "Cache cleared");
  }
  /**
   * Get cache statistics
   */
  getStats() {
    return {
      size: this.entries.size,
      maxSize: this.config.maxEntries,
      version: this.globalVersion
    };
  }
  removeFromAccessOrder(key) {
    const index = this.accessOrder.indexOf(key);
    if (index !== -1) {
      this.accessOrder.splice(index, 1);
    }
  }
};
var ContextCache = class {
  constructor(app, config = {}) {
    this.invalidationTimeout = null;
    this.registeredEvents = [];
    this.app = app;
    this.debounceMs = config.debounceMs || DEFAULT_CONFIG.debounceMs;
    this.goalsCache = new Cache(config);
    this.projectsCache = new Cache(config);
    this.epicsCache = new Cache(config);
    this.tasksCache = new Cache(config);
    this.metadataCache = new Cache(config);
    this.setupEventListeners();
  }
  /**
   * Setup event listeners for automatic invalidation
   */
  setupEventListeners() {
    const modifyRef = this.app.vault.on("modify", (file) => {
      if (file instanceof import_obsidian6.TFile && file.extension === "md") {
        this.debouncedInvalidate();
      }
    });
    const createRef = this.app.vault.on("create", (file) => {
      if (file instanceof import_obsidian6.TFile && file.extension === "md") {
        this.debouncedInvalidate();
      }
    });
    const deleteRef = this.app.vault.on("delete", (file) => {
      if (file instanceof import_obsidian6.TFile && file.extension === "md") {
        this.debouncedInvalidate();
      }
    });
    const renameRef = this.app.vault.on("rename", (file) => {
      if (file instanceof import_obsidian6.TFile && file.extension === "md") {
        this.debouncedInvalidate();
      }
    });
    this.registeredEvents.push(
      () => this.app.vault.offref(modifyRef),
      () => this.app.vault.offref(createRef),
      () => this.app.vault.offref(deleteRef),
      () => this.app.vault.offref(renameRef)
    );
    logger.info(CATEGORY4, "Cache event listeners registered");
  }
  /**
   * Debounced invalidation to prevent excessive cache clears
   */
  debouncedInvalidate() {
    if (this.invalidationTimeout) {
      clearTimeout(this.invalidationTimeout);
    }
    this.invalidationTimeout = setTimeout(() => {
      this.invalidateAll();
      this.invalidationTimeout = null;
    }, this.debounceMs);
  }
  /**
   * Get cached goals or load them
   */
  getGoals(key, loader) {
    const cached = this.goalsCache.get(key);
    if (cached !== null) {
      return cached;
    }
    const data = loader();
    this.goalsCache.set(key, data);
    return data;
  }
  /**
   * Get cached projects or load them
   */
  getProjects(key, loader) {
    const cached = this.projectsCache.get(key);
    if (cached !== null) {
      return cached;
    }
    const data = loader();
    this.projectsCache.set(key, data);
    return data;
  }
  /**
   * Get cached epics or load them
   */
  getEpics(key, loader) {
    const cached = this.epicsCache.get(key);
    if (cached !== null) {
      return cached;
    }
    const data = loader();
    this.epicsCache.set(key, data);
    return data;
  }
  /**
   * Get cached tasks or load them
   */
  getTasks(key, loader) {
    const cached = this.tasksCache.get(key);
    if (cached !== null) {
      return cached;
    }
    const data = loader();
    this.tasksCache.set(key, data);
    return data;
  }
  /**
   * Get cached metadata or load it
   */
  getMetadata(key, loader) {
    const cached = this.metadataCache.get(key);
    if (cached !== null) {
      return cached;
    }
    const data = loader();
    this.metadataCache.set(key, data);
    return data;
  }
  /**
   * Invalidate all caches
   */
  invalidateAll() {
    this.goalsCache.invalidateAll();
    this.projectsCache.invalidateAll();
    this.epicsCache.invalidateAll();
    this.tasksCache.invalidateAll();
    this.metadataCache.invalidateAll();
    logger.info(CATEGORY4, "All caches invalidated");
  }
  /**
   * Clear all caches
   */
  clear() {
    this.goalsCache.clear();
    this.projectsCache.clear();
    this.epicsCache.clear();
    this.tasksCache.clear();
    this.metadataCache.clear();
    logger.info(CATEGORY4, "All caches cleared");
  }
  /**
   * Get cache statistics
   */
  getStats() {
    return {
      goals: this.goalsCache.getStats(),
      projects: this.projectsCache.getStats(),
      epics: this.epicsCache.getStats(),
      tasks: this.tasksCache.getStats(),
      metadata: this.metadataCache.getStats()
    };
  }
  /**
   * Cleanup event listeners
   */
  destroy() {
    for (const cleanup of this.registeredEvents) {
      cleanup();
    }
    this.registeredEvents = [];
    if (this.invalidationTimeout) {
      clearTimeout(this.invalidationTimeout);
      this.invalidationTimeout = null;
    }
    this.clear();
    logger.info(CATEGORY4, "Cache destroyed");
  }
};

// src/i18n.ts
var en = {
  // Common
  cancel: "Cancel",
  confirm: "Confirm",
  create: "Create",
  save: "Save",
  delete: "Delete",
  close: "Close",
  loading: "Loading...",
  error: "Error",
  success: "Success",
  retry: "Retry",
  // Task creation
  quickTaskTitle: "\u{1F680} Quick Task Creation",
  quickTaskDescription: "Describe your task naturally. GPT will help structure it based on your goals and projects.",
  quickTaskPlaceholder: "e.g., Create a landing page for the Freedom Runway project with high priority",
  createWithAi: "\u2728 Create with AI",
  simpleCreate: "Create (No AI)",
  taskCreationCancelled: "Task creation cancelled",
  taskCreated: "\u2705 Created task: {title}",
  taskCreationFailed: "Failed to create task: {error}",
  // Voice
  voiceRecording: "\u{1F3A4} Voice Recording",
  voiceRecordingStart: "Start Recording",
  voiceRecordingStop: "Stop Recording",
  voiceRecordingCancel: "Cancel",
  voiceTranscribing: "\u{1F3A4} Transcribing...",
  voiceInstructions: "Speak clearly and describe your task. Include priority, epic, or project names if relevant.",
  // Review modal
  reviewTask: "\u{1F4CB} Review Task",
  reviewTitle: "Title",
  reviewObjective: "Objective",
  reviewImportance: "Why it matters",
  reviewEpic: "Epic",
  reviewPriority: "Priority",
  reviewSubtasks: "Suggested Subtasks ({count})",
  noEpic: "-- No Epic --",
  // Breakdown
  breakdownTitle: "\u{1F4CA} Task Breakdown: {epic}",
  breakdownDescription: "{count} tasks will be created:",
  breakdownTaskCount: "{count} tasks",
  breakdownDependsOn: "Depends on: Task {index}",
  breakdownCreating: "\u{1F916} Breaking down: {epic}...",
  // Confirmation
  confirmTaskCreation: "\u{1F4CB} Confirm Task Creation ({count} tasks)",
  confirmTaskCreationSingle: "\u{1F4CB} Confirm Task Creation",
  confirmTasksWillBeCreated: "The following tasks will be created:",
  confirmTargetFolder: "\u{1F4C1} {folder}",
  confirmCreateTasks: "\u2713 Create {count} Tasks",
  confirmCreateTask: "\u2713 Create Task",
  // Errors
  errorNoApiKey: "Please set your OpenAI API key in settings first.",
  errorVoiceDisabled: "Voice input is disabled. Enable it in settings.",
  errorNoEpics: "No epics found in your vault.",
  errorNoSelection: "Please select some text first.",
  errorRateLimited: "Rate limited. Please wait {seconds} seconds.",
  errorTimeout: "Request timed out. Please try again.",
  errorServerError: "Server error. Please try again later.",
  errorAuthFailed: "Authentication failed. Please check your API key.",
  errorParsingFailed: "Failed to parse GPT response. Creating simple task.",
  // Progress
  progressProcessing: "\u{1F916} Processing with GPT...",
  progressBreakingDown: "\u{1F916} Breaking down epic...",
  progressCreatingTasks: "Creating tasks...",
  progressTranscribing: "\u{1F3A4} Transcribing audio...",
  // Settings
  settingsApiConfig: "\u{1F511} API Configuration",
  settingsVaultPaths: "\u{1F4C1} Vault Paths",
  settingsFeatures: "\u26A1 Features",
  settingsDefaults: "\u{1F4CB} Task Defaults",
  settingsPrompts: "\u{1F916} GPT Prompts",
  settingsReset: "\u{1F504} Reset",
  // Conflict resolution
  conflictFileExists: "File already exists: {filename}",
  conflictRename: "Rename",
  conflictOverwrite: "Overwrite",
  conflictSkip: "Skip",
  // Accessibility
  ariaCloseModal: "Close modal",
  ariaConfirmButton: "Confirm action",
  ariaCancelButton: "Cancel action",
  ariaLoadingIndicator: "Loading, please wait",
  ariaTaskList: "Task list",
  ariaPriorityBadge: "Priority: {priority}"
};
var ko = {
  // Common
  cancel: "\uCDE8\uC18C",
  confirm: "\uD655\uC778",
  create: "\uC0DD\uC131",
  save: "\uC800\uC7A5",
  delete: "\uC0AD\uC81C",
  close: "\uB2EB\uAE30",
  loading: "\uB85C\uB529 \uC911...",
  error: "\uC624\uB958",
  success: "\uC131\uACF5",
  retry: "\uC7AC\uC2DC\uB3C4",
  // Task creation
  quickTaskTitle: "\u{1F680} \uBE60\uB978 \uD0DC\uC2A4\uD06C \uC0DD\uC131",
  quickTaskDescription: "\uD0DC\uC2A4\uD06C\uB97C \uC790\uC5F0\uC2A4\uB7FD\uAC8C \uC124\uBA85\uD558\uC138\uC694. GPT\uAC00 \uBAA9\uD45C\uC640 \uD504\uB85C\uC81D\uD2B8\uC5D0 \uB9DE\uAC8C \uAD6C\uC870\uD654\uD569\uB2C8\uB2E4.",
  quickTaskPlaceholder: "\uC608: Freedom Runway \uD504\uB85C\uC81D\uD2B8\uC758 \uB79C\uB529 \uD398\uC774\uC9C0\uB97C \uB192\uC740 \uC6B0\uC120\uC21C\uC704\uB85C \uB9CC\uB4E4\uAE30",
  createWithAi: "\u2728 AI\uB85C \uC0DD\uC131",
  simpleCreate: "\uC0DD\uC131 (AI \uC5C6\uC774)",
  taskCreationCancelled: "\uD0DC\uC2A4\uD06C \uC0DD\uC131\uC774 \uCDE8\uC18C\uB418\uC5C8\uC2B5\uB2C8\uB2E4",
  taskCreated: "\u2705 \uD0DC\uC2A4\uD06C \uC0DD\uC131\uB428: {title}",
  taskCreationFailed: "\uD0DC\uC2A4\uD06C \uC0DD\uC131 \uC2E4\uD328: {error}",
  // Voice
  voiceRecording: "\u{1F3A4} \uC74C\uC131 \uB179\uC74C",
  voiceRecordingStart: "\uB179\uC74C \uC2DC\uC791",
  voiceRecordingStop: "\uB179\uC74C \uC911\uC9C0",
  voiceRecordingCancel: "\uCDE8\uC18C",
  voiceTranscribing: "\u{1F3A4} \uBCC0\uD658 \uC911...",
  voiceInstructions: "\uBA85\uD655\uD558\uAC8C \uB9D0\uD558\uACE0 \uD0DC\uC2A4\uD06C\uB97C \uC124\uBA85\uD558\uC138\uC694. \uC6B0\uC120\uC21C\uC704, \uC5D0\uD53D \uB610\uB294 \uD504\uB85C\uC81D\uD2B8 \uC774\uB984\uC744 \uD3EC\uD568\uD558\uC138\uC694.",
  // Review modal
  reviewTask: "\u{1F4CB} \uD0DC\uC2A4\uD06C \uAC80\uD1A0",
  reviewTitle: "\uC81C\uBAA9",
  reviewObjective: "\uBAA9\uD45C",
  reviewImportance: "\uC911\uC694\uD55C \uC774\uC720",
  reviewEpic: "\uC5D0\uD53D",
  reviewPriority: "\uC6B0\uC120\uC21C\uC704",
  reviewSubtasks: "\uC81C\uC548\uB41C \uD558\uC704 \uD0DC\uC2A4\uD06C ({count})",
  noEpic: "-- \uC5D0\uD53D \uC5C6\uC74C --",
  // Breakdown
  breakdownTitle: "\u{1F4CA} \uD0DC\uC2A4\uD06C \uBD84\uD574: {epic}",
  breakdownDescription: "{count}\uAC1C\uC758 \uD0DC\uC2A4\uD06C\uAC00 \uC0DD\uC131\uB429\uB2C8\uB2E4:",
  breakdownTaskCount: "{count}\uAC1C \uD0DC\uC2A4\uD06C",
  breakdownDependsOn: "\uC758\uC874: \uD0DC\uC2A4\uD06C {index}",
  breakdownCreating: "\u{1F916} \uBD84\uD574 \uC911: {epic}...",
  // Confirmation
  confirmTaskCreation: "\u{1F4CB} \uD0DC\uC2A4\uD06C \uC0DD\uC131 \uD655\uC778 ({count}\uAC1C)",
  confirmTaskCreationSingle: "\u{1F4CB} \uD0DC\uC2A4\uD06C \uC0DD\uC131 \uD655\uC778",
  confirmTasksWillBeCreated: "\uB2E4\uC74C \uD0DC\uC2A4\uD06C\uAC00 \uC0DD\uC131\uB429\uB2C8\uB2E4:",
  confirmTargetFolder: "\u{1F4C1} {folder}",
  confirmCreateTasks: "\u2713 {count}\uAC1C \uD0DC\uC2A4\uD06C \uC0DD\uC131",
  confirmCreateTask: "\u2713 \uD0DC\uC2A4\uD06C \uC0DD\uC131",
  // Errors
  errorNoApiKey: "\uBA3C\uC800 \uC124\uC815\uC5D0\uC11C OpenAI API \uD0A4\uB97C \uC124\uC815\uD558\uC138\uC694.",
  errorVoiceDisabled: "\uC74C\uC131 \uC785\uB825\uC774 \uBE44\uD65C\uC131\uD654\uB418\uC5B4 \uC788\uC2B5\uB2C8\uB2E4. \uC124\uC815\uC5D0\uC11C \uD65C\uC131\uD654\uD558\uC138\uC694.",
  errorNoEpics: "\uBCFC\uD2B8\uC5D0\uC11C \uC5D0\uD53D\uC744 \uCC3E\uC744 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4.",
  errorNoSelection: "\uBA3C\uC800 \uD14D\uC2A4\uD2B8\uB97C \uC120\uD0DD\uD558\uC138\uC694.",
  errorRateLimited: "\uC694\uCCAD \uC81C\uD55C\uB428. {seconds}\uCD08 \uD6C4\uC5D0 \uB2E4\uC2DC \uC2DC\uB3C4\uD558\uC138\uC694.",
  errorTimeout: "\uC694\uCCAD \uC2DC\uAC04 \uCD08\uACFC. \uB2E4\uC2DC \uC2DC\uB3C4\uD558\uC138\uC694.",
  errorServerError: "\uC11C\uBC84 \uC624\uB958. \uB098\uC911\uC5D0 \uB2E4\uC2DC \uC2DC\uB3C4\uD558\uC138\uC694.",
  errorAuthFailed: "\uC778\uC99D \uC2E4\uD328. API \uD0A4\uB97C \uD655\uC778\uD558\uC138\uC694.",
  errorParsingFailed: "GPT \uC751\uB2F5 \uD30C\uC2F1 \uC2E4\uD328. \uAC04\uB2E8\uD55C \uD0DC\uC2A4\uD06C\uB97C \uC0DD\uC131\uD569\uB2C8\uB2E4.",
  // Progress
  progressProcessing: "\u{1F916} GPT\uB85C \uCC98\uB9AC \uC911...",
  progressBreakingDown: "\u{1F916} \uC5D0\uD53D \uBD84\uD574 \uC911...",
  progressCreatingTasks: "\uD0DC\uC2A4\uD06C \uC0DD\uC131 \uC911...",
  progressTranscribing: "\u{1F3A4} \uC624\uB514\uC624 \uBCC0\uD658 \uC911...",
  // Settings
  settingsApiConfig: "\u{1F511} API \uC124\uC815",
  settingsVaultPaths: "\u{1F4C1} \uBCFC\uD2B8 \uACBD\uB85C",
  settingsFeatures: "\u26A1 \uAE30\uB2A5",
  settingsDefaults: "\u{1F4CB} \uD0DC\uC2A4\uD06C \uAE30\uBCF8\uAC12",
  settingsPrompts: "\u{1F916} GPT \uD504\uB86C\uD504\uD2B8",
  settingsReset: "\u{1F504} \uCD08\uAE30\uD654",
  // Conflict resolution
  conflictFileExists: "\uD30C\uC77C\uC774 \uC774\uBBF8 \uC874\uC7AC\uD569\uB2C8\uB2E4: {filename}",
  conflictRename: "\uC774\uB984 \uBCC0\uACBD",
  conflictOverwrite: "\uB36E\uC5B4\uC4F0\uAE30",
  conflictSkip: "\uAC74\uB108\uB6F0\uAE30",
  // Accessibility
  ariaCloseModal: "\uBAA8\uB2EC \uB2EB\uAE30",
  ariaConfirmButton: "\uC791\uC5C5 \uD655\uC778",
  ariaCancelButton: "\uC791\uC5C5 \uCDE8\uC18C",
  ariaLoadingIndicator: "\uB85C\uB529 \uC911\uC785\uB2C8\uB2E4. \uC7A0\uC2DC \uAE30\uB2E4\uB824\uC8FC\uC138\uC694",
  ariaTaskList: "\uD0DC\uC2A4\uD06C \uBAA9\uB85D",
  ariaPriorityBadge: "\uC6B0\uC120\uC21C\uC704: {priority}"
};
var ja = {
  ...en,
  // Fallback to English for incomplete translations
  cancel: "\u30AD\u30E3\u30F3\u30BB\u30EB",
  confirm: "\u78BA\u8A8D",
  create: "\u4F5C\u6210",
  save: "\u4FDD\u5B58",
  delete: "\u524A\u9664",
  close: "\u9589\u3058\u308B",
  loading: "\u8AAD\u307F\u8FBC\u307F\u4E2D...",
  error: "\u30A8\u30E9\u30FC",
  success: "\u6210\u529F",
  retry: "\u518D\u8A66\u884C",
  quickTaskTitle: "\u{1F680} \u30AF\u30A4\u30C3\u30AF\u30BF\u30B9\u30AF\u4F5C\u6210",
  createWithAi: "\u2728 AI\u3067\u4F5C\u6210",
  taskCreationCancelled: "\u30BF\u30B9\u30AF\u4F5C\u6210\u304C\u30AD\u30E3\u30F3\u30BB\u30EB\u3055\u308C\u307E\u3057\u305F"
};
var zh = {
  ...en,
  // Fallback to English for incomplete translations
  cancel: "\u53D6\u6D88",
  confirm: "\u786E\u8BA4",
  create: "\u521B\u5EFA",
  save: "\u4FDD\u5B58",
  delete: "\u5220\u9664",
  close: "\u5173\u95ED",
  loading: "\u52A0\u8F7D\u4E2D...",
  error: "\u9519\u8BEF",
  success: "\u6210\u529F",
  retry: "\u91CD\u8BD5",
  quickTaskTitle: "\u{1F680} \u5FEB\u901F\u521B\u5EFA\u4EFB\u52A1",
  createWithAi: "\u2728 AI\u521B\u5EFA",
  taskCreationCancelled: "\u4EFB\u52A1\u521B\u5EFA\u5DF2\u53D6\u6D88"
};
var translations = {
  en,
  ko,
  ja,
  zh
};
var currentLocale = "en";
function setLocale(locale) {
  if (translations[locale]) {
    currentLocale = locale;
  } else {
    console.warn(`[GPT Task Manager] Unsupported locale: ${locale}, falling back to English`);
    currentLocale = "en";
  }
}
function t(key, params) {
  const strings = translations[currentLocale] || translations.en;
  let text = strings[key] || translations.en[key] || key;
  if (params) {
    for (const [paramKey, value] of Object.entries(params)) {
      text = text.replace(new RegExp(`\\{${paramKey}\\}`, "g"), String(value));
    }
  }
  return text;
}

// src/ui-components.ts
var import_obsidian7 = require("obsidian");
function showNotice(message, duration = 4e3) {
  new import_obsidian7.Notice(message, duration);
}
function showErrorNotice(error, recovery) {
  const message = recovery ? `${error}
${recovery}` : error;
  new import_obsidian7.Notice(message, 6e3);
}
function showSuccessNotice(message) {
  new import_obsidian7.Notice(`\u2705 ${message}`, 3e3);
}

// main.ts
var QuickTaskModal = class extends import_obsidian8.Modal {
  constructor(app, onSubmit) {
    super(app);
    this.inputEl = null;
    this.onSubmit = onSubmit;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("gpt-task-manager-quick-modal");
    contentEl.createEl("h2", { text: "\u{1F680} Quick Task Creation" });
    contentEl.createEl("p", {
      text: "Describe your task naturally. GPT will help structure it based on your goals and projects.",
      cls: "modal-description"
    });
    this.inputEl = contentEl.createEl("textarea", {
      placeholder: "e.g., Create a landing page for the Freedom Runway project with high priority"
    });
    this.inputEl.style.width = "100%";
    this.inputEl.style.minHeight = "100px";
    this.inputEl.style.marginBottom = "16px";
    this.inputEl.style.padding = "12px";
    this.inputEl.style.fontSize = "14px";
    this.inputEl.style.borderRadius = "8px";
    this.inputEl.addEventListener("keydown", (event) => {
      if (event.key === "Enter" && !event.shiftKey) {
        event.preventDefault();
        this.submit();
      }
    });
    const buttonsEl = contentEl.createDiv({ cls: "modal-button-container" });
    const cancelBtn = buttonsEl.createEl("button", { text: "Cancel" });
    cancelBtn.onclick = () => this.close();
    const submitBtn = buttonsEl.createEl("button", { text: "\u2728 Create with AI", cls: "mod-cta" });
    submitBtn.onclick = () => this.submit();
    this.inputEl.focus();
  }
  submit() {
    var _a;
    const input = (_a = this.inputEl) == null ? void 0 : _a.value.trim();
    if (input) {
      this.close();
      this.onSubmit(input);
    } else {
      new import_obsidian8.Notice("Please enter a task description");
    }
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var EpicSelectModal = class extends import_obsidian8.FuzzySuggestModal {
  constructor(app, epics, onChoose) {
    super(app);
    this.epics = epics;
    this.onChoose = onChoose;
    this.setPlaceholder("Select an epic to break down...");
  }
  getItems() {
    return this.epics;
  }
  getItemText(item) {
    const status = item.status ? ` [${item.status}]` : "";
    const project = item.project ? ` - ${item.project}` : "";
    return `${item.name}${status}${project}`;
  }
  onChooseItem(item, evt) {
    this.onChoose(item);
  }
};
var TaskReviewModal = class extends import_obsidian8.Modal {
  constructor(app, suggestion, epics, onConfirm, onCancel) {
    super(app);
    this.resolved = false;
    this.suggestion = suggestion;
    this.epics = epics;
    this.onConfirm = onConfirm;
    this.onCancel = onCancel;
    this.selectedEpic = suggestion.suggestedEpic;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("gpt-task-manager-review-modal");
    contentEl.createEl("h2", { text: "\u{1F4CB} Review Task" });
    const formEl = contentEl.createDiv({ cls: "task-review-form" });
    const titleGroup = formEl.createDiv({ cls: "form-group" });
    titleGroup.createEl("label", { text: "Title" });
    const titleInput = titleGroup.createEl("input", { type: "text", value: this.suggestion.title });
    titleInput.style.width = "100%";
    titleInput.addEventListener("change", () => {
      this.suggestion.title = titleInput.value;
    });
    const objectiveGroup = formEl.createDiv({ cls: "form-group" });
    objectiveGroup.createEl("label", { text: "Objective" });
    const objectiveInput = objectiveGroup.createEl("textarea", { text: this.suggestion.objective });
    objectiveInput.style.width = "100%";
    objectiveInput.rows = 3;
    objectiveInput.addEventListener("change", () => {
      this.suggestion.objective = objectiveInput.value;
    });
    const importanceGroup = formEl.createDiv({ cls: "form-group" });
    importanceGroup.createEl("label", { text: "Why it matters" });
    const importanceInput = importanceGroup.createEl("textarea", { text: this.suggestion.importance });
    importanceInput.style.width = "100%";
    importanceInput.rows = 2;
    importanceInput.addEventListener("change", () => {
      this.suggestion.importance = importanceInput.value;
    });
    const epicGroup = formEl.createDiv({ cls: "form-group" });
    epicGroup.createEl("label", { text: "Epic" });
    const epicSelect = epicGroup.createEl("select");
    epicSelect.style.width = "100%";
    const noneOption = epicSelect.createEl("option", { text: "-- No Epic --", value: "" });
    for (const epic of this.epics) {
      const option = epicSelect.createEl("option", {
        text: `${epic.name} (${epic.status || "active"})`,
        value: epic.name
      });
      if (epic.name === this.suggestion.suggestedEpic) {
        option.selected = true;
      }
    }
    epicSelect.addEventListener("change", () => {
      this.selectedEpic = epicSelect.value || null;
    });
    const priorityGroup = formEl.createDiv({ cls: "form-group" });
    priorityGroup.createEl("label", { text: "Priority" });
    const prioritySelect = priorityGroup.createEl("select");
    prioritySelect.style.width = "100%";
    const priorities = [
      { value: "low", text: "Low" },
      { value: "medium", text: "Medium" },
      { value: "high", text: "High" },
      { value: "critical", text: "Critical" }
    ];
    for (const priority of priorities) {
      const option = prioritySelect.createEl("option", {
        text: priority.text,
        value: priority.value
      });
      if (priority.value === this.suggestion.priority) {
        option.selected = true;
      }
    }
    prioritySelect.addEventListener("change", () => {
      this.suggestion.priority = prioritySelect.value;
    });
    if (this.suggestion.subtasks.length > 0) {
      const subtasksGroup = formEl.createDiv({ cls: "form-group" });
      subtasksGroup.createEl("label", { text: `Suggested Subtasks (${this.suggestion.subtasks.length})` });
      const subtasksList = subtasksGroup.createEl("ul", { cls: "subtasks-preview" });
      for (const subtask of this.suggestion.subtasks) {
        subtasksList.createEl("li", { text: subtask });
      }
    }
    const buttonsEl = contentEl.createDiv({ cls: "modal-button-container" });
    const cancelBtn = buttonsEl.createEl("button", { text: "Cancel" });
    cancelBtn.onclick = () => {
      this.resolved = true;
      this.close();
      this.onCancel();
    };
    const confirmBtn = buttonsEl.createEl("button", { text: "\u2713 Create Task", cls: "mod-cta" });
    confirmBtn.onclick = () => {
      this.resolved = true;
      this.close();
      this.onConfirm(this.suggestion, this.selectedEpic);
    };
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
    if (!this.resolved) {
      this.resolved = true;
      this.onCancel();
    }
  }
};
var BreakdownReviewModal = class extends import_obsidian8.Modal {
  constructor(app, breakdown, epicName, onConfirm, onCancel) {
    super(app);
    this.resolved = false;
    this.breakdown = breakdown;
    this.epicName = epicName;
    this.onConfirm = onConfirm;
    this.onCancel = onCancel;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("gpt-task-manager-breakdown-modal");
    contentEl.createEl("h2", { text: `\u{1F4CA} Task Breakdown: ${this.epicName}` });
    contentEl.createEl("p", {
      text: `${this.breakdown.tasks.length} tasks will be created:`,
      cls: "modal-description"
    });
    const taskListEl = contentEl.createDiv({ cls: "breakdown-task-list" });
    for (let index = 0; index < this.breakdown.tasks.length; index++) {
      const task = this.breakdown.tasks[index];
      const taskEl = taskListEl.createDiv({ cls: "breakdown-task-item" });
      const headerEl = taskEl.createDiv({ cls: "task-header" });
      headerEl.createEl("span", { text: `${index + 1}. ${task.title}`, cls: "task-title" });
      headerEl.createEl("span", {
        text: task.priority,
        cls: `task-priority priority-${task.priority}`
      });
      if (task.objective) {
        taskEl.createEl("p", { text: task.objective, cls: "task-objective" });
      }
      if (task.dependsOn !== null) {
        taskEl.createEl("span", {
          text: `Depends on: Task ${task.dependsOn + 1}`,
          cls: "task-dependency"
        });
      }
    }
    const buttonsEl = contentEl.createDiv({ cls: "modal-button-container" });
    const cancelBtn = buttonsEl.createEl("button", { text: "Cancel" });
    cancelBtn.onclick = () => {
      this.resolved = true;
      this.close();
      this.onCancel();
    };
    const confirmBtn = buttonsEl.createEl("button", {
      text: `\u2713 Create ${this.breakdown.tasks.length} Tasks`,
      cls: "mod-cta"
    });
    confirmBtn.onclick = () => {
      this.resolved = true;
      this.close();
      this.onConfirm(this.breakdown);
    };
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
    if (!this.resolved) {
      this.resolved = true;
      this.onCancel();
    }
  }
};
var GptTaskManagerPlugin = class extends import_obsidian8.Plugin {
  constructor() {
    super(...arguments);
    this.settings = DEFAULT_SETTINGS;
    this.contextCache = null;
    this.activeCancellationToken = null;
  }
  async onload() {
    logger.info("Plugin", "Loading GPT Task Manager plugin...");
    await this.loadSettings();
    this.initializeInfrastructure();
    this.addSettingTab(new GptTaskManagerSettingTab(this.app, this));
    this.addRibbonIcon("plus-circle", "Quick Task (GPT)", () => {
      this.showQuickTaskModal();
    });
    this.addRibbonIcon("mic", "Voice Task", () => {
      this.startVoiceTask();
    });
    this.addCommand({
      id: "gpt-task-quick-create",
      name: "Quick Task Creation (GPT Assisted)",
      callback: () => this.showQuickTaskModal()
    });
    this.addCommand({
      id: "gpt-task-voice-create",
      name: "Voice Task Creation",
      callback: () => this.startVoiceTask()
    });
    this.addCommand({
      id: "gpt-task-breakdown-epic",
      name: "Break Down Epic into Tasks",
      callback: () => this.showEpicBreakdownModal()
    });
    this.addCommand({
      id: "gpt-task-simple-create",
      name: "Simple Task Creation (No AI)",
      callback: () => this.showSimpleTaskModal()
    });
    this.addCommand({
      id: "gpt-task-from-selection",
      name: "Create Task from Selection (GPT)",
      editorCallback: (editor, view) => {
        this.createTaskFromSelection(editor);
      }
    });
    logger.info("Plugin", "GPT Task Manager loaded successfully");
  }
  onunload() {
    logger.info("Plugin", "Unloading GPT Task Manager plugin...");
    if (this.contextCache) {
      this.contextCache.destroy();
      this.contextCache = null;
    }
    if (this.activeCancellationToken) {
      this.activeCancellationToken.cancel("Plugin unloading");
    }
  }
  async loadSettings() {
    const stored = await this.loadData();
    this.settings = Object.assign({}, DEFAULT_SETTINGS, stored);
  }
  async saveSettings() {
    await this.saveData(this.settings);
    this.initializeInfrastructure();
  }
  /**
   * Initialize infrastructure based on settings
   */
  initializeInfrastructure() {
    const logLevelMap = {
      debug: 0 /* DEBUG */,
      info: 1 /* INFO */,
      warn: 2 /* WARN */,
      error: 3 /* ERROR */,
      none: 4 /* NONE */
    };
    logger.setLogLevel(logLevelMap[this.settings.logLevel] || 1 /* INFO */);
    setLocale(this.settings.uiLocale);
    setRateLimitConfig(this.settings.rateLimitPerMinute, 6e4);
    if (this.settings.enableContextCache) {
      if (!this.contextCache) {
        this.contextCache = new ContextCache(this.app, {
          ttlMs: 6e4,
          // 1 minute cache
          maxEntries: 50,
          debounceMs: 500
        });
      }
    } else if (this.contextCache) {
      this.contextCache.destroy();
      this.contextCache = null;
    }
    logger.debug("Plugin", "Infrastructure initialized", {
      logLevel: this.settings.logLevel,
      locale: this.settings.uiLocale,
      cacheEnabled: this.settings.enableContextCache,
      rateLimitPerMinute: this.settings.rateLimitPerMinute
    });
  }
  /**
   * Create a new cancellation token for an operation
   */
  createCancellationToken() {
    if (this.activeCancellationToken) {
      this.activeCancellationToken.cancel("New operation started");
    }
    this.activeCancellationToken = new CancellationToken();
    return this.activeCancellationToken;
  }
  /**
   * Get user context (cached if enabled)
   */
  getUserContext() {
    if (this.contextCache && this.settings.enableContextCache) {
      const cacheKey = `${this.settings.goalsFolder}|${this.settings.projectsFolder}|${this.settings.epicsFolder}|${this.settings.tasksFolder}`;
      const goals = this.contextCache.getGoals(
        cacheKey,
        () => loadUserContext(this.app, this.settings.goalsFolder, this.settings.projectsFolder, this.settings.epicsFolder, this.settings.tasksFolder).goals
      );
      const projects = this.contextCache.getProjects(
        cacheKey,
        () => loadUserContext(this.app, this.settings.goalsFolder, this.settings.projectsFolder, this.settings.epicsFolder, this.settings.tasksFolder).projects
      );
      const epics = this.contextCache.getEpics(
        cacheKey,
        () => loadUserContext(this.app, this.settings.goalsFolder, this.settings.projectsFolder, this.settings.epicsFolder, this.settings.tasksFolder).epics
      );
      const activeTasks = this.contextCache.getTasks(
        cacheKey,
        () => loadUserContext(this.app, this.settings.goalsFolder, this.settings.projectsFolder, this.settings.epicsFolder, this.settings.tasksFolder).activeTasks
      );
      return { goals, projects, epics, activeTasks };
    }
    return loadUserContext(
      this.app,
      this.settings.goalsFolder,
      this.settings.projectsFolder,
      this.settings.epicsFolder,
      this.settings.tasksFolder
    );
  }
  /**
   * Show quick task input modal
   */
  showQuickTaskModal() {
    if (!this.settings.openAIApiKey) {
      showErrorNotice(t("errorNoApiKey"));
      return;
    }
    new QuickTaskModal(this.app, async (input) => {
      await this.processQuickTask(input);
    }).open();
  }
  /**
   * Process quick task input with GPT
   */
  async processQuickTask(input) {
    showNotice(t("progressProcessing"));
    const cancellationToken = this.createCancellationToken();
    try {
      const context = this.getUserContext();
      const formattedContext = formatContextForPrompt(context);
      const prompt = fillPromptTemplate(this.settings.taskCreationPrompt, {
        goals: formattedContext.goals,
        projects: formattedContext.projects,
        epics: formattedContext.epics,
        input
      });
      const result = await callGptApi(
        prompt,
        "You are a helpful task management assistant that creates well-structured tasks.",
        this.settings.openAIApiKey,
        this.settings.gptModel,
        this.settings.gptMaxTokens,
        this.settings.gptTemperature,
        cancellationToken,
        this.settings.apiTimeoutSeconds,
        this.settings.apiMaxRetries
      );
      if (result.cancelled) {
        showNotice(t("taskCreationCancelled"));
        return;
      }
      if (!result.success || !result.content) {
        showErrorNotice(result.errorMessage || "Unknown error");
        return;
      }
      const suggestion = parseTaskSuggestion(result.content);
      if (!suggestion) {
        showNotice(t("errorParsingFailed"));
        await this.createSimpleTask(input);
        return;
      }
      new TaskReviewModal(
        this.app,
        suggestion,
        context.epics,
        async (finalSuggestion, selectedEpic) => {
          await this.createTaskFromSuggestion(finalSuggestion, selectedEpic);
        },
        () => {
          showNotice(t("taskCreationCancelled"));
        }
      ).open();
    } catch (error) {
      logger.error("Plugin", "Quick task error", { error: error instanceof Error ? error.message : "Unknown" });
      showErrorNotice(error instanceof Error ? error.message : "Unknown error");
    }
  }
  /**
   * Create task from GPT suggestion with confirmation dialog
   */
  async createTaskFromSuggestion(suggestion, epicName) {
    try {
      const summary = buildSuggestionSummary(suggestion, epicName, this.settings);
      const confirmed = await showTaskConfirmation(
        this.app,
        [summary],
        "single",
        epicName
      );
      if (!confirmed) {
        new import_obsidian8.Notice("Task creation cancelled");
        return;
      }
      let epicMetadata = null;
      if (epicName) {
        epicMetadata = await getEpicMetadata(this.app, epicName, this.settings.epicsFolder);
      }
      const content = generateTaskFromSuggestion(suggestion, epicMetadata, this.settings);
      const file = await createTaskFile(
        this.app,
        content,
        suggestion.title,
        epicName,
        this.settings
      );
      new import_obsidian8.Notice(`\u2705 Created task: ${suggestion.title}`);
      await this.app.workspace.openLinkText(file.path, "", false);
    } catch (error) {
      console.error("[GPT Task Manager] Task creation error:", error);
      new import_obsidian8.Notice(`Failed to create task: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  /**
   * Start voice task recording
   */
  startVoiceTask() {
    if (!this.settings.openAIApiKey) {
      showErrorNotice(t("errorNoApiKey"));
      return;
    }
    if (!this.settings.enableVoiceInput) {
      showErrorNotice(t("errorVoiceDisabled"));
      return;
    }
    new VoiceRecordingModal(
      this.app,
      async (audioBlob) => {
        await this.processVoiceTask(audioBlob);
      },
      () => {
        showNotice(t("taskCreationCancelled"));
      }
    ).open();
  }
  /**
   * Process voice recording into task
   */
  async processVoiceTask(audioBlob) {
    showNotice(t("progressTranscribing"));
    const cancellationToken = this.createCancellationToken();
    try {
      const transcription = await transcribeAudio(
        audioBlob,
        this.settings.openAIApiKey,
        this.settings.whisperModel,
        this.settings.defaultLanguage === "auto" ? void 0 : this.settings.defaultLanguage,
        cancellationToken
      );
      if (!transcription) {
        showErrorNotice("Transcription returned empty result");
        return;
      }
      showNotice(`\u{1F4DD} Transcribed: "${transcription.substring(0, 50)}..."`);
      const voiceInput = parseVoiceTaskInput(transcription);
      if (this.settings.enableSmartSuggestions) {
        await this.processQuickTask(transcription);
      } else {
        await this.createSimpleTask(voiceInput.taskTitle || transcription);
      }
    } catch (error) {
      logger.error("Plugin", "Voice task error", { error: error instanceof Error ? error.message : "Unknown" });
      if (error instanceof Error && error.message.includes("cancelled")) {
        showNotice(t("taskCreationCancelled"));
      } else {
        showErrorNotice(error instanceof Error ? error.message : "Unknown error");
      }
    }
  }
  /**
   * Show epic breakdown modal
   */
  showEpicBreakdownModal() {
    if (!this.settings.openAIApiKey) {
      showErrorNotice(t("errorNoApiKey"));
      return;
    }
    const epics = loadEpics(this.app, this.settings.epicsFolder);
    if (epics.length === 0) {
      showErrorNotice(t("errorNoEpics"));
      return;
    }
    new EpicSelectModal(this.app, epics, async (epic) => {
      await this.breakdownEpic(epic);
    }).open();
  }
  /**
   * Break down an epic into tasks using GPT
   */
  async breakdownEpic(epic) {
    showNotice(t("breakdownCreating", { epic: epic.name }));
    const cancellationToken = this.createCancellationToken();
    try {
      const epicPath = epic.path;
      const epicFile = this.app.vault.getAbstractFileByPath(epicPath);
      let epicContent = "";
      if (epicFile instanceof import_obsidian8.TFile) {
        epicContent = await this.app.vault.read(epicFile);
      }
      const objectiveMatch = epicContent.match(/## 🎯 Objective[\s\S]*?> What this epic aims to achieve:\s*\n-\s*(.+)/);
      const objective = objectiveMatch ? objectiveMatch[1] : epic.description || "";
      const prompt = fillPromptTemplate(this.settings.taskBreakdownPrompt, {
        title: epic.name,
        description: epic.description || "No description provided",
        objective,
        goal: epic.goal,
        project: epic.project,
        area: epic.area
      });
      const result = await callGptApi(
        prompt,
        "You are an expert project manager that breaks down complex work into actionable tasks.",
        this.settings.openAIApiKey,
        this.settings.gptModel,
        this.settings.gptMaxTokens,
        this.settings.gptTemperature,
        cancellationToken,
        this.settings.apiTimeoutSeconds,
        this.settings.apiMaxRetries
      );
      if (result.cancelled) {
        showNotice(t("taskCreationCancelled"));
        return;
      }
      if (!result.success || !result.content) {
        showErrorNotice(result.errorMessage || "Unknown error");
        return;
      }
      const breakdown = parseTaskBreakdown(result.content);
      if (!breakdown || breakdown.tasks.length === 0) {
        showErrorNotice("Failed to parse task breakdown from GPT response.");
        return;
      }
      new BreakdownReviewModal(
        this.app,
        breakdown,
        epic.name,
        async (finalBreakdown) => {
          await this.createBreakdownTasks(finalBreakdown, epic);
        },
        () => {
          showNotice(t("taskCreationCancelled"));
        }
      ).open();
    } catch (error) {
      logger.error("Plugin", "Epic breakdown error", { error: error instanceof Error ? error.message : "Unknown" });
      showErrorNotice(error instanceof Error ? error.message : "Unknown error");
    }
  }
  /**
   * Create tasks from breakdown with confirmation dialog
   */
  async createBreakdownTasks(breakdown, epic) {
    try {
      if (this.settings.showConfirmationDialogs) {
        const summaries = buildBreakdownSummaries(breakdown, epic.name, this.settings);
        const confirmed = await showTaskConfirmation(
          this.app,
          summaries,
          "breakdown",
          epic.name
        );
        if (!confirmed) {
          showNotice(t("taskCreationCancelled"));
          return;
        }
      }
      const epicMetadata = {
        area: epic.area,
        goal: epic.goal,
        project: epic.project
      };
      const files = await createTasksFromBreakdown(
        this.app,
        breakdown,
        epic.name,
        epicMetadata,
        this.settings
      );
      showSuccessNotice(t("taskCreated", { title: `${files.length} tasks for ${epic.name}` }));
      if (files.length > 0) {
        await this.app.workspace.openLinkText(files[0].path, "", false);
      }
    } catch (error) {
      logger.error("Plugin", "Breakdown task creation error", { error: error instanceof Error ? error.message : "Unknown" });
      showErrorNotice(error instanceof Error ? error.message : "Unknown error");
    }
  }
  /**
   * Show simple task creation modal (no AI)
   */
  showSimpleTaskModal() {
    new QuickTaskModal(this.app, async (input) => {
      await this.createSimpleTask(input);
    }).open();
  }
  /**
   * Create a simple task without GPT (with confirmation)
   */
  async createSimpleTask(title) {
    try {
      const summary = {
        title,
        targetFolder: this.settings.tasksFolder,
        epic: null,
        priority: this.settings.defaultPriority,
        dependsOnTask: null
      };
      const confirmed = await showTaskConfirmation(
        this.app,
        [summary],
        "single",
        null
      );
      if (!confirmed) {
        new import_obsidian8.Notice("Task creation cancelled");
        return;
      }
      const params = {
        title,
        objective: "",
        importance: "",
        status: this.settings.defaultStatus,
        priority: this.settings.defaultPriority,
        tags: ["tasks"]
      };
      const content = generateTaskContent(params, this.settings);
      const file = await createTaskFile(
        this.app,
        content,
        title,
        null,
        this.settings
      );
      new import_obsidian8.Notice(`\u2705 Created task: ${title}`);
      await this.app.workspace.openLinkText(file.path, "", false);
    } catch (error) {
      console.error("[GPT Task Manager] Simple task error:", error);
      new import_obsidian8.Notice(`Failed to create task: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  /**
   * Create task from selected text
   */
  async createTaskFromSelection(editor) {
    const selection = editor.getSelection();
    if (!selection) {
      new import_obsidian8.Notice("Please select some text first");
      return;
    }
    if (this.settings.enableSmartSuggestions && this.settings.openAIApiKey) {
      await this.processQuickTask(selection);
    } else {
      await this.createSimpleTask(selection);
    }
  }
};
