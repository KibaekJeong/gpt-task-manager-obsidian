/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => GptTaskManagerPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian9 = require("obsidian");

// src/settings.ts
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  openAIApiKey: "",
  gptModel: "gpt-4o-mini",
  whisperModel: "whisper-1",
  gptMaxTokens: 2e3,
  gptTemperature: 0.7,
  // API Reliability defaults
  apiTimeoutSeconds: 60,
  apiMaxRetries: 3,
  rateLimitPerMinute: 10,
  tasksFolder: "500 Plan & Reflect/520 Tasks",
  epicsFolder: "500 Plan & Reflect/510 Epics",
  goalsFolder: "300 Goals & Milestone/Goals",
  projectsFolder: "400 Projects",
  milestonesFolder: "300 Goals & Milestone/Milestones",
  templatesFolder: "900 Templates",
  taskTemplatePath: "900 Templates/4 Task Template.md",
  epicTemplatePath: "900 Templates/4 Epic Template.md",
  enableVoiceInput: true,
  enableSmartSuggestions: true,
  enableAutoBreakdown: true,
  enableContextCache: true,
  showConfirmationDialogs: true,
  defaultLanguage: "ko",
  // UI/Locale
  uiLocale: "en",
  // Logging
  logLevel: "info",
  enableDebugNotices: false,
  defaultStatus: "backlog",
  defaultPriority: "medium",
  // Kanban Integration defaults
  enableKanbanIntegration: false,
  kanbanBoardsFolder: "500 Plan & Reflect/530 Boards",
  defaultKanbanBoardName: "All Tasks Board",
  autoSyncKanbanOnTaskChange: true,
  kanbanStatusMapping: {
    backlog: "Backlog",
    todo: "To Do",
    inProgress: "In Progress",
    done: "Done"
  },
  taskCreationPrompt: `You are an expert task manager assistant. Based on the user's input and their current goals/projects context, help create well-structured tasks.

USER CONTEXT:
Goals: {{goals}}
Projects: {{projects}}
Current Epics: {{epics}}

USER INPUT: {{input}}

Create a task with:
1. A clear, actionable title
2. Specific objectives (what needs to be accomplished)
3. Why it matters (connection to goals)
4. Suggested Epic/Project association
5. Priority recommendation (low/medium/high/critical)
6. Estimated complexity (simple/moderate/complex)

Respond in JSON format:
{
  "title": "Task title",
  "objective": "What needs to be accomplished",
  "importance": "Why it matters",
  "suggestedEpic": "Epic name or null",
  "suggestedProject": "Project name or null",
  "priority": "medium",
  "complexity": "moderate",
  "subtasks": ["subtask 1", "subtask 2"] // if complex
}`,
  taskBreakdownPrompt: `You are an expert project manager. Break down the following epic/task into smaller, actionable tasks.

EPIC/TASK: {{title}}
DESCRIPTION: {{description}}
OBJECTIVE: {{objective}}

Context:
- Goal: {{goal}}
- Project: {{project}}
- Area: {{area}}

Create 3-8 well-structured subtasks that:
1. Are specific and actionable
2. Can be completed in 1-4 hours each
3. Have clear dependencies (if any)
4. Lead to completing the parent task/epic

Respond in JSON format:
{
  "tasks": [
    {
      "title": "Task title",
      "objective": "What this task accomplishes",
      "priority": "medium",
      "dependsOn": null // or task index
    }
  ]
}`,
  prioritizationPrompt: `You are a productivity expert. Analyze the following tasks and suggest optimal prioritization.

TASKS:
{{tasks}}

USER'S CURRENT FOCUS:
- Active Goals: {{goals}}
- Deadlines: {{deadlines}}
- Available Time: {{availableTime}}

Provide prioritization recommendations considering:
1. Urgency and deadlines
2. Alignment with current goals
3. Dependencies between tasks
4. Effort vs impact ratio

Respond in JSON format:
{
  "prioritizedTasks": [
    {
      "title": "Task title",
      "suggestedPriority": "high",
      "reasoning": "Why this priority",
      "suggestedOrder": 1
    }
  ],
  "insights": "Overall productivity insights"
}`
};
var GptTaskManagerSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.addClass("gpt-task-manager-settings");
    containerEl.createEl("h1", { text: "GPT Task Manager Settings" });
    containerEl.createEl("h2", { text: "\u{1F511} API Configuration" });
    new import_obsidian.Setting(containerEl).setName("OpenAI API Key").setDesc("Your OpenAI API key for GPT and Whisper.").addText(
      (text) => text.setPlaceholder("sk-...").setValue(this.plugin.settings.openAIApiKey).onChange(async (value) => {
        this.plugin.settings.openAIApiKey = value;
        await this.plugin.saveSettings();
      })
    ).then((setting) => {
      const inputEl = setting.controlEl.querySelector("input");
      if (inputEl) {
        inputEl.type = "password";
        inputEl.style.width = "300px";
      }
    });
    new import_obsidian.Setting(containerEl).setName("GPT Model").setDesc("The OpenAI model to use for task assistance (gpt-4o-mini, gpt-4o, gpt-4-turbo).").addDropdown(
      (dropdown) => dropdown.addOption("gpt-4o-mini", "GPT-4o Mini (Fast, Cheap)").addOption("gpt-4o", "GPT-4o (Powerful)").addOption("gpt-4-turbo", "GPT-4 Turbo").addOption("gpt-3.5-turbo", "GPT-3.5 Turbo (Legacy)").setValue(this.plugin.settings.gptModel).onChange(async (value) => {
        this.plugin.settings.gptModel = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("GPT Max Tokens").setDesc("Maximum tokens for GPT responses (500-4000).").addText(
      (text) => text.setPlaceholder("2000").setValue(String(this.plugin.settings.gptMaxTokens)).onChange(async (value) => {
        const parsed = parseInt(value, 10);
        this.plugin.settings.gptMaxTokens = isNaN(parsed) ? 2e3 : Math.max(500, Math.min(4e3, parsed));
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("GPT Temperature").setDesc("Creativity level (0.0-1.0). Lower = more focused, Higher = more creative.").addText(
      (text) => text.setPlaceholder("0.7").setValue(String(this.plugin.settings.gptTemperature)).onChange(async (value) => {
        const parsed = parseFloat(value);
        this.plugin.settings.gptTemperature = isNaN(parsed) ? 0.7 : Math.max(0, Math.min(1, parsed));
        await this.plugin.saveSettings();
      })
    );
    containerEl.createEl("h2", { text: "\u{1F504} API Reliability" });
    new import_obsidian.Setting(containerEl).setName("Request Timeout").setDesc("Timeout for API requests in seconds (10-120).").addText(
      (text) => text.setPlaceholder("60").setValue(String(this.plugin.settings.apiTimeoutSeconds)).onChange(async (value) => {
        const parsed = parseInt(value, 10);
        this.plugin.settings.apiTimeoutSeconds = isNaN(parsed) ? 60 : Math.max(10, Math.min(120, parsed));
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Max Retries").setDesc("Maximum retry attempts for failed requests (0-5).").addText(
      (text) => text.setPlaceholder("3").setValue(String(this.plugin.settings.apiMaxRetries)).onChange(async (value) => {
        const parsed = parseInt(value, 10);
        this.plugin.settings.apiMaxRetries = isNaN(parsed) ? 3 : Math.max(0, Math.min(5, parsed));
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Rate Limit (per minute)").setDesc("Maximum API requests per minute to prevent abuse (5-30).").addText(
      (text) => text.setPlaceholder("10").setValue(String(this.plugin.settings.rateLimitPerMinute)).onChange(async (value) => {
        const parsed = parseInt(value, 10);
        this.plugin.settings.rateLimitPerMinute = isNaN(parsed) ? 10 : Math.max(5, Math.min(30, parsed));
        await this.plugin.saveSettings();
      })
    );
    containerEl.createEl("h2", { text: "\u{1F4C1} Vault Paths" });
    new import_obsidian.Setting(containerEl).setName("Tasks Folder").setDesc("Path to your tasks folder (e.g., 500 Plan & Reflect/520 Tasks).").addText(
      (text) => text.setPlaceholder("500 Plan & Reflect/520 Tasks").setValue(this.plugin.settings.tasksFolder).onChange(async (value) => {
        this.plugin.settings.tasksFolder = (0, import_obsidian.normalizePath)(value.trim());
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Epics Folder").setDesc("Path to your epics folder.").addText(
      (text) => text.setPlaceholder("500 Plan & Reflect/510 Epics").setValue(this.plugin.settings.epicsFolder).onChange(async (value) => {
        this.plugin.settings.epicsFolder = (0, import_obsidian.normalizePath)(value.trim());
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Goals Folder").setDesc("Path to your goals folder.").addText(
      (text) => text.setPlaceholder("300 Goals & Milestone/Goals").setValue(this.plugin.settings.goalsFolder).onChange(async (value) => {
        this.plugin.settings.goalsFolder = (0, import_obsidian.normalizePath)(value.trim());
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Projects Folder").setDesc("Path to your projects folder.").addText(
      (text) => text.setPlaceholder("400 Projects").setValue(this.plugin.settings.projectsFolder).onChange(async (value) => {
        this.plugin.settings.projectsFolder = (0, import_obsidian.normalizePath)(value.trim());
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Task Template Path").setDesc("Path to your task template file.").addText(
      (text) => text.setPlaceholder("900 Templates/4 Task Template.md").setValue(this.plugin.settings.taskTemplatePath).onChange(async (value) => {
        this.plugin.settings.taskTemplatePath = (0, import_obsidian.normalizePath)(value.trim());
        await this.plugin.saveSettings();
      })
    );
    containerEl.createEl("h2", { text: "\u26A1 Features" });
    new import_obsidian.Setting(containerEl).setName("Enable Voice Input").setDesc("Allow creating tasks via voice recording (requires microphone access).").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.enableVoiceInput).onChange(async (value) => {
        this.plugin.settings.enableVoiceInput = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Enable Smart Suggestions").setDesc("Use GPT to suggest task details based on your goals and context.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.enableSmartSuggestions).onChange(async (value) => {
        this.plugin.settings.enableSmartSuggestions = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Enable Auto Breakdown").setDesc("Automatically suggest breaking down complex tasks into subtasks.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.enableAutoBreakdown).onChange(async (value) => {
        this.plugin.settings.enableAutoBreakdown = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Default Language").setDesc("Default language for voice transcription and GPT responses.").addDropdown(
      (dropdown) => dropdown.addOption("ko", "\uD55C\uAD6D\uC5B4 (Korean)").addOption("en", "English").addOption("auto", "Auto-detect").setValue(this.plugin.settings.defaultLanguage).onChange(async (value) => {
        this.plugin.settings.defaultLanguage = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("UI Language").setDesc("Language for plugin interface elements.").addDropdown(
      (dropdown) => dropdown.addOption("en", "English").addOption("ko", "\uD55C\uAD6D\uC5B4 (Korean)").addOption("ja", "\u65E5\u672C\u8A9E (Japanese)").addOption("zh", "\u4E2D\u6587 (Chinese)").setValue(this.plugin.settings.uiLocale).onChange(async (value) => {
        this.plugin.settings.uiLocale = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Enable Context Cache").setDesc("Cache vault context (goals, projects, epics) for faster performance.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.enableContextCache).onChange(async (value) => {
        this.plugin.settings.enableContextCache = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Show Confirmation Dialogs").setDesc("Show confirmation before creating tasks.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.showConfirmationDialogs).onChange(async (value) => {
        this.plugin.settings.showConfirmationDialogs = value;
        await this.plugin.saveSettings();
      })
    );
    containerEl.createEl("h2", { text: "\u{1F4CB} Kanban Integration" });
    containerEl.createEl("p", {
      text: "Integrate with obsidian-base-kanban plugin to view and manage tasks in a Kanban board format.",
      cls: "setting-item-description"
    });
    new import_obsidian.Setting(containerEl).setName("Enable Kanban Integration").setDesc("Enable integration with obsidian-base-kanban plugin for visual task management.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.enableKanbanIntegration).onChange(async (value) => {
        this.plugin.settings.enableKanbanIntegration = value;
        await this.plugin.saveSettings();
        this.display();
      })
    );
    if (this.plugin.settings.enableKanbanIntegration) {
      new import_obsidian.Setting(containerEl).setName("Kanban Boards Folder").setDesc("Folder where Kanban board files will be stored.").addText(
        (text) => text.setPlaceholder("500 Plan & Reflect/530 Boards").setValue(this.plugin.settings.kanbanBoardsFolder).onChange(async (value) => {
          this.plugin.settings.kanbanBoardsFolder = (0, import_obsidian.normalizePath)(value.trim());
          await this.plugin.saveSettings();
        })
      );
      new import_obsidian.Setting(containerEl).setName("Default Board Name").setDesc("Name for the default 'All Tasks' Kanban board.").addText(
        (text) => text.setPlaceholder("All Tasks Board").setValue(this.plugin.settings.defaultKanbanBoardName).onChange(async (value) => {
          this.plugin.settings.defaultKanbanBoardName = value.trim() || "All Tasks Board";
          await this.plugin.saveSettings();
        })
      );
      new import_obsidian.Setting(containerEl).setName("Auto-sync on Task Change").setDesc("Automatically refresh Kanban board when tasks are created or modified.").addToggle(
        (toggle) => toggle.setValue(this.plugin.settings.autoSyncKanbanOnTaskChange).onChange(async (value) => {
          this.plugin.settings.autoSyncKanbanOnTaskChange = value;
          await this.plugin.saveSettings();
        })
      );
      containerEl.createEl("h3", { text: "Lane \u2194 Status Mapping" });
      containerEl.createEl("p", {
        text: "Map task status values to Kanban lane names. These should match the lane titles in obsidian-base-kanban.",
        cls: "setting-item-description"
      });
      new import_obsidian.Setting(containerEl).setName("Backlog Lane Name").addText(
        (text) => text.setPlaceholder("Backlog").setValue(this.plugin.settings.kanbanStatusMapping.backlog).onChange(async (value) => {
          this.plugin.settings.kanbanStatusMapping.backlog = value.trim() || "Backlog";
          await this.plugin.saveSettings();
        })
      );
      new import_obsidian.Setting(containerEl).setName("To Do Lane Name").addText(
        (text) => text.setPlaceholder("To Do").setValue(this.plugin.settings.kanbanStatusMapping.todo).onChange(async (value) => {
          this.plugin.settings.kanbanStatusMapping.todo = value.trim() || "To Do";
          await this.plugin.saveSettings();
        })
      );
      new import_obsidian.Setting(containerEl).setName("In Progress Lane Name").addText(
        (text) => text.setPlaceholder("In Progress").setValue(this.plugin.settings.kanbanStatusMapping.inProgress).onChange(async (value) => {
          this.plugin.settings.kanbanStatusMapping.inProgress = value.trim() || "In Progress";
          await this.plugin.saveSettings();
        })
      );
      new import_obsidian.Setting(containerEl).setName("Done Lane Name").addText(
        (text) => text.setPlaceholder("Done").setValue(this.plugin.settings.kanbanStatusMapping.done).onChange(async (value) => {
          this.plugin.settings.kanbanStatusMapping.done = value.trim() || "Done";
          await this.plugin.saveSettings();
        })
      );
    }
    containerEl.createEl("h2", { text: "\u{1F50D} Logging & Debugging" });
    new import_obsidian.Setting(containerEl).setName("Log Level").setDesc("Minimum log level for console output.").addDropdown(
      (dropdown) => dropdown.addOption("debug", "Debug (Verbose)").addOption("info", "Info (Normal)").addOption("warn", "Warnings Only").addOption("error", "Errors Only").addOption("none", "Disabled").setValue(this.plugin.settings.logLevel).onChange(async (value) => {
        this.plugin.settings.logLevel = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Show Debug Notices").setDesc("Show debug information in Obsidian notices (useful for troubleshooting).").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.enableDebugNotices).onChange(async (value) => {
        this.plugin.settings.enableDebugNotices = value;
        await this.plugin.saveSettings();
      })
    );
    containerEl.createEl("h2", { text: "\u{1F4CB} Task Defaults" });
    new import_obsidian.Setting(containerEl).setName("Default Status").setDesc("Default status for new tasks.").addDropdown(
      (dropdown) => dropdown.addOption("backlog", "Backlog").addOption("todo", "To Do").addOption("in-progress", "In Progress").setValue(this.plugin.settings.defaultStatus).onChange(async (value) => {
        this.plugin.settings.defaultStatus = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Default Priority").setDesc("Default priority for new tasks.").addDropdown(
      (dropdown) => dropdown.addOption("low", "Low").addOption("medium", "Medium").addOption("high", "High").addOption("critical", "Critical").setValue(this.plugin.settings.defaultPriority).onChange(async (value) => {
        this.plugin.settings.defaultPriority = value;
        await this.plugin.saveSettings();
      })
    );
    containerEl.createEl("h2", { text: "\u{1F916} GPT Prompts" });
    containerEl.createEl("p", {
      text: "Customize the prompts used for GPT-powered features. Use {{placeholders}} for dynamic content.",
      cls: "setting-item-description"
    });
    new import_obsidian.Setting(containerEl).setName("Task Creation Prompt").setDesc("Prompt used when creating new tasks with GPT assistance.").addTextArea((text) => {
      text.setPlaceholder("Enter your task creation prompt...").setValue(this.plugin.settings.taskCreationPrompt).onChange(async (value) => {
        this.plugin.settings.taskCreationPrompt = value;
        await this.plugin.saveSettings();
      });
      text.inputEl.rows = 10;
      text.inputEl.style.width = "100%";
      text.inputEl.style.fontFamily = "monospace";
      text.inputEl.style.fontSize = "12px";
    });
    new import_obsidian.Setting(containerEl).setName("Task Breakdown Prompt").setDesc("Prompt used when breaking down tasks/epics into subtasks.").addTextArea((text) => {
      text.setPlaceholder("Enter your task breakdown prompt...").setValue(this.plugin.settings.taskBreakdownPrompt).onChange(async (value) => {
        this.plugin.settings.taskBreakdownPrompt = value;
        await this.plugin.saveSettings();
      });
      text.inputEl.rows = 10;
      text.inputEl.style.width = "100%";
      text.inputEl.style.fontFamily = "monospace";
      text.inputEl.style.fontSize = "12px";
    });
    containerEl.createEl("h2", { text: "\u{1F504} Reset" });
    new import_obsidian.Setting(containerEl).setName("Reset to Defaults").setDesc("Reset all settings to their default values.").addButton(
      (button) => button.setButtonText("Reset All Settings").setWarning().onClick(async () => {
        const apiKey = this.plugin.settings.openAIApiKey;
        this.plugin.settings = { ...DEFAULT_SETTINGS, openAIApiKey: apiKey };
        await this.plugin.saveSettings();
        this.display();
      })
    );
  }
};

// src/api-client.ts
var import_obsidian2 = require("obsidian");

// src/logger.ts
var SENSITIVE_PATTERNS = [
  /sk-[a-zA-Z0-9]{20,}/g,
  // OpenAI API keys
  /Bearer\s+[a-zA-Z0-9._-]+/gi,
  // Bearer tokens
  /api[_-]?key["\s:=]+[^\s"',}]+/gi,
  // Generic API key patterns
  /password["\s:=]+[^\s"',}]+/gi
  // Passwords
];
var PLUGIN_PREFIX = "[GPT Task Manager]";
var Logger = class {
  constructor() {
    this.logLevel = 1 /* INFO */;
    this.logHistory = [];
    this.maxHistorySize = 100;
    this.listeners = [];
  }
  /**
   * Set the current log level
   */
  setLogLevel(level) {
    this.logLevel = level;
  }
  /**
   * Get current log level
   */
  getLogLevel() {
    return this.logLevel;
  }
  /**
   * Add a listener for log entries (for telemetry/UI)
   */
  addListener(listener) {
    this.listeners.push(listener);
    return () => {
      this.listeners = this.listeners.filter((listenerItem) => listenerItem !== listener);
    };
  }
  /**
   * Get recent log history
   */
  getHistory(limit) {
    const historyLimit = limit || this.maxHistorySize;
    return this.logHistory.slice(-historyLimit);
  }
  /**
   * Clear log history
   */
  clearHistory() {
    this.logHistory = [];
  }
  /**
   * Sanitize text to remove sensitive information
   */
  sanitize(text) {
    let sanitized = text;
    for (const pattern of SENSITIVE_PATTERNS) {
      sanitized = sanitized.replace(pattern, "[REDACTED]");
    }
    return sanitized;
  }
  /**
   * Sanitize an object recursively
   */
  sanitizeObject(obj) {
    if (obj === null || obj === void 0) {
      return obj;
    }
    if (typeof obj === "string") {
      return this.sanitize(obj);
    }
    if (Array.isArray(obj)) {
      return obj.map((item) => this.sanitizeObject(item));
    }
    if (typeof obj === "object") {
      const sanitized = {};
      for (const [key, value] of Object.entries(obj)) {
        const lowerKey = key.toLowerCase();
        if (lowerKey.includes("apikey") || lowerKey.includes("api_key") || lowerKey.includes("password") || lowerKey.includes("secret") || lowerKey.includes("token") || lowerKey.includes("authorization")) {
          sanitized[key] = "[REDACTED]";
        } else {
          sanitized[key] = this.sanitizeObject(value);
        }
      }
      return sanitized;
    }
    return obj;
  }
  /**
   * Create a log entry
   */
  log(level, category, message, data) {
    if (level < this.logLevel) {
      return;
    }
    const entry = {
      timestamp: (/* @__PURE__ */ new Date()).toISOString(),
      level,
      category,
      message: this.sanitize(message),
      data: data ? this.sanitizeObject(data) : void 0
    };
    this.logHistory.push(entry);
    if (this.logHistory.length > this.maxHistorySize) {
      this.logHistory.shift();
    }
    for (const listener of this.listeners) {
      try {
        listener(entry);
      } catch (e) {
      }
    }
    const prefix = `${PLUGIN_PREFIX} [${category}]`;
    const dataStr = data ? ` ${JSON.stringify(this.sanitizeObject(data))}` : "";
    switch (level) {
      case 0 /* DEBUG */:
        console.debug(`${prefix} ${message}${dataStr}`);
        break;
      case 1 /* INFO */:
        console.log(`${prefix} ${message}${dataStr}`);
        break;
      case 2 /* WARN */:
        console.warn(`${prefix} ${message}${dataStr}`);
        break;
      case 3 /* ERROR */:
        console.error(`${prefix} ${message}${dataStr}`);
        break;
    }
  }
  debug(category, message, data) {
    this.log(0 /* DEBUG */, category, message, data);
  }
  info(category, message, data) {
    this.log(1 /* INFO */, category, message, data);
  }
  warn(category, message, data) {
    this.log(2 /* WARN */, category, message, data);
  }
  error(category, message, data) {
    this.log(3 /* ERROR */, category, message, data);
  }
};
var logger = new Logger();
function scopeTextForApi(text, maxLength = 4e3) {
  const sanitized = logger.sanitize(text);
  if (sanitized.length <= maxLength) {
    return sanitized;
  }
  return sanitized.substring(0, maxLength - 3) + "...";
}

// src/api-client.ts
var CATEGORY = "APIClient";
var CancellationToken = class {
  constructor() {
    this._isCancelled = false;
    this._reason = "";
    this._callbacks = [];
  }
  get isCancelled() {
    return this._isCancelled;
  }
  get reason() {
    return this._reason;
  }
  cancel(reason = "User cancelled") {
    if (this._isCancelled)
      return;
    this._isCancelled = true;
    this._reason = reason;
    for (const callback of this._callbacks) {
      try {
        callback();
      } catch (e) {
      }
    }
  }
  onCancel(callback) {
    if (this._isCancelled) {
      callback();
    } else {
      this._callbacks.push(callback);
    }
  }
  throwIfCancelled() {
    if (this._isCancelled) {
      throw new CancellationError(this._reason);
    }
  }
};
var CancellationError = class extends Error {
  constructor(reason) {
    super(reason);
    this.name = "CancellationError";
  }
};
var RateLimiter = class {
  constructor(maxRequests = 10, windowMs = 6e4) {
    this.requests = [];
    this.maxRequests = maxRequests;
    this.windowMs = windowMs;
  }
  canMakeRequest() {
    this.cleanup();
    return this.requests.length < this.maxRequests;
  }
  recordRequest() {
    this.requests.push(Date.now());
  }
  getWaitTime() {
    this.cleanup();
    if (this.requests.length < this.maxRequests) {
      return 0;
    }
    const oldestRequest = this.requests[0];
    return oldestRequest + this.windowMs - Date.now();
  }
  cleanup() {
    const cutoff = Date.now() - this.windowMs;
    this.requests = this.requests.filter((timestamp) => timestamp > cutoff);
  }
};
var rateLimiter = new RateLimiter(10, 6e4);
function calculateBackoffDelay(retryCount, baseDelayMs) {
  const exponentialDelay = baseDelayMs * Math.pow(2, retryCount);
  const jitter = Math.random() * 1e3;
  return Math.min(exponentialDelay + jitter, 3e4);
}
function isRetryableError(statusCode) {
  return statusCode === 429 || statusCode >= 500 && statusCode < 600;
}
function extractErrorMessage(response) {
  var _a, _b;
  try {
    const body = response.json || response.text;
    if (typeof body === "object" && ((_a = body == null ? void 0 : body.error) == null ? void 0 : _a.message)) {
      return body.error.message;
    }
    if (typeof body === "string" && body.length < 200) {
      try {
        const parsed = JSON.parse(body);
        if ((_b = parsed == null ? void 0 : parsed.error) == null ? void 0 : _b.message) {
          return parsed.error.message;
        }
      } catch (e) {
        return body;
      }
    }
  } catch (e) {
  }
  return `HTTP ${response.status}`;
}
function getErrorWithRecovery(statusCode, message) {
  switch (statusCode) {
    case 401:
      return `Authentication failed: ${message}. Please check your API key in settings.`;
    case 403:
      return `Access denied: ${message}. Your API key may lack required permissions.`;
    case 429:
      return `Rate limited: ${message}. Please wait a moment before trying again.`;
    case 500:
    case 502:
    case 503:
    case 504:
      return `Server error: ${message}. The API is temporarily unavailable. Please try again later.`;
    default:
      return message;
  }
}
function sleep(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}
async function makeApiRequest(config, cancellationToken) {
  const {
    url,
    method,
    headers = {},
    body,
    timeout = 3e4,
    maxRetries = 3,
    retryDelayMs = 1e3
  } = config;
  if (!rateLimiter.canMakeRequest()) {
    const waitTime = rateLimiter.getWaitTime();
    logger.warn(CATEGORY, `Rate limit reached, need to wait ${waitTime}ms`);
    return {
      success: false,
      data: null,
      error: `Rate limited. Please wait ${Math.ceil(waitTime / 1e3)} seconds.`,
      statusCode: 429,
      retryCount: 0,
      cancelled: false
    };
  }
  let retryCount = 0;
  let lastError = "";
  let lastStatusCode = 0;
  while (retryCount <= maxRetries) {
    if (cancellationToken == null ? void 0 : cancellationToken.isCancelled) {
      logger.info(CATEGORY, "Request cancelled by user");
      return {
        success: false,
        data: null,
        error: cancellationToken.reason,
        statusCode: 0,
        retryCount,
        cancelled: true
      };
    }
    try {
      logger.debug(CATEGORY, `Making request attempt ${retryCount + 1}/${maxRetries + 1}`, {
        url,
        method,
        timeout
      });
      rateLimiter.recordRequest();
      const timeoutPromise = new Promise((_, reject) => {
        setTimeout(() => reject(new Error("Request timeout")), timeout);
      });
      const requestPromise = (0, import_obsidian2.requestUrl)({
        url,
        method,
        headers,
        body,
        throw: false
      });
      const response = await Promise.race([requestPromise, timeoutPromise]);
      lastStatusCode = response.status;
      if (response.status >= 200 && response.status < 300) {
        logger.info(CATEGORY, `Request successful`, { statusCode: response.status });
        return {
          success: true,
          data: response.json,
          error: null,
          statusCode: response.status,
          retryCount,
          cancelled: false
        };
      }
      lastError = extractErrorMessage(response);
      logger.warn(CATEGORY, `Request failed`, { statusCode: response.status, error: lastError });
      if (isRetryableError(response.status) && retryCount < maxRetries) {
        const delay = calculateBackoffDelay(retryCount, retryDelayMs);
        logger.info(CATEGORY, `Retrying in ${delay}ms (attempt ${retryCount + 2}/${maxRetries + 1})`);
        const startWait = Date.now();
        while (Date.now() - startWait < delay) {
          if (cancellationToken == null ? void 0 : cancellationToken.isCancelled) {
            return {
              success: false,
              data: null,
              error: cancellationToken.reason,
              statusCode: 0,
              retryCount,
              cancelled: true
            };
          }
          await sleep(100);
        }
        retryCount++;
        continue;
      }
      break;
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : "Unknown error";
      lastError = errorMessage;
      logger.error(CATEGORY, `Request exception`, { error: errorMessage });
      if (errorMessage === "Request timeout" && retryCount < maxRetries) {
        const delay = calculateBackoffDelay(retryCount, retryDelayMs);
        logger.info(CATEGORY, `Timeout, retrying in ${delay}ms`);
        await sleep(delay);
        retryCount++;
        continue;
      }
      break;
    }
  }
  const finalError = getErrorWithRecovery(lastStatusCode, lastError);
  return {
    success: false,
    data: null,
    error: finalError,
    statusCode: lastStatusCode,
    retryCount,
    cancelled: false
  };
}
async function callOpenAIChatApi(prompt, systemPrompt, config, cancellationToken) {
  var _a, _b, _c, _d;
  const scopedPrompt = scopeTextForApi(prompt, 8e3);
  const scopedSystem = scopeTextForApi(systemPrompt, 2e3);
  const response = await makeApiRequest({
    url: "https://api.openai.com/v1/chat/completions",
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      "Authorization": `Bearer ${config.apiKey}`
    },
    body: JSON.stringify({
      model: config.model,
      messages: [
        { role: "system", content: scopedSystem },
        { role: "user", content: scopedPrompt }
      ],
      max_tokens: config.maxTokens,
      temperature: config.temperature
    }),
    timeout: config.timeout || 6e4,
    maxRetries: config.maxRetries || 3
  }, cancellationToken);
  if (!response.success) {
    return {
      ...response,
      data: null
    };
  }
  const content = (_d = (_c = (_b = (_a = response.data) == null ? void 0 : _a.choices) == null ? void 0 : _b[0]) == null ? void 0 : _c.message) == null ? void 0 : _d.content;
  if (!content) {
    return {
      success: false,
      data: null,
      error: "Empty response from API",
      statusCode: response.statusCode,
      retryCount: response.retryCount,
      cancelled: false
    };
  }
  return {
    success: true,
    data: { content },
    error: null,
    statusCode: response.statusCode,
    retryCount: response.retryCount,
    cancelled: false
  };
}
async function callWhisperApi(audioBlob, apiKey, model = "whisper-1", language, cancellationToken) {
  var _a;
  if (cancellationToken == null ? void 0 : cancellationToken.isCancelled) {
    return {
      success: false,
      data: null,
      error: cancellationToken.reason,
      statusCode: 0,
      retryCount: 0,
      cancelled: true
    };
  }
  const formData = new FormData();
  formData.append("file", audioBlob, "audio.webm");
  formData.append("model", model);
  if (language && language !== "auto") {
    formData.append("language", language);
  }
  try {
    const controller = new AbortController();
    cancellationToken == null ? void 0 : cancellationToken.onCancel(() => {
      controller.abort();
    });
    const response = await fetch("https://api.openai.com/v1/audio/transcriptions", {
      method: "POST",
      headers: {
        "Authorization": `Bearer ${apiKey}`
      },
      body: formData,
      signal: controller.signal
    });
    if (!response.ok) {
      const errorText = await response.text();
      let errorMessage = `HTTP ${response.status}`;
      try {
        const errorJson = JSON.parse(errorText);
        errorMessage = ((_a = errorJson == null ? void 0 : errorJson.error) == null ? void 0 : _a.message) || errorMessage;
      } catch (e) {
        if (errorText.length < 200) {
          errorMessage = errorText;
        }
      }
      return {
        success: false,
        data: null,
        error: getErrorWithRecovery(response.status, errorMessage),
        statusCode: response.status,
        retryCount: 0,
        cancelled: false
      };
    }
    const data = await response.json();
    return {
      success: true,
      data: { text: data.text },
      error: null,
      statusCode: response.status,
      retryCount: 0,
      cancelled: false
    };
  } catch (error) {
    if (error instanceof Error && error.name === "AbortError") {
      return {
        success: false,
        data: null,
        error: "Request cancelled",
        statusCode: 0,
        retryCount: 0,
        cancelled: true
      };
    }
    const errorMessage = error instanceof Error ? error.message : "Unknown error";
    logger.error(CATEGORY, "Whisper API error", { error: errorMessage });
    return {
      success: false,
      data: null,
      error: errorMessage,
      statusCode: 0,
      retryCount: 0,
      cancelled: false
    };
  }
}
function setRateLimitConfig(maxRequests, windowMs) {
  Object.assign(rateLimiter, new RateLimiter(maxRequests, windowMs));
}

// src/gpt-service.ts
var CATEGORY2 = "GPTService";
async function callGptApi(prompt, systemPrompt, apiKey, model, maxTokens, temperature, cancellationToken, timeoutSeconds = 60, maxRetries = 3) {
  var _a;
  if (!apiKey) {
    logger.warn(CATEGORY2, "No API key configured");
    return { success: false, content: null, errorMessage: "No API key configured" };
  }
  logger.info(CATEGORY2, `Calling GPT API`, { model, maxTokens, temperature });
  const config = {
    apiKey,
    model,
    maxTokens,
    temperature,
    timeout: timeoutSeconds * 1e3,
    maxRetries
  };
  const response = await callOpenAIChatApi(
    prompt,
    systemPrompt,
    config,
    cancellationToken
  );
  if (response.cancelled) {
    logger.info(CATEGORY2, "GPT API call was cancelled");
    return {
      success: false,
      content: null,
      errorMessage: "Request cancelled",
      cancelled: true
    };
  }
  if (!response.success) {
    logger.error(CATEGORY2, "GPT API call failed", { error: response.error });
    return {
      success: false,
      content: null,
      errorMessage: response.error || "Unknown error"
    };
  }
  const content = (_a = response.data) == null ? void 0 : _a.content;
  if (!content) {
    logger.warn(CATEGORY2, "GPT API returned empty content");
    return {
      success: false,
      content: null,
      errorMessage: "Empty response from API"
    };
  }
  logger.info(CATEGORY2, `GPT response received`, { contentLength: content.length });
  return { success: true, content, errorMessage: null };
}
function extractJsonFromResponse(response) {
  const codeBlockMatch = response.match(/```(?:json)?\s*([\s\S]*?)```/);
  if (codeBlockMatch) {
    return codeBlockMatch[1].trim();
  }
  const jsonMatch = response.match(/\{[\s\S]*\}/);
  if (jsonMatch) {
    return jsonMatch[0];
  }
  return response;
}
function generateFallbackTitle() {
  const now = /* @__PURE__ */ new Date();
  return `Task-${now.getFullYear()}${String(now.getMonth() + 1).padStart(2, "0")}${String(now.getDate()).padStart(2, "0")}-${String(now.getHours()).padStart(2, "0")}${String(now.getMinutes()).padStart(2, "0")}`;
}
function ensureValidTitle(title, fallbackSource) {
  const trimmedTitle = (title || "").trim();
  if (trimmedTitle.length > 0) {
    return trimmedTitle;
  }
  const trimmedFallback = (fallbackSource || "").trim();
  if (trimmedFallback.length > 0) {
    return trimmedFallback.substring(0, 50);
  }
  return generateFallbackTitle();
}
function parseTaskSuggestion(response) {
  try {
    const jsonStr = extractJsonFromResponse(response);
    const parsed = JSON.parse(jsonStr);
    return {
      title: ensureValidTitle(parsed.title, parsed.objective),
      objective: parsed.objective || "",
      importance: parsed.importance || "",
      suggestedEpic: parsed.suggestedEpic || null,
      suggestedProject: parsed.suggestedProject || null,
      priority: parsed.priority || "medium",
      complexity: parsed.complexity || "moderate",
      subtasks: Array.isArray(parsed.subtasks) ? parsed.subtasks : []
    };
  } catch (error) {
    console.error("[GPT Task Manager] Failed to parse task suggestion:", error);
    return null;
  }
}
function parseTaskBreakdown(response) {
  try {
    const jsonStr = extractJsonFromResponse(response);
    const parsed = JSON.parse(jsonStr);
    if (!Array.isArray(parsed.tasks)) {
      return null;
    }
    return {
      tasks: parsed.tasks.map((task, taskIndex) => {
        var _a;
        return {
          title: ensureValidTitle(task.title, task.objective) || `Subtask-${taskIndex + 1}`,
          objective: task.objective || "",
          priority: task.priority || "medium",
          dependsOn: (_a = task.dependsOn) != null ? _a : null
        };
      })
    };
  } catch (error) {
    console.error("[GPT Task Manager] Failed to parse task breakdown:", error);
    return null;
  }
}
function fillPromptTemplate(template, values) {
  let result = template;
  for (const [key, value] of Object.entries(values)) {
    result = result.replace(
      new RegExp(`\\{\\{${key}\\}\\}`, "g"),
      () => value
    );
  }
  return result;
}

// src/voice.ts
var import_obsidian3 = require("obsidian");

// src/i18n.ts
var en = {
  // Common
  cancel: "Cancel",
  confirm: "Confirm",
  create: "Create",
  save: "Save",
  delete: "Delete",
  close: "Close",
  loading: "Loading...",
  error: "Error",
  success: "Success",
  retry: "Retry",
  // Task creation
  quickTaskTitle: "\u{1F680} Quick Task Creation",
  quickTaskDescription: "Describe your task naturally. GPT will help structure it based on your goals and projects.",
  quickTaskPlaceholder: "e.g., Create a landing page for the Freedom Runway project with high priority",
  createWithAi: "\u2728 Create with AI",
  simpleCreate: "Create (No AI)",
  taskCreationCancelled: "Task creation cancelled",
  taskCreated: "\u2705 Created task: {title}",
  taskCreationFailed: "Failed to create task: {error}",
  pleaseEnterDescription: "Please enter a task description",
  pleaseSelectText: "Please select some text first",
  // Voice
  voiceRecording: "\u{1F3A4} Voice Recording",
  voiceRecordingStart: "Start Recording",
  voiceRecordingStop: "Stop Recording",
  voiceRecordingCancel: "Cancel",
  voiceTranscribing: "\u{1F3A4} Transcribing...",
  voiceInstructions: "Speak clearly and describe your task. Include priority, epic, or project names if relevant.",
  // Review modal
  reviewTask: "\u{1F4CB} Review Task",
  reviewTitle: "Title",
  reviewObjective: "Objective",
  reviewImportance: "Why it matters",
  reviewEpic: "Epic",
  reviewPriority: "Priority",
  reviewSubtasks: "Suggested Subtasks ({count})",
  noEpic: "-- No Epic --",
  createTask: "\u2713 Create Task",
  // Breakdown
  breakdownTitle: "\u{1F4CA} Task Breakdown: {epic}",
  breakdownDescription: "{count} tasks will be created:",
  breakdownTaskCount: "{count} tasks",
  breakdownDependsOn: "Depends on: Task {index}",
  breakdownCreating: "\u{1F916} Breaking down: {epic}...",
  // Confirmation
  confirmTaskCreation: "\u{1F4CB} Confirm Task Creation ({count} tasks)",
  confirmTaskCreationSingle: "\u{1F4CB} Confirm Task Creation",
  confirmTasksWillBeCreated: "The following tasks will be created:",
  confirmTargetFolder: "\u{1F4C1} {folder}",
  confirmCreateTasks: "\u2713 Create {count} Tasks",
  confirmCreateTask: "\u2713 Create Task",
  // Errors
  errorNoApiKey: "Please set your OpenAI API key in settings first.",
  errorVoiceDisabled: "Voice input is disabled. Enable it in settings.",
  errorNoEpics: "No epics found in your vault.",
  errorNoSelection: "Please select some text first.",
  errorRateLimited: "Rate limited. Please wait {seconds} seconds.",
  errorTimeout: "Request timed out. Please try again.",
  errorServerError: "Server error. Please try again later.",
  errorAuthFailed: "Authentication failed. Please check your API key.",
  errorParsingFailed: "Failed to parse GPT response. Creating simple task.",
  errorBreakdownTooLarge: "GPT returned {count} tasks (max {max}). Truncated to first {max}.",
  errorBreakdownEmpty: "GPT returned no tasks. Please try again or adjust your epic description.",
  // Progress
  progressProcessing: "\u{1F916} Processing with GPT...",
  progressBreakingDown: "\u{1F916} Breaking down epic...",
  progressCreatingTasks: "Creating tasks...",
  progressTranscribing: "\u{1F3A4} Transcribing audio...",
  // Settings
  settingsApiConfig: "\u{1F511} API Configuration",
  settingsVaultPaths: "\u{1F4C1} Vault Paths",
  settingsFeatures: "\u26A1 Features",
  settingsDefaults: "\u{1F4CB} Task Defaults",
  settingsPrompts: "\u{1F916} GPT Prompts",
  settingsReset: "\u{1F504} Reset",
  // Conflict resolution
  conflictFileExists: "File already exists: {filename}",
  conflictRename: "Rename",
  conflictOverwrite: "Overwrite",
  conflictSkip: "Skip",
  // Accessibility
  ariaCloseModal: "Close modal",
  ariaConfirmButton: "Confirm action",
  ariaCancelButton: "Cancel action",
  ariaLoadingIndicator: "Loading, please wait",
  ariaTaskList: "Task list",
  ariaPriorityBadge: "Priority: {priority}",
  // Kanban Integration
  kanbanNotEnabled: "Kanban integration is not enabled. Enable it in settings.",
  kanbanLoading: "\u{1F4CB} Loading Kanban board...",
  kanbanLoadingEpic: "\u{1F4CB} Loading Kanban board for Epic: {epic}...",
  kanbanLoadingProject: "\u{1F4CB} Loading Kanban board for Project: {project}...",
  kanbanNoProjects: "No projects found in your vault.",
  kanbanNoActiveBoard: "No Kanban board is currently open.",
  kanbanNotABoard: "The current file is not a Kanban board.",
  kanbanRefreshed: "\u2705 Kanban board refreshed",
  kanbanOpenAllTasks: "Open All Tasks Board",
  kanbanOpenEpicBoard: "Open Board for Epic",
  kanbanOpenProjectBoard: "Open Board for Project"
};
var ko = {
  // Common
  cancel: "\uCDE8\uC18C",
  confirm: "\uD655\uC778",
  create: "\uC0DD\uC131",
  save: "\uC800\uC7A5",
  delete: "\uC0AD\uC81C",
  close: "\uB2EB\uAE30",
  loading: "\uB85C\uB529 \uC911...",
  error: "\uC624\uB958",
  success: "\uC131\uACF5",
  retry: "\uC7AC\uC2DC\uB3C4",
  // Task creation
  quickTaskTitle: "\u{1F680} \uBE60\uB978 \uD0DC\uC2A4\uD06C \uC0DD\uC131",
  quickTaskDescription: "\uD0DC\uC2A4\uD06C\uB97C \uC790\uC5F0\uC2A4\uB7FD\uAC8C \uC124\uBA85\uD558\uC138\uC694. GPT\uAC00 \uBAA9\uD45C\uC640 \uD504\uB85C\uC81D\uD2B8\uC5D0 \uB9DE\uAC8C \uAD6C\uC870\uD654\uD569\uB2C8\uB2E4.",
  quickTaskPlaceholder: "\uC608: Freedom Runway \uD504\uB85C\uC81D\uD2B8\uC758 \uB79C\uB529 \uD398\uC774\uC9C0\uB97C \uB192\uC740 \uC6B0\uC120\uC21C\uC704\uB85C \uB9CC\uB4E4\uAE30",
  createWithAi: "\u2728 AI\uB85C \uC0DD\uC131",
  simpleCreate: "\uC0DD\uC131 (AI \uC5C6\uC774)",
  taskCreationCancelled: "\uD0DC\uC2A4\uD06C \uC0DD\uC131\uC774 \uCDE8\uC18C\uB418\uC5C8\uC2B5\uB2C8\uB2E4",
  taskCreated: "\u2705 \uD0DC\uC2A4\uD06C \uC0DD\uC131\uB428: {title}",
  taskCreationFailed: "\uD0DC\uC2A4\uD06C \uC0DD\uC131 \uC2E4\uD328: {error}",
  pleaseEnterDescription: "\uD0DC\uC2A4\uD06C \uC124\uBA85\uC744 \uC785\uB825\uD558\uC138\uC694",
  pleaseSelectText: "\uBA3C\uC800 \uD14D\uC2A4\uD2B8\uB97C \uC120\uD0DD\uD558\uC138\uC694",
  // Voice
  voiceRecording: "\u{1F3A4} \uC74C\uC131 \uB179\uC74C",
  voiceRecordingStart: "\uB179\uC74C \uC2DC\uC791",
  voiceRecordingStop: "\uB179\uC74C \uC911\uC9C0",
  voiceRecordingCancel: "\uCDE8\uC18C",
  voiceTranscribing: "\u{1F3A4} \uBCC0\uD658 \uC911...",
  voiceInstructions: "\uBA85\uD655\uD558\uAC8C \uB9D0\uD558\uACE0 \uD0DC\uC2A4\uD06C\uB97C \uC124\uBA85\uD558\uC138\uC694. \uC6B0\uC120\uC21C\uC704, \uC5D0\uD53D \uB610\uB294 \uD504\uB85C\uC81D\uD2B8 \uC774\uB984\uC744 \uD3EC\uD568\uD558\uC138\uC694.",
  // Review modal
  reviewTask: "\u{1F4CB} \uD0DC\uC2A4\uD06C \uAC80\uD1A0",
  reviewTitle: "\uC81C\uBAA9",
  reviewObjective: "\uBAA9\uD45C",
  reviewImportance: "\uC911\uC694\uD55C \uC774\uC720",
  reviewEpic: "\uC5D0\uD53D",
  reviewPriority: "\uC6B0\uC120\uC21C\uC704",
  reviewSubtasks: "\uC81C\uC548\uB41C \uD558\uC704 \uD0DC\uC2A4\uD06C ({count})",
  noEpic: "-- \uC5D0\uD53D \uC5C6\uC74C --",
  createTask: "\u2713 \uD0DC\uC2A4\uD06C \uC0DD\uC131",
  // Breakdown
  breakdownTitle: "\u{1F4CA} \uD0DC\uC2A4\uD06C \uBD84\uD574: {epic}",
  breakdownDescription: "{count}\uAC1C\uC758 \uD0DC\uC2A4\uD06C\uAC00 \uC0DD\uC131\uB429\uB2C8\uB2E4:",
  breakdownTaskCount: "{count}\uAC1C \uD0DC\uC2A4\uD06C",
  breakdownDependsOn: "\uC758\uC874: \uD0DC\uC2A4\uD06C {index}",
  breakdownCreating: "\u{1F916} \uBD84\uD574 \uC911: {epic}...",
  // Confirmation
  confirmTaskCreation: "\u{1F4CB} \uD0DC\uC2A4\uD06C \uC0DD\uC131 \uD655\uC778 ({count}\uAC1C)",
  confirmTaskCreationSingle: "\u{1F4CB} \uD0DC\uC2A4\uD06C \uC0DD\uC131 \uD655\uC778",
  confirmTasksWillBeCreated: "\uB2E4\uC74C \uD0DC\uC2A4\uD06C\uAC00 \uC0DD\uC131\uB429\uB2C8\uB2E4:",
  confirmTargetFolder: "\u{1F4C1} {folder}",
  confirmCreateTasks: "\u2713 {count}\uAC1C \uD0DC\uC2A4\uD06C \uC0DD\uC131",
  confirmCreateTask: "\u2713 \uD0DC\uC2A4\uD06C \uC0DD\uC131",
  // Errors
  errorNoApiKey: "\uBA3C\uC800 \uC124\uC815\uC5D0\uC11C OpenAI API \uD0A4\uB97C \uC124\uC815\uD558\uC138\uC694.",
  errorVoiceDisabled: "\uC74C\uC131 \uC785\uB825\uC774 \uBE44\uD65C\uC131\uD654\uB418\uC5B4 \uC788\uC2B5\uB2C8\uB2E4. \uC124\uC815\uC5D0\uC11C \uD65C\uC131\uD654\uD558\uC138\uC694.",
  errorNoEpics: "\uBCFC\uD2B8\uC5D0\uC11C \uC5D0\uD53D\uC744 \uCC3E\uC744 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4.",
  errorNoSelection: "\uBA3C\uC800 \uD14D\uC2A4\uD2B8\uB97C \uC120\uD0DD\uD558\uC138\uC694.",
  errorRateLimited: "\uC694\uCCAD \uC81C\uD55C\uB428. {seconds}\uCD08 \uD6C4\uC5D0 \uB2E4\uC2DC \uC2DC\uB3C4\uD558\uC138\uC694.",
  errorTimeout: "\uC694\uCCAD \uC2DC\uAC04 \uCD08\uACFC. \uB2E4\uC2DC \uC2DC\uB3C4\uD558\uC138\uC694.",
  errorServerError: "\uC11C\uBC84 \uC624\uB958. \uB098\uC911\uC5D0 \uB2E4\uC2DC \uC2DC\uB3C4\uD558\uC138\uC694.",
  errorAuthFailed: "\uC778\uC99D \uC2E4\uD328. API \uD0A4\uB97C \uD655\uC778\uD558\uC138\uC694.",
  errorParsingFailed: "GPT \uC751\uB2F5 \uD30C\uC2F1 \uC2E4\uD328. \uAC04\uB2E8\uD55C \uD0DC\uC2A4\uD06C\uB97C \uC0DD\uC131\uD569\uB2C8\uB2E4.",
  errorBreakdownTooLarge: "GPT\uAC00 {count}\uAC1C \uD0DC\uC2A4\uD06C\uB97C \uBC18\uD658\uD588\uC2B5\uB2C8\uB2E4 (\uCD5C\uB300 {max}). \uCC98\uC74C {max}\uAC1C\uB9CC \uC0AC\uC6A9\uD569\uB2C8\uB2E4.",
  errorBreakdownEmpty: "GPT\uAC00 \uD0DC\uC2A4\uD06C\uB97C \uBC18\uD658\uD558\uC9C0 \uC54A\uC558\uC2B5\uB2C8\uB2E4. \uB2E4\uC2DC \uC2DC\uB3C4\uD558\uAC70\uB098 \uC5D0\uD53D \uC124\uBA85\uC744 \uC218\uC815\uD558\uC138\uC694.",
  // Progress
  progressProcessing: "\u{1F916} GPT\uB85C \uCC98\uB9AC \uC911...",
  progressBreakingDown: "\u{1F916} \uC5D0\uD53D \uBD84\uD574 \uC911...",
  progressCreatingTasks: "\uD0DC\uC2A4\uD06C \uC0DD\uC131 \uC911...",
  progressTranscribing: "\u{1F3A4} \uC624\uB514\uC624 \uBCC0\uD658 \uC911...",
  // Settings
  settingsApiConfig: "\u{1F511} API \uC124\uC815",
  settingsVaultPaths: "\u{1F4C1} \uBCFC\uD2B8 \uACBD\uB85C",
  settingsFeatures: "\u26A1 \uAE30\uB2A5",
  settingsDefaults: "\u{1F4CB} \uD0DC\uC2A4\uD06C \uAE30\uBCF8\uAC12",
  settingsPrompts: "\u{1F916} GPT \uD504\uB86C\uD504\uD2B8",
  settingsReset: "\u{1F504} \uCD08\uAE30\uD654",
  // Conflict resolution
  conflictFileExists: "\uD30C\uC77C\uC774 \uC774\uBBF8 \uC874\uC7AC\uD569\uB2C8\uB2E4: {filename}",
  conflictRename: "\uC774\uB984 \uBCC0\uACBD",
  conflictOverwrite: "\uB36E\uC5B4\uC4F0\uAE30",
  conflictSkip: "\uAC74\uB108\uB6F0\uAE30",
  // Accessibility
  ariaCloseModal: "\uBAA8\uB2EC \uB2EB\uAE30",
  ariaConfirmButton: "\uC791\uC5C5 \uD655\uC778",
  ariaCancelButton: "\uC791\uC5C5 \uCDE8\uC18C",
  ariaLoadingIndicator: "\uB85C\uB529 \uC911\uC785\uB2C8\uB2E4. \uC7A0\uC2DC \uAE30\uB2E4\uB824\uC8FC\uC138\uC694",
  ariaTaskList: "\uD0DC\uC2A4\uD06C \uBAA9\uB85D",
  ariaPriorityBadge: "\uC6B0\uC120\uC21C\uC704: {priority}",
  // Kanban Integration
  kanbanNotEnabled: "\uCE78\uBC18 \uD1B5\uD569\uC774 \uD65C\uC131\uD654\uB418\uC9C0 \uC54A\uC558\uC2B5\uB2C8\uB2E4. \uC124\uC815\uC5D0\uC11C \uD65C\uC131\uD654\uD558\uC138\uC694.",
  kanbanLoading: "\u{1F4CB} \uCE78\uBC18 \uBCF4\uB4DC \uB85C\uB529 \uC911...",
  kanbanLoadingEpic: "\u{1F4CB} \uC5D0\uD53D \uCE78\uBC18 \uBCF4\uB4DC \uB85C\uB529 \uC911: {epic}...",
  kanbanLoadingProject: "\u{1F4CB} \uD504\uB85C\uC81D\uD2B8 \uCE78\uBC18 \uBCF4\uB4DC \uB85C\uB529 \uC911: {project}...",
  kanbanNoProjects: "\uBCFC\uD2B8\uC5D0\uC11C \uD504\uB85C\uC81D\uD2B8\uB97C \uCC3E\uC744 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4.",
  kanbanNoActiveBoard: "\uD604\uC7AC \uC5F4\uB824 \uC788\uB294 \uCE78\uBC18 \uBCF4\uB4DC\uAC00 \uC5C6\uC2B5\uB2C8\uB2E4.",
  kanbanNotABoard: "\uD604\uC7AC \uD30C\uC77C\uC740 \uCE78\uBC18 \uBCF4\uB4DC\uAC00 \uC544\uB2D9\uB2C8\uB2E4.",
  kanbanRefreshed: "\u2705 \uCE78\uBC18 \uBCF4\uB4DC\uAC00 \uC0C8\uB85C\uACE0\uCE68\uB418\uC5C8\uC2B5\uB2C8\uB2E4",
  kanbanOpenAllTasks: "\uC804\uCCB4 \uD0DC\uC2A4\uD06C \uBCF4\uB4DC \uC5F4\uAE30",
  kanbanOpenEpicBoard: "\uC5D0\uD53D \uBCF4\uB4DC \uC5F4\uAE30",
  kanbanOpenProjectBoard: "\uD504\uB85C\uC81D\uD2B8 \uBCF4\uB4DC \uC5F4\uAE30"
};
var ja = {
  ...en,
  // Fallback to English for incomplete translations
  cancel: "\u30AD\u30E3\u30F3\u30BB\u30EB",
  confirm: "\u78BA\u8A8D",
  create: "\u4F5C\u6210",
  save: "\u4FDD\u5B58",
  delete: "\u524A\u9664",
  close: "\u9589\u3058\u308B",
  loading: "\u8AAD\u307F\u8FBC\u307F\u4E2D...",
  error: "\u30A8\u30E9\u30FC",
  success: "\u6210\u529F",
  retry: "\u518D\u8A66\u884C",
  quickTaskTitle: "\u{1F680} \u30AF\u30A4\u30C3\u30AF\u30BF\u30B9\u30AF\u4F5C\u6210",
  createWithAi: "\u2728 AI\u3067\u4F5C\u6210",
  taskCreationCancelled: "\u30BF\u30B9\u30AF\u4F5C\u6210\u304C\u30AD\u30E3\u30F3\u30BB\u30EB\u3055\u308C\u307E\u3057\u305F",
  // Kanban
  kanbanNotEnabled: "\u30AB\u30F3\u30D0\u30F3\u7D71\u5408\u304C\u6709\u52B9\u306B\u306A\u3063\u3066\u3044\u307E\u305B\u3093\u3002\u8A2D\u5B9A\u3067\u6709\u52B9\u306B\u3057\u3066\u304F\u3060\u3055\u3044\u3002",
  kanbanLoading: "\u{1F4CB} \u30AB\u30F3\u30D0\u30F3\u30DC\u30FC\u30C9\u3092\u8AAD\u307F\u8FBC\u307F\u4E2D...",
  kanbanRefreshed: "\u2705 \u30AB\u30F3\u30D0\u30F3\u30DC\u30FC\u30C9\u3092\u66F4\u65B0\u3057\u307E\u3057\u305F"
};
var zh = {
  ...en,
  // Fallback to English for incomplete translations
  cancel: "\u53D6\u6D88",
  confirm: "\u786E\u8BA4",
  create: "\u521B\u5EFA",
  save: "\u4FDD\u5B58",
  delete: "\u5220\u9664",
  close: "\u5173\u95ED",
  loading: "\u52A0\u8F7D\u4E2D...",
  error: "\u9519\u8BEF",
  success: "\u6210\u529F",
  retry: "\u91CD\u8BD5",
  quickTaskTitle: "\u{1F680} \u5FEB\u901F\u521B\u5EFA\u4EFB\u52A1",
  createWithAi: "\u2728 AI\u521B\u5EFA",
  taskCreationCancelled: "\u4EFB\u52A1\u521B\u5EFA\u5DF2\u53D6\u6D88",
  // Kanban
  kanbanNotEnabled: "\u770B\u677F\u96C6\u6210\u672A\u542F\u7528\u3002\u8BF7\u5728\u8BBE\u7F6E\u4E2D\u542F\u7528\u3002",
  kanbanLoading: "\u{1F4CB} \u6B63\u5728\u52A0\u8F7D\u770B\u677F...",
  kanbanRefreshed: "\u2705 \u770B\u677F\u5DF2\u5237\u65B0"
};
var translations = {
  en,
  ko,
  ja,
  zh
};
var currentLocale = "en";
function setLocale(locale) {
  if (translations[locale]) {
    currentLocale = locale;
  } else {
    console.warn(`[GPT Task Manager] Unsupported locale: ${locale}, falling back to English`);
    currentLocale = "en";
  }
}
function t(key, params) {
  const strings = translations[currentLocale] || translations.en;
  let text = strings[key] || translations.en[key] || key;
  if (params) {
    for (const [paramKey, value] of Object.entries(params)) {
      text = text.replace(new RegExp(`\\{${paramKey}\\}`, "g"), String(value));
    }
  }
  return text;
}

// src/voice.ts
var CATEGORY3 = "Voice";
var VoiceRecordingModal = class extends import_obsidian3.Modal {
  constructor(app, onComplete, onCancel) {
    super(app);
    this.mediaRecorder = null;
    this.audioChunks = [];
    this.stream = null;
    this.timerInterval = null;
    this.startTime = 0;
    this.timerEl = null;
    this.statusEl = null;
    this.startBtn = null;
    this.stopBtn = null;
    this.recordingDot = null;
    this.onComplete = onComplete;
    this.onCancel = onCancel;
  }
  async onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("gpt-task-manager-recording-modal");
    contentEl.createEl("h3", { text: t("voiceRecording") });
    const indicatorEl = contentEl.createDiv({ cls: "recording-indicator" });
    this.recordingDot = indicatorEl.createDiv({ cls: "recording-dot" });
    this.statusEl = indicatorEl.createSpan({ text: t("voiceRecordingStart") });
    this.timerEl = contentEl.createDiv({ cls: "recording-timer", text: "00:00" });
    const instructionsEl = contentEl.createDiv({ cls: "recording-instructions" });
    instructionsEl.createEl("p", { text: t("voiceInstructions") });
    const examplesList = instructionsEl.createEl("ul");
    examplesList.createEl("li", { text: '"Create login page for the app"' });
    examplesList.createEl("li", { text: '"High priority: Fix payment bug by Friday"' });
    examplesList.createEl("li", { text: '"Add user profile settings to Freedom Runway project"' });
    const buttonsEl = contentEl.createDiv({ cls: "recording-buttons" });
    this.startBtn = buttonsEl.createEl("button", {
      text: "\u{1F399}\uFE0F Start Recording",
      cls: "mod-cta"
    });
    this.startBtn.onclick = () => {
      this.initiateRecording();
    };
    this.stopBtn = buttonsEl.createEl("button", {
      text: "\u23F9\uFE0F Stop & Process",
      cls: "mod-warning"
    });
    this.stopBtn.style.display = "none";
    this.stopBtn.onclick = () => this.stopRecording();
    const cancelBtn = buttonsEl.createEl("button", { text: t("cancel") });
    cancelBtn.onclick = () => this.cancelRecording();
  }
  async initiateRecording() {
    if (this.startBtn)
      this.startBtn.style.display = "none";
    if (this.stopBtn)
      this.stopBtn.style.display = "inline-block";
    if (this.statusEl)
      this.statusEl.textContent = "Recording...";
    if (this.recordingDot)
      this.recordingDot.addClass("active");
    await this.startRecording();
  }
  async startRecording() {
    try {
      this.stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      const mimeType = this.getSupportedMimeType();
      const options = {};
      if (mimeType) {
        options.mimeType = mimeType;
      }
      this.mediaRecorder = new MediaRecorder(this.stream, options);
      this.audioChunks = [];
      this.mediaRecorder.ondataavailable = (event) => {
        if (event.data.size > 0) {
          this.audioChunks.push(event.data);
        }
      };
      this.mediaRecorder.onstop = async () => {
        var _a;
        const mimeType2 = ((_a = this.mediaRecorder) == null ? void 0 : _a.mimeType) || "audio/webm";
        const audioBlob = new Blob(this.audioChunks, { type: mimeType2 });
        this.cleanup();
        try {
          await this.onComplete(audioBlob);
        } catch (error) {
          console.error("[GPT Task Manager] Recording processing failed:", error);
          new import_obsidian3.Notice("Processing failed");
        }
        this.close();
      };
      this.mediaRecorder.onerror = () => {
        console.error("[GPT Task Manager] MediaRecorder error");
        new import_obsidian3.Notice("Recording error occurred");
        this.cancelRecording();
      };
      this.mediaRecorder.start(1e3);
      this.startTime = Date.now();
      this.startTimer();
    } catch (error) {
      console.error("[GPT Task Manager] Failed to start recording:", error);
      new import_obsidian3.Notice("Failed to access microphone. Please check permissions.");
      this.close();
      this.onCancel();
    }
  }
  getSupportedMimeType() {
    const mimeTypes = [
      "audio/mp4",
      "audio/webm;codecs=opus",
      "audio/webm",
      "audio/ogg;codecs=opus",
      "audio/ogg",
      "audio/mpeg"
    ];
    for (const mimeType of mimeTypes) {
      if (MediaRecorder.isTypeSupported(mimeType)) {
        return mimeType;
      }
    }
    return null;
  }
  startTimer() {
    this.timerInterval = window.setInterval(() => {
      const elapsed = Math.floor((Date.now() - this.startTime) / 1e3);
      const minutes = Math.floor(elapsed / 60).toString().padStart(2, "0");
      const seconds = (elapsed % 60).toString().padStart(2, "0");
      if (this.timerEl) {
        this.timerEl.textContent = `${minutes}:${seconds}`;
      }
    }, 1e3);
  }
  stopRecording() {
    if (this.mediaRecorder && this.mediaRecorder.state === "recording") {
      if (this.statusEl)
        this.statusEl.textContent = "Processing...";
      if (this.stopBtn) {
        this.stopBtn.disabled = true;
        this.stopBtn.textContent = "Processing...";
      }
      if (this.recordingDot)
        this.recordingDot.removeClass("active");
      this.mediaRecorder.stop();
    }
  }
  cancelRecording() {
    this.cleanup();
    this.close();
    this.onCancel();
  }
  cleanup() {
    if (this.timerInterval) {
      window.clearInterval(this.timerInterval);
      this.timerInterval = null;
    }
    if (this.stream) {
      this.stream.getTracks().forEach((track) => track.stop());
      this.stream = null;
    }
  }
  onClose() {
    this.cleanup();
    const { contentEl } = this;
    contentEl.empty();
  }
};
async function transcribeAudio(audioBlob, apiKey, model = "whisper-1", language, cancellationToken) {
  var _a;
  logger.info(CATEGORY3, "Starting audio transcription", {
    blobSize: audioBlob.size,
    model,
    language: language || "auto"
  });
  const response = await callWhisperApi(
    audioBlob,
    apiKey,
    model,
    language,
    cancellationToken
  );
  if (response.cancelled) {
    logger.info(CATEGORY3, "Transcription was cancelled");
    throw new Error("Transcription cancelled");
  }
  if (!response.success) {
    logger.error(CATEGORY3, "Transcription failed", { error: response.error });
    throw new Error(response.error || "Transcription failed");
  }
  const text = (_a = response.data) == null ? void 0 : _a.text;
  if (!text) {
    logger.warn(CATEGORY3, "Transcription returned empty text");
    throw new Error("Transcription returned empty result");
  }
  logger.info(CATEGORY3, "Transcription successful", { textLength: text.length });
  return text.trim();
}
function parseVoiceTaskInput(transcription) {
  const result = {
    rawText: transcription,
    taskTitle: "",
    description: "",
    epic: "",
    project: "",
    priority: ""
  };
  const cleanedText = transcription.trim();
  const priorityPatterns = [
    { pattern: /(?:high||urgent|)\s*priority/i, priority: "high" },
    { pattern: /priority[:\s]*(high||urgent|)/i, priority: "high" },
    { pattern: /(?:critical||\s*)/i, priority: "critical" },
    { pattern: /(?:low|)\s*priority/i, priority: "low" },
    { pattern: /priority[:\s]*(low|)/i, priority: "low" }
  ];
  for (const { pattern, priority } of priorityPatterns) {
    if (pattern.test(cleanedText)) {
      result.priority = priority;
      break;
    }
  }
  const projectPatterns = [
    /\b(?:for|in|to)\s+the\s+(.+?)\s+(?:project|)/i,
    /\b(?:for|in|to)\s+(\w+(?:\s+\w+)*?)\s+(?:project|)/i,
    /(?:project|)[:\s]+(.+?)(?:\.|,|$)/i
  ];
  for (const pattern of projectPatterns) {
    const match = cleanedText.match(pattern);
    if (match) {
      result.project = match[1].trim();
      break;
    }
  }
  const epicPatterns = [
    /\b(?:for|in|to)\s+the\s+(.+?)\s+(?:epic|)/i,
    /\b(?:for|in|to)\s+(\w+(?:\s+\w+)*?)\s+(?:epic|)/i,
    /(?:epic|)[:\s]+(.+?)(?:\.|,|$)/i
  ];
  for (const pattern of epicPatterns) {
    const match = cleanedText.match(pattern);
    if (match) {
      result.epic = match[1].trim();
      break;
    }
  }
  let taskText = cleanedText.replace(/(?:high|low|critical||||urgent)\s*priority[:\s]*/gi, "").replace(/priority[:\s]*(?:high|low|critical|medium|||)/gi, "").replace(/(?:for|in|to)\s+(?:the\s+)?.+?\s+(?:project|epic||)/gi, "").replace(/(?:project|epic||)[:\s]+.+?(?:\.|,|$)/gi, "").trim();
  taskText = taskText.replace(/\s+/g, " ").replace(/^[,.\s]+|[,.\s]+$/g, "").trim();
  result.taskTitle = taskText;
  return result;
}

// src/context-loader.ts
var import_obsidian4 = require("obsidian");
function loadGoals(app, goalsFolder) {
  const goals = [];
  const folder = app.vault.getAbstractFileByPath(goalsFolder);
  if (!folder || !(folder instanceof import_obsidian4.TFolder)) {
    return goals;
  }
  for (const child of folder.children) {
    if (child instanceof import_obsidian4.TFile && child.extension === "md") {
      const cache = app.metadataCache.getFileCache(child);
      if (!(cache == null ? void 0 : cache.frontmatter))
        continue;
      const frontmatter = cache.frontmatter;
      const type = extractFrontmatterString(frontmatter.Type);
      if (type.toLowerCase().includes("goal")) {
        goals.push({
          name: child.basename,
          path: child.path,
          area: extractFrontmatterString(frontmatter.Area),
          status: extractFrontmatterString(frontmatter.Status),
          milestones: []
        });
      }
    }
  }
  return goals;
}
function loadProjects(app, projectsFolder) {
  const projects = [];
  const folder = app.vault.getAbstractFileByPath(projectsFolder);
  if (!folder || !(folder instanceof import_obsidian4.TFolder)) {
    return projects;
  }
  const processFolder = (currentFolder) => {
    for (const child of currentFolder.children) {
      if (child instanceof import_obsidian4.TFile && child.extension === "md") {
        const cache = app.metadataCache.getFileCache(child);
        if (!(cache == null ? void 0 : cache.frontmatter))
          continue;
        const frontmatter = cache.frontmatter;
        const type = extractFrontmatterString(frontmatter.Type);
        if (type.toLowerCase().includes("project")) {
          projects.push({
            name: child.basename,
            path: child.path,
            area: extractFrontmatterString(frontmatter.Area),
            goal: extractFrontmatterString(frontmatter.Goal),
            status: extractFrontmatterString(frontmatter.Status)
          });
        }
      } else if (child instanceof import_obsidian4.TFolder) {
        processFolder(child);
      }
    }
  };
  processFolder(folder);
  return projects;
}
function loadEpics(app, epicsFolder) {
  const epics = [];
  const folder = app.vault.getAbstractFileByPath(epicsFolder);
  if (!folder || !(folder instanceof import_obsidian4.TFolder)) {
    return epics;
  }
  for (const child of folder.children) {
    if (child instanceof import_obsidian4.TFile && child.extension === "md") {
      const cache = app.metadataCache.getFileCache(child);
      if (!(cache == null ? void 0 : cache.frontmatter))
        continue;
      const frontmatter = cache.frontmatter;
      const type = extractFrontmatterString(frontmatter.Type);
      if (type.toLowerCase().includes("epic")) {
        epics.push({
          name: child.basename,
          path: child.path,
          area: extractFrontmatterString(frontmatter.Area),
          goal: extractFrontmatterString(frontmatter.Goal),
          project: extractFrontmatterString(frontmatter.Project),
          milestone: extractFrontmatterString(frontmatter.Milestone),
          status: extractFrontmatterString(frontmatter.Status),
          description: extractFrontmatterString(frontmatter.Description)
        });
      }
    }
  }
  return epics;
}
function loadActiveTasks(app, tasksFolder) {
  const tasks = [];
  const folder = app.vault.getAbstractFileByPath(tasksFolder);
  if (!folder || !(folder instanceof import_obsidian4.TFolder)) {
    return tasks;
  }
  const processFolder = (currentFolder) => {
    for (const child of currentFolder.children) {
      if (child instanceof import_obsidian4.TFile && child.extension === "md") {
        const cache = app.metadataCache.getFileCache(child);
        if (!(cache == null ? void 0 : cache.frontmatter))
          continue;
        const frontmatter = cache.frontmatter;
        const type = extractFrontmatterString(frontmatter.Type);
        const status = extractFrontmatterString(frontmatter.Status);
        if (type.toLowerCase().includes("task") && !status.toLowerCase().includes("completed")) {
          tasks.push({
            name: child.basename,
            path: child.path,
            area: extractFrontmatterString(frontmatter.Area),
            goal: extractFrontmatterString(frontmatter.Goal),
            project: extractFrontmatterString(frontmatter.Project),
            epic: extractFrontmatterString(frontmatter.Epic),
            status,
            priority: extractFrontmatterString(frontmatter.Priority),
            due: extractFrontmatterString(frontmatter.Due)
          });
        }
      } else if (child instanceof import_obsidian4.TFolder) {
        processFolder(child);
      }
    }
  };
  processFolder(folder);
  return tasks;
}
function loadUserContext(app, goalsFolder, projectsFolder, epicsFolder, tasksFolder) {
  return {
    goals: loadGoals(app, goalsFolder),
    projects: loadProjects(app, projectsFolder),
    epics: loadEpics(app, epicsFolder),
    activeTasks: loadActiveTasks(app, tasksFolder)
  };
}
function formatContextForPrompt(context) {
  const goals = context.goals.map((goal) => `- ${goal.name} (${goal.status || "active"}) - Area: ${goal.area || "none"}`).join("\n") || "No goals defined";
  const projects = context.projects.map((project) => `- ${project.name} (${project.status || "active"}) - Goal: ${project.goal || "none"}`).join("\n") || "No projects defined";
  const epics = context.epics.map((epic) => `- ${epic.name} (${epic.status || "backlog"}) - Project: ${epic.project || "none"}, Goal: ${epic.goal || "none"}`).join("\n") || "No epics defined";
  const tasks = context.activeTasks.slice(0, 20).map((task) => `- ${task.name} (${task.status || "backlog"}, ${task.priority || "medium"}) - Epic: ${task.epic || "none"}`).join("\n") || "No active tasks";
  return { goals, projects, epics, tasks };
}
function extractFrontmatterString(value) {
  if (!value)
    return "";
  if (typeof value === "string") {
    return value.replace(/\[\[([^\]|]+)(?:\|[^\]]+)?\]\]/g, "$1").trim();
  }
  if (Array.isArray(value)) {
    return value.map((item) => extractFrontmatterString(item)).filter(Boolean).join(", ");
  }
  return String(value);
}
async function getEpicMetadata(app, epicName, epicsFolder) {
  const epicPath = `${epicsFolder}/${epicName}.md`;
  const epicFile = app.vault.getAbstractFileByPath(epicPath);
  if (!epicFile || !(epicFile instanceof import_obsidian4.TFile)) {
    return null;
  }
  const cache = app.metadataCache.getFileCache(epicFile);
  if (!(cache == null ? void 0 : cache.frontmatter)) {
    return null;
  }
  const frontmatter = cache.frontmatter;
  return {
    area: extractFrontmatterString(frontmatter.Area),
    goal: extractFrontmatterString(frontmatter.Goal),
    project: extractFrontmatterString(frontmatter.Project),
    milestone: extractFrontmatterString(frontmatter.Milestone)
  };
}

// src/task-creator.ts
var import_obsidian5 = require("obsidian");
async function ensureFolderExists(app, folderPath) {
  const normalizedPath = (0, import_obsidian5.normalizePath)(folderPath);
  const existingFolder = app.vault.getAbstractFileByPath(normalizedPath);
  if (existingFolder && existingFolder instanceof import_obsidian5.TFolder) {
    return;
  }
  const pathParts = normalizedPath.split("/").filter((part) => part.length > 0);
  const foldersToCreate = [];
  let currentPath = "";
  for (const part of pathParts) {
    currentPath = currentPath ? `${currentPath}/${part}` : part;
    const existing = app.vault.getAbstractFileByPath(currentPath);
    if (!existing) {
      foldersToCreate.push(currentPath);
    } else if (existing instanceof import_obsidian5.TFile) {
      throw new Error(`Cannot create folder "${currentPath}": a file exists at this path`);
    }
  }
  for (const folderToCreate of foldersToCreate) {
    try {
      const recheck = app.vault.getAbstractFileByPath(folderToCreate);
      if (!recheck) {
        await app.vault.createFolder(folderToCreate);
      }
    } catch (error) {
      const afterError = app.vault.getAbstractFileByPath(folderToCreate);
      if (afterError && afterError instanceof import_obsidian5.TFolder) {
        continue;
      }
      const errorMessage = error instanceof Error ? error.message : String(error);
      throw new Error(`Failed to create folder "${folderToCreate}": ${errorMessage}`);
    }
  }
}
function sanitizeFilename(filename, fallbackDefault = "Untitled Task") {
  const sanitized = filename.replace(/[\\/:*?"<>|]/g, "-").replace(/\s+/g, " ").trim().substring(0, 100);
  if (!sanitized || sanitized.length === 0) {
    const rawTrimmed = filename.trim().substring(0, 100);
    if (rawTrimmed && rawTrimmed.length > 0) {
      return rawTrimmed.replace(/[\\/:]/g, "-");
    }
    return fallbackDefault;
  }
  return sanitized;
}
function generateTaskContent(params, settings) {
  const timestamp = /* @__PURE__ */ new Date();
  const createdAt = formatDateTime(timestamp);
  const updatedAt = formatDateTime(timestamp);
  const formatLink = (value) => {
    if (!value)
      return "Empty";
    if (value.startsWith("[[") && value.endsWith("]]")) {
      return `"${value}"`;
    }
    return `"[[${value}]]"`;
  };
  const formatString = (value) => {
    if (!value)
      return "";
    return value.replace(/"/g, '\\"').replace(/\n/g, " ");
  };
  const formatTags = (tags) => {
    const YAML_INDENT = "  ";
    if (!tags || tags.length === 0) {
      return `${YAML_INDENT}- tasks`;
    }
    return tags.map((tag) => `${YAML_INDENT}- ${tag.startsWith("#") ? tag.substring(1) : tag}`).join("\n");
  };
  const frontmatterLines = [
    "---",
    'Type: "[[Tasks]]"',
    `Area: ${formatLink(params.area)}`,
    `Goal: ${formatLink(params.goal)}`,
    `Project: ${formatLink(params.project)}`,
    `Epic: ${formatLink(params.epic)}`,
    `Status: ${params.status || settings.defaultStatus}`,
    `Priority: ${params.priority || settings.defaultPriority}`,
    `Due: ${params.due || ""}`,
    `Created: "${createdAt}"`,
    `Updated: "${updatedAt}"`,
    "tags:",
    formatTags(params.tags),
    "Cover: ",
    `Description: "${formatString(params.objective)}"`,
    "Topics: ",
    `Parent: ${params.parent ? formatLink(params.parent) : "Empty"}`,
    "---"
  ];
  const frontmatter = frontmatterLines.join("\n");
  const body = `
## \u{1F504} Sync
- [ ] ${params.title}

## \u{1F3AF} Objective
> What needs to be accomplished:
- ${params.objective || ""}

> Why it matters:
- ${params.importance || ""}


## \u2699\uFE0F Progress Log

> **Updates / checkpoints:**
> Date - 


## \u{1F9E0} Notes / Insights
>


## \u{1F4A1} Reflection
> What was learned or decided:
- 

> What to improve next time:
- 
  
  

---
### \u{1F517} Related Notes
- 
`;
  return frontmatter + body;
}
function generateTaskFromSuggestion(suggestion, epicMetadata, settings) {
  const params = {
    title: suggestion.title,
    objective: suggestion.objective,
    importance: suggestion.importance,
    area: (epicMetadata == null ? void 0 : epicMetadata.area) || "",
    goal: (epicMetadata == null ? void 0 : epicMetadata.goal) || "",
    project: suggestion.suggestedProject || (epicMetadata == null ? void 0 : epicMetadata.project) || "",
    epic: suggestion.suggestedEpic || "",
    priority: suggestion.priority,
    tags: ["tasks"]
  };
  return generateTaskContent(params, settings);
}
async function createTaskFile(app, content, title, epicName, settings) {
  const sanitizedTitle = sanitizeFilename(title, `Task-${Date.now()}`);
  let taskPath;
  await ensureFolderExists(app, settings.tasksFolder);
  if (epicName) {
    const sanitizedEpicName = sanitizeFilename(epicName, "Untitled Epic");
    const epicFolder = `${settings.tasksFolder}/active epic folder/${sanitizedEpicName}`;
    await ensureFolderExists(app, `${settings.tasksFolder}/active epic folder`);
    await ensureFolderExists(app, epicFolder);
    taskPath = `${epicFolder}/${sanitizedTitle}.md`;
  } else {
    taskPath = `${settings.tasksFolder}/${sanitizedTitle}.md`;
  }
  const normalizedPath = (0, import_obsidian5.normalizePath)(taskPath);
  const existingFile = app.vault.getAbstractFileByPath(normalizedPath);
  if (existingFile instanceof import_obsidian5.TFile) {
    let counter = 1;
    let newPath = taskPath;
    while (app.vault.getAbstractFileByPath(newPath)) {
      newPath = taskPath.replace(".md", ` (${counter}).md`);
      counter++;
    }
    taskPath = newPath;
  }
  const file = await app.vault.create((0, import_obsidian5.normalizePath)(taskPath), content);
  return file;
}
async function createTasksFromBreakdown(app, breakdown, epicName, epicMetadata, settings) {
  const createdFiles = [];
  const indexToFile = /* @__PURE__ */ new Map();
  const forwardDependencies = [];
  await ensureFolderExists(app, settings.tasksFolder);
  if (epicName) {
    const sanitizedEpicName = sanitizeFilename(epicName, "Untitled Epic");
    await ensureFolderExists(app, `${settings.tasksFolder}/active epic folder`);
    await ensureFolderExists(app, `${settings.tasksFolder}/active epic folder/${sanitizedEpicName}`);
  }
  for (let taskIndex = 0; taskIndex < breakdown.tasks.length; taskIndex++) {
    const task = breakdown.tasks[taskIndex];
    let parentBasename = void 0;
    if (task.dependsOn !== null && task.dependsOn !== void 0) {
      const dependsOnIndex = task.dependsOn;
      if (dependsOnIndex >= 0 && dependsOnIndex < breakdown.tasks.length) {
        if (dependsOnIndex < taskIndex) {
          const dependsOnFile = indexToFile.get(dependsOnIndex);
          if (dependsOnFile) {
            parentBasename = dependsOnFile.basename;
          }
        } else if (dependsOnIndex > taskIndex) {
          forwardDependencies.push({ taskIndex, dependsOnIndex });
        }
      }
    }
    const params = {
      title: task.title,
      objective: task.objective,
      area: (epicMetadata == null ? void 0 : epicMetadata.area) || "",
      goal: (epicMetadata == null ? void 0 : epicMetadata.goal) || "",
      project: (epicMetadata == null ? void 0 : epicMetadata.project) || "",
      epic: epicName,
      priority: task.priority,
      parent: parentBasename,
      tags: ["tasks"]
    };
    const content = generateTaskContent(params, settings);
    try {
      const file = await createTaskFile(app, content, task.title, epicName, settings);
      createdFiles.push(file);
      indexToFile.set(taskIndex, file);
    } catch (error) {
      console.error(`[GPT Task Manager] Failed to create task: ${task.title}`, error);
      new import_obsidian5.Notice(`Failed to create task: ${task.title}`);
    }
  }
  for (const { taskIndex, dependsOnIndex } of forwardDependencies) {
    const file = indexToFile.get(taskIndex);
    const dependsOnFile = indexToFile.get(dependsOnIndex);
    if (file && dependsOnFile) {
      try {
        await updateTaskParent(app, file, dependsOnFile.basename);
      } catch (error) {
        console.error(`[GPT Task Manager] Failed to update dependency for: ${file.basename}`, error);
      }
    }
  }
  return createdFiles;
}
async function updateTaskParent(app, file, parentBasename) {
  const content = await app.vault.read(file);
  const frontmatterMatch = content.match(/^---\n([\s\S]*?)\n---/);
  if (!frontmatterMatch) {
    return;
  }
  const frontmatter = frontmatterMatch[1];
  const parentPattern = /^Parent:\s*.*/m;
  if (parentPattern.test(frontmatter)) {
    const newFrontmatter = frontmatter.replace(
      parentPattern,
      `Parent: "[[${parentBasename}]]"`
    );
    const newContent = content.replace(
      /^---\n[\s\S]*?\n---/,
      `---
${newFrontmatter}
---`
    );
    await app.vault.modify(file, newContent);
  }
}
function buildBreakdownSummaries(breakdown, epicName, settings) {
  const summaries = [];
  const sanitizedEpicName = sanitizeFilename(epicName, "Untitled Epic");
  const targetFolder = `${settings.tasksFolder}/active epic folder/${sanitizedEpicName}`;
  const indexToTitle = /* @__PURE__ */ new Map();
  breakdown.tasks.forEach((task, index) => {
    indexToTitle.set(index, task.title);
  });
  for (let taskIndex = 0; taskIndex < breakdown.tasks.length; taskIndex++) {
    const task = breakdown.tasks[taskIndex];
    let dependsOnTask = null;
    if (task.dependsOn !== null && task.dependsOn !== void 0) {
      const dependsOnIndex = task.dependsOn;
      if (dependsOnIndex >= 0 && dependsOnIndex < breakdown.tasks.length && indexToTitle.has(dependsOnIndex)) {
        dependsOnTask = indexToTitle.get(dependsOnIndex) || null;
      }
    }
    summaries.push({
      title: task.title,
      targetFolder,
      epic: epicName,
      priority: task.priority || settings.defaultPriority,
      dependsOnTask
    });
  }
  return summaries;
}
function buildSuggestionSummary(suggestion, epicName, settings) {
  let targetFolder;
  if (epicName) {
    const sanitizedEpicName = sanitizeFilename(epicName, "Untitled Epic");
    targetFolder = `${settings.tasksFolder}/active epic folder/${sanitizedEpicName}`;
  } else {
    targetFolder = settings.tasksFolder;
  }
  return {
    title: suggestion.title,
    targetFolder,
    epic: epicName,
    priority: suggestion.priority || settings.defaultPriority,
    dependsOnTask: null
  };
}
function formatDateTime(date) {
  const year = date.getFullYear();
  const month = String(date.getMonth() + 1).padStart(2, "0");
  const day = String(date.getDate()).padStart(2, "0");
  const hours = String(date.getHours()).padStart(2, "0");
  const minutes = String(date.getMinutes()).padStart(2, "0");
  return `${year}-${month}-${day} ${hours}:${minutes}`;
}
var TaskConfirmationModal = class extends import_obsidian5.Modal {
  constructor(app, summaries, operationType, epicName, onConfirm, onCancel) {
    super(app);
    this.resolved = false;
    this.summaries = summaries;
    this.operationType = operationType;
    this.epicName = epicName;
    this.onConfirm = onConfirm;
    this.onCancel = onCancel;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("gpt-task-manager-confirmation-modal");
    const headerText = this.operationType === "breakdown" ? `\u{1F4CB} Confirm Task Creation (${this.summaries.length} tasks)` : "\u{1F4CB} Confirm Task Creation";
    contentEl.createEl("h2", { text: headerText });
    const descText = this.operationType === "breakdown" ? "The following tasks will be created:" : "The following task will be created:";
    contentEl.createEl("p", { text: descText, cls: "modal-description" });
    const listEl = contentEl.createDiv({ cls: "confirmation-task-list" });
    for (let summaryIndex = 0; summaryIndex < this.summaries.length; summaryIndex++) {
      const summary = this.summaries[summaryIndex];
      const itemEl = listEl.createDiv({ cls: "confirmation-task-item" });
      const titleRow = itemEl.createDiv({ cls: "task-title-row" });
      if (this.operationType === "breakdown") {
        titleRow.createEl("span", {
          text: `${summaryIndex + 1}. `,
          cls: "task-number"
        });
      }
      titleRow.createEl("span", { text: summary.title, cls: "task-title" });
      const detailsEl = itemEl.createDiv({ cls: "task-details" });
      detailsEl.createEl("span", {
        text: summary.priority,
        cls: `priority-badge priority-${summary.priority}`
      });
      if (summary.epic) {
        detailsEl.createEl("span", {
          text: `Epic: ${summary.epic}`,
          cls: "task-epic"
        });
      }
      if (summary.dependsOnTask) {
        detailsEl.createEl("span", {
          text: `\u2192 Depends on: ${summary.dependsOnTask}`,
          cls: "task-dependency"
        });
      }
      const folderEl = itemEl.createDiv({ cls: "task-folder" });
      folderEl.createEl("span", {
        text: `\u{1F4C1} ${summary.targetFolder}`,
        cls: "folder-path"
      });
    }
    const buttonsEl = contentEl.createDiv({ cls: "modal-button-container" });
    const cancelBtn = buttonsEl.createEl("button", { text: "Cancel" });
    cancelBtn.onclick = () => {
      this.resolved = true;
      this.close();
      this.onCancel();
    };
    const confirmText = this.operationType === "breakdown" ? `\u2713 Create ${this.summaries.length} Tasks` : "\u2713 Create Task";
    const confirmBtn = buttonsEl.createEl("button", {
      text: confirmText,
      cls: "mod-cta"
    });
    confirmBtn.onclick = () => {
      this.resolved = true;
      this.close();
      this.onConfirm();
    };
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
    if (!this.resolved) {
      this.resolved = true;
      this.onCancel();
    }
  }
};
function showTaskConfirmation(app, summaries, operationType, epicName) {
  return new Promise((resolve) => {
    new TaskConfirmationModal(
      app,
      summaries,
      operationType,
      epicName,
      () => resolve(true),
      () => resolve(false)
    ).open();
  });
}

// src/cache.ts
var import_obsidian6 = require("obsidian");
var CATEGORY4 = "Cache";
var DEFAULT_CONFIG = {
  ttlMs: 6e4,
  // 1 minute
  maxEntries: 50,
  debounceMs: 500
};
var Cache = class {
  constructor(config = {}) {
    this.entries = /* @__PURE__ */ new Map();
    this.accessOrder = [];
    this.globalVersion = 0;
    this.config = { ...DEFAULT_CONFIG, ...config };
  }
  /**
   * Get a cached value
   */
  get(key) {
    const entry = this.entries.get(key);
    if (!entry) {
      return null;
    }
    if (Date.now() - entry.timestamp > this.config.ttlMs) {
      this.entries.delete(key);
      this.removeFromAccessOrder(key);
      logger.debug(CATEGORY4, `Cache expired: ${key}`);
      return null;
    }
    if (entry.version !== this.globalVersion) {
      this.entries.delete(key);
      this.removeFromAccessOrder(key);
      logger.debug(CATEGORY4, `Cache invalidated (version mismatch): ${key}`);
      return null;
    }
    this.removeFromAccessOrder(key);
    this.accessOrder.push(key);
    logger.debug(CATEGORY4, `Cache hit: ${key}`);
    return entry.data;
  }
  /**
   * Set a cached value
   */
  set(key, data) {
    while (this.entries.size >= this.config.maxEntries && this.accessOrder.length > 0) {
      const oldestKey = this.accessOrder.shift();
      if (oldestKey) {
        this.entries.delete(oldestKey);
        logger.debug(CATEGORY4, `Cache evicted (LRU): ${oldestKey}`);
      }
    }
    this.entries.set(key, {
      data,
      timestamp: Date.now(),
      version: this.globalVersion
    });
    this.removeFromAccessOrder(key);
    this.accessOrder.push(key);
    logger.debug(CATEGORY4, `Cache set: ${key}`);
  }
  /**
   * Check if key exists and is valid
   */
  has(key) {
    return this.get(key) !== null;
  }
  /**
   * Delete a specific key
   */
  delete(key) {
    this.entries.delete(key);
    this.removeFromAccessOrder(key);
  }
  /**
   * Invalidate all entries (cheap operation - just bump version)
   */
  invalidateAll() {
    this.globalVersion++;
    logger.debug(CATEGORY4, `Cache invalidated all (version: ${this.globalVersion})`);
  }
  /**
   * Clear all entries
   */
  clear() {
    this.entries.clear();
    this.accessOrder = [];
    this.globalVersion++;
    logger.debug(CATEGORY4, "Cache cleared");
  }
  /**
   * Get cache statistics
   */
  getStats() {
    return {
      size: this.entries.size,
      maxSize: this.config.maxEntries,
      version: this.globalVersion
    };
  }
  removeFromAccessOrder(key) {
    const index = this.accessOrder.indexOf(key);
    if (index !== -1) {
      this.accessOrder.splice(index, 1);
    }
  }
};
var ContextCache = class {
  constructor(app, config = {}) {
    this.invalidationTimeout = null;
    this.registeredEvents = [];
    this.app = app;
    this.debounceMs = config.debounceMs || DEFAULT_CONFIG.debounceMs;
    this.goalsCache = new Cache(config);
    this.projectsCache = new Cache(config);
    this.epicsCache = new Cache(config);
    this.tasksCache = new Cache(config);
    this.metadataCache = new Cache(config);
    this.userContextCache = new Cache(config);
    this.setupEventListeners();
  }
  /**
   * Setup event listeners for automatic invalidation
   */
  setupEventListeners() {
    const modifyRef = this.app.vault.on("modify", (file) => {
      if (file instanceof import_obsidian6.TFile && file.extension === "md") {
        this.debouncedInvalidate();
      }
    });
    const createRef = this.app.vault.on("create", (file) => {
      if (file instanceof import_obsidian6.TFile && file.extension === "md") {
        this.debouncedInvalidate();
      }
    });
    const deleteRef = this.app.vault.on("delete", (file) => {
      if (file instanceof import_obsidian6.TFile && file.extension === "md") {
        this.debouncedInvalidate();
      }
    });
    const renameRef = this.app.vault.on("rename", (file) => {
      if (file instanceof import_obsidian6.TFile && file.extension === "md") {
        this.debouncedInvalidate();
      }
    });
    this.registeredEvents.push(
      () => this.app.vault.offref(modifyRef),
      () => this.app.vault.offref(createRef),
      () => this.app.vault.offref(deleteRef),
      () => this.app.vault.offref(renameRef)
    );
    logger.info(CATEGORY4, "Cache event listeners registered");
  }
  /**
   * Debounced invalidation to prevent excessive cache clears
   */
  debouncedInvalidate() {
    if (this.invalidationTimeout) {
      clearTimeout(this.invalidationTimeout);
    }
    this.invalidationTimeout = setTimeout(() => {
      this.invalidateAll();
      this.invalidationTimeout = null;
    }, this.debounceMs);
  }
  /**
   * Get cached full UserContext or load it atomically.
   * This is the preferred method  it loads all context arrays in one call
   * ensuring a consistent snapshot and avoiding redundant vault scans.
   */
  getUserContext(key, loader) {
    const cached = this.userContextCache.get(key);
    if (cached !== null) {
      return cached;
    }
    const data = loader();
    this.userContextCache.set(key, data);
    return data;
  }
  /**
   * Get cached goals or load them
   * @deprecated Prefer getUserContext() for consistent snapshots
   */
  getGoals(key, loader) {
    const cached = this.goalsCache.get(key);
    if (cached !== null) {
      return cached;
    }
    const data = loader();
    this.goalsCache.set(key, data);
    return data;
  }
  /**
   * Get cached projects or load them
   * @deprecated Prefer getUserContext() for consistent snapshots
   */
  getProjects(key, loader) {
    const cached = this.projectsCache.get(key);
    if (cached !== null) {
      return cached;
    }
    const data = loader();
    this.projectsCache.set(key, data);
    return data;
  }
  /**
   * Get cached epics or load them
   * @deprecated Prefer getUserContext() for consistent snapshots
   */
  getEpics(key, loader) {
    const cached = this.epicsCache.get(key);
    if (cached !== null) {
      return cached;
    }
    const data = loader();
    this.epicsCache.set(key, data);
    return data;
  }
  /**
   * Get cached tasks or load them
   * @deprecated Prefer getUserContext() for consistent snapshots
   */
  getTasks(key, loader) {
    const cached = this.tasksCache.get(key);
    if (cached !== null) {
      return cached;
    }
    const data = loader();
    this.tasksCache.set(key, data);
    return data;
  }
  /**
   * Get cached metadata or load it
   */
  getMetadata(key, loader) {
    const cached = this.metadataCache.get(key);
    if (cached !== null) {
      return cached;
    }
    const data = loader();
    this.metadataCache.set(key, data);
    return data;
  }
  /**
   * Invalidate all caches
   */
  invalidateAll() {
    this.goalsCache.invalidateAll();
    this.projectsCache.invalidateAll();
    this.epicsCache.invalidateAll();
    this.tasksCache.invalidateAll();
    this.metadataCache.invalidateAll();
    this.userContextCache.invalidateAll();
    logger.info(CATEGORY4, "All caches invalidated");
  }
  /**
   * Clear all caches
   */
  clear() {
    this.goalsCache.clear();
    this.projectsCache.clear();
    this.epicsCache.clear();
    this.tasksCache.clear();
    this.metadataCache.clear();
    this.userContextCache.clear();
    logger.info(CATEGORY4, "All caches cleared");
  }
  /**
   * Get cache statistics
   */
  getStats() {
    return {
      goals: this.goalsCache.getStats(),
      projects: this.projectsCache.getStats(),
      epics: this.epicsCache.getStats(),
      tasks: this.tasksCache.getStats(),
      metadata: this.metadataCache.getStats(),
      userContext: this.userContextCache.getStats()
    };
  }
  /**
   * Cleanup event listeners
   */
  destroy() {
    for (const cleanup of this.registeredEvents) {
      cleanup();
    }
    this.registeredEvents = [];
    if (this.invalidationTimeout) {
      clearTimeout(this.invalidationTimeout);
      this.invalidationTimeout = null;
    }
    this.clear();
    logger.info(CATEGORY4, "Cache destroyed");
  }
};

// src/ui-components.ts
var import_obsidian7 = require("obsidian");
var EnhancedModal = class extends import_obsidian7.Modal {
  constructor(app) {
    super(app);
    this.loadingState = {
      isLoading: false,
      message: "",
      canCancel: false
    };
    this.cancellationToken = null;
    this.loadingOverlay = null;
  }
  /**
   * Show loading overlay with optional cancel button
   */
  showLoading(message, canCancel = true) {
    this.loadingState = {
      isLoading: true,
      message,
      canCancel
    };
    this.cancellationToken = new CancellationToken();
    if (!this.loadingOverlay) {
      this.loadingOverlay = this.contentEl.createDiv({ cls: "loading-overlay" });
    }
    this.loadingOverlay.empty();
    this.loadingOverlay.style.display = "flex";
    const spinner = this.loadingOverlay.createDiv({ cls: "loading-spinner" });
    spinner.setAttribute("role", "status");
    spinner.setAttribute("aria-label", t("ariaLoadingIndicator"));
    const messageEl = this.loadingOverlay.createEl("p", {
      text: message,
      cls: "loading-message"
    });
    messageEl.setAttribute("aria-live", "polite");
    if (canCancel) {
      const cancelBtn = this.loadingOverlay.createEl("button", {
        text: t("cancel"),
        cls: "loading-cancel-btn"
      });
      cancelBtn.setAttribute("aria-label", t("ariaCancelButton"));
      cancelBtn.onclick = () => {
        this.cancelOperation();
      };
    }
    return this.cancellationToken;
  }
  /**
   * Hide loading overlay
   */
  hideLoading() {
    this.loadingState.isLoading = false;
    if (this.loadingOverlay) {
      this.loadingOverlay.style.display = "none";
    }
  }
  /**
   * Update loading message
   */
  updateLoadingMessage(message) {
    if (this.loadingOverlay) {
      const messageEl = this.loadingOverlay.querySelector(".loading-message");
      if (messageEl) {
        messageEl.textContent = message;
      }
    }
  }
  /**
   * Cancel the current operation
   */
  cancelOperation() {
    if (this.cancellationToken) {
      this.cancellationToken.cancel(t("taskCreationCancelled"));
    }
    this.hideLoading();
  }
  /**
   * Add ARIA attributes to modal
   */
  setupAccessibility(title) {
    this.modalEl.setAttribute("role", "dialog");
    this.modalEl.setAttribute("aria-modal", "true");
    this.modalEl.setAttribute("aria-labelledby", "modal-title");
    const titleEl = this.contentEl.querySelector("h2");
    if (titleEl) {
      titleEl.id = "modal-title";
    }
  }
  /**
   * Create accessible button
   */
  createAccessibleButton(parent, text, ariaLabel, onClick, classes) {
    const btn = parent.createEl("button", { text, cls: classes });
    btn.setAttribute("aria-label", ariaLabel);
    btn.onclick = onClick;
    return btn;
  }
  onClose() {
    if (this.cancellationToken && !this.cancellationToken.isCancelled) {
      this.cancellationToken.cancel("Modal closed");
    }
    super.onClose();
  }
};
var BatchConfirmationModal = class extends EnhancedModal {
  constructor(app, items, epicName) {
    super(app);
    this.epicName = epicName;
    this.onConfirm = null;
    this.items = items.map((item) => ({
      title: item.title,
      selected: true,
      deferred: false
    }));
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("gpt-task-manager-batch-modal");
    const titleText = `\u{1F4CB} ${t("confirmTaskCreation", { count: this.items.length })}`;
    contentEl.createEl("h2", { text: titleText });
    contentEl.createEl("p", {
      text: "Select tasks to create now. Unselected tasks can be deferred for later.",
      cls: "modal-description"
    });
    const listEl = contentEl.createDiv({ cls: "batch-task-list" });
    listEl.setAttribute("role", "list");
    listEl.setAttribute("aria-label", t("ariaTaskList"));
    this.items.forEach((item, index) => {
      const itemEl = listEl.createDiv({ cls: "batch-task-item" });
      itemEl.setAttribute("role", "listitem");
      const checkbox = itemEl.createEl("input", { type: "checkbox" });
      checkbox.checked = item.selected;
      checkbox.id = `task-${index}`;
      checkbox.setAttribute("aria-label", `Select ${item.title}`);
      checkbox.onchange = () => {
        item.selected = checkbox.checked;
        this.updateCounts();
      };
      const label = itemEl.createEl("label");
      label.htmlFor = `task-${index}`;
      label.textContent = item.title;
      const deferContainer = itemEl.createDiv({ cls: "defer-container" });
      const deferCheckbox = deferContainer.createEl("input", { type: "checkbox" });
      deferCheckbox.id = `defer-${index}`;
      deferCheckbox.checked = item.deferred;
      deferCheckbox.setAttribute("aria-label", `Defer ${item.title}`);
      deferCheckbox.onchange = () => {
        item.deferred = deferCheckbox.checked;
        if (item.deferred) {
          item.selected = false;
          checkbox.checked = false;
        }
        this.updateCounts();
      };
      deferContainer.createEl("label", { text: "Defer" }).htmlFor = `defer-${index}`;
    });
    const summaryEl = contentEl.createDiv({ cls: "batch-summary" });
    summaryEl.id = "batch-summary";
    const buttonsEl = contentEl.createDiv({ cls: "modal-button-container" });
    const selectAllBtn = this.createAccessibleButton(
      buttonsEl,
      "Select All",
      "Select all tasks",
      () => this.selectAll(true)
    );
    const selectNoneBtn = this.createAccessibleButton(
      buttonsEl,
      "Select None",
      "Deselect all tasks",
      () => this.selectAll(false)
    );
    this.createAccessibleButton(
      buttonsEl,
      t("cancel"),
      t("ariaCancelButton"),
      () => this.close()
    );
    this.createAccessibleButton(
      buttonsEl,
      t("confirmCreateTask"),
      t("ariaConfirmButton"),
      () => this.confirm(),
      "mod-cta"
    );
    this.updateCounts();
    this.setupAccessibility(titleText);
  }
  updateCounts() {
    const selected = this.items.filter((item) => item.selected).length;
    const deferred = this.items.filter((item) => item.deferred).length;
    const summary = this.contentEl.querySelector("#batch-summary");
    if (summary) {
      summary.textContent = `${selected} to create now, ${deferred} deferred`;
    }
  }
  selectAll(selected) {
    this.items.forEach((item) => {
      item.selected = selected;
      item.deferred = !selected;
    });
    const checkboxes = this.contentEl.querySelectorAll('input[type="checkbox"]');
    checkboxes.forEach((checkbox, index) => {
      const el = checkbox;
      if (el.id.startsWith("task-")) {
        el.checked = selected;
      } else if (el.id.startsWith("defer-")) {
        el.checked = !selected;
      }
    });
    this.updateCounts();
  }
  confirm() {
    if (this.onConfirm) {
      this.onConfirm(this.items);
    }
    this.close();
  }
  /**
   * Show modal and wait for confirmation
   */
  async waitForConfirmation() {
    return new Promise((resolve) => {
      this.onConfirm = resolve;
      this.open();
    });
  }
  onClose() {
    if (this.onConfirm) {
      this.onConfirm(this.items.filter((item) => item.selected && !item.deferred));
    }
    super.onClose();
  }
};
function showNotice(message, duration = 4e3) {
  new import_obsidian7.Notice(message, duration);
}
function showErrorNotice(error, recovery) {
  const message = recovery ? `${error}
${recovery}` : error;
  new import_obsidian7.Notice(message, 6e3);
}
function showSuccessNotice(message) {
  new import_obsidian7.Notice(`\u2705 ${message}`, 3e3);
}

// src/kanban-integration.ts
var import_obsidian8 = require("obsidian");
var KanbanIntegrationService = class {
  constructor(app, settings) {
    this.app = app;
    this.settings = settings;
  }
  /**
   * Update settings reference
   */
  updateSettings(settings) {
    this.settings = settings;
  }
  /**
   * Check if obsidian-base-kanban plugin is available
   */
  isKanbanPluginAvailable() {
    var _a, _b;
    const kanbanPlugin = (_b = (_a = this.app.plugins) == null ? void 0 : _a.plugins) == null ? void 0 : _b["obsidian-base-kanban"];
    return !!kanbanPlugin;
  }
  /**
   * Parse frontmatter from a task file
   */
  parseTaskFrontmatter(content) {
    const metadata = {};
    const frontmatterMatch = content.match(/^---\s*\n([\s\S]*?)\n---/);
    if (!frontmatterMatch) {
      return metadata;
    }
    const frontmatter = frontmatterMatch[1];
    const lines = frontmatter.split("\n");
    for (const line of lines) {
      const kvMatch = line.match(/^(\w+):\s*(.+)$/);
      if (kvMatch) {
        const key = kvMatch[1];
        let value = kvMatch[2].trim();
        value = value.replace(/^["']|["']$/g, "");
        value = value.replace(/^\[\[|\]\]$/g, "");
        switch (key.toLowerCase()) {
          case "type":
            metadata.type = value;
            break;
          case "area":
            metadata.area = value;
            break;
          case "goal":
            metadata.goal = value;
            break;
          case "project":
            metadata.project = value;
            break;
          case "epic":
            metadata.epic = value;
            break;
          case "status":
            metadata.status = value;
            break;
          case "priority":
            metadata.priority = value;
            break;
          case "due":
            metadata.due = value;
            break;
          case "created":
            metadata.created = value;
            break;
          case "updated":
            metadata.updated = value;
            break;
          case "parent":
            metadata.parent = value;
            break;
          case "description":
            metadata.description = value;
            break;
          case "tags":
            if (value.startsWith("[")) {
              metadata.tags = value.replace(/[\[\]]/g, "").split(",").map((t2) => t2.trim());
            }
            break;
        }
      }
      if (line.trim().startsWith("- ") && metadata.tags === void 0) {
        const tagValue = line.trim().replace(/^-\s*/, "");
        if (!metadata.tags) {
          metadata.tags = [];
        }
        metadata.tags.push(tagValue);
      }
    }
    return metadata;
  }
  /**
   * Extract sync checklist item from task content
   */
  extractSyncChecklistItem(content) {
    const syncSectionMatch = content.match(/##  Sync\s*\n([\s\S]*?)(?=\n## |$)/);
    if (!syncSectionMatch) {
      return null;
    }
    const syncSection = syncSectionMatch[1];
    const checkboxMatch = syncSection.match(/-\s*\[([ xX])\]\s*(.+)/);
    if (!checkboxMatch) {
      return null;
    }
    return {
      completed: checkboxMatch[1].toLowerCase() === "x",
      text: checkboxMatch[2].trim()
    };
  }
  /**
   * Parse a single task file
   */
  async parseTaskFile(file) {
    try {
      const content = await this.app.vault.read(file);
      const metadata = this.parseTaskFrontmatter(content);
      if (!metadata.type || !metadata.type.includes("Tasks")) {
        return null;
      }
      const syncItem = this.extractSyncChecklistItem(content);
      const title = (syncItem == null ? void 0 : syncItem.text) || file.basename;
      return {
        file,
        title,
        metadata,
        syncChecklistItem: syncItem == null ? void 0 : syncItem.text,
        completed: (syncItem == null ? void 0 : syncItem.completed) || false,
        content
      };
    } catch (error) {
      console.error(`Failed to parse task file: ${file.path}`, error);
      return null;
    }
  }
  /**
   * Query all tasks from the tasks folder
   */
  async queryTasks(filter) {
    const tasks = [];
    const folder = this.app.vault.getAbstractFileByPath(this.settings.tasksFolder);
    if (!(folder instanceof import_obsidian8.TFolder)) {
      console.warn(`Tasks folder not found: ${this.settings.tasksFolder}`);
      return tasks;
    }
    const getAllMarkdownFiles = (folder2) => {
      const files2 = [];
      for (const child of folder2.children) {
        if (child instanceof import_obsidian8.TFile && child.extension === "md") {
          files2.push(child);
        } else if (child instanceof import_obsidian8.TFolder) {
          files2.push(...getAllMarkdownFiles(child));
        }
      }
      return files2;
    };
    const files = getAllMarkdownFiles(folder);
    for (const file of files) {
      const task = await this.parseTaskFile(file);
      if (!task)
        continue;
      if (filter) {
        if (filter.epic && task.metadata.epic !== filter.epic) {
          continue;
        }
        if (filter.project && task.metadata.project !== filter.project) {
          continue;
        }
        if (filter.status && filter.status.length > 0 && task.metadata.status) {
          if (!filter.status.includes(task.metadata.status)) {
            continue;
          }
        }
        if (!filter.includeCompleted && task.completed) {
          continue;
        }
      }
      tasks.push(task);
    }
    return tasks;
  }
  /**
   * Convert task status to lane title
   */
  statusToLane(status) {
    if (!status)
      return this.settings.kanbanStatusMapping.backlog;
    const statusLower = status.toLowerCase();
    if (statusLower === "backlog")
      return this.settings.kanbanStatusMapping.backlog;
    if (statusLower === "todo")
      return this.settings.kanbanStatusMapping.todo;
    if (statusLower === "in-progress" || statusLower === "inprogress") {
      return this.settings.kanbanStatusMapping.inProgress;
    }
    if (statusLower === "done" || statusLower === "completed") {
      return this.settings.kanbanStatusMapping.done;
    }
    return this.settings.kanbanStatusMapping.backlog;
  }
  /**
   * Convert lane title to task status
   */
  laneToStatus(laneTitle) {
    const laneLower = laneTitle.toLowerCase();
    const mapping = this.settings.kanbanStatusMapping;
    if (laneLower === mapping.backlog.toLowerCase() || laneLower.includes("backlog")) {
      return "backlog";
    }
    if (laneLower === mapping.todo.toLowerCase() || laneLower.includes("todo")) {
      return "todo";
    }
    if (laneLower === mapping.inProgress.toLowerCase() || laneLower.includes("progress")) {
      return "in-progress";
    }
    if (laneLower === mapping.done.toLowerCase() || laneLower.includes("done")) {
      return "done";
    }
    return "backlog";
  }
  /**
   * Generate a unique ID
   */
  generateId() {
    return Math.random().toString(36).substring(2, 11) + Date.now().toString(36).slice(-4);
  }
  /**
   * Convert a GptTask to a KanbanCard
   */
  taskToCard(task) {
    return {
      id: this.generateId(),
      title: task.title,
      completed: task.completed,
      tags: task.metadata.tags || [],
      dueDate: task.metadata.due,
      metadata: {
        project: task.metadata.project,
        priority: task.metadata.priority,
        status: task.metadata.status
      },
      baseTaskPath: task.file.path,
      baseSyncTime: Date.now()
    };
  }
  /**
   * Create a Kanban board from tasks
   */
  createBoardFromTasks(tasks, boardTitle) {
    const mapping = this.settings.kanbanStatusMapping;
    const lanes = [
      { id: this.generateId(), title: mapping.backlog, cards: [] },
      { id: this.generateId(), title: mapping.todo, cards: [] },
      { id: this.generateId(), title: mapping.inProgress, cards: [] },
      { id: this.generateId(), title: mapping.done, cards: [] }
    ];
    for (const task of tasks) {
      const card = this.taskToCard(task);
      const laneTitle = this.statusToLane(task.metadata.status);
      const lane = lanes.find((l) => l.title === laneTitle);
      if (lane) {
        lane.cards.push(card);
      } else {
        lanes[0].cards.push(card);
      }
    }
    const priorityOrder = {
      critical: 0,
      high: 1,
      medium: 2,
      low: 3
    };
    for (const lane of lanes) {
      lane.cards.sort((a, b) => {
        var _a, _b;
        const aPriority = (_a = priorityOrder[a.metadata.priority || "medium"]) != null ? _a : 2;
        const bPriority = (_b = priorityOrder[b.metadata.priority || "medium"]) != null ? _b : 2;
        return aPriority - bPriority;
      });
    }
    return {
      lanes,
      archive: [],
      settings: {
        "lane-width": "300px",
        "show-checkboxes": true,
        "show-progress": true,
        "show-project": true,
        "base-sync": {
          enabled: true,
          tasksFolder: this.settings.tasksFolder,
          query: "",
          statusField: "Status",
          progressField: "progress",
          projectField: "Project",
          laneMapping: {
            [mapping.backlog]: "backlog",
            [mapping.todo]: "todo",
            [mapping.inProgress]: "in-progress",
            [mapping.done]: "done"
          },
          conflictResolution: "prompt",
          syncInterval: 0,
          createMissingTasks: false,
          archiveCompletedTasks: false
        },
        "gpt-task-manager": {
          enabled: true,
          tasksFolder: this.settings.tasksFolder,
          epicsFolder: this.settings.epicsFolder,
          projectsFolder: this.settings.projectsFolder,
          goalsFolder: this.settings.goalsFolder
        }
      },
      _frontmatter: `---
kanban-plugin: basic
title: ${boardTitle || "Task Board"}
gpt-task-manager: true
---

`
    };
  }
  /**
   * Serialize a Kanban board to markdown format
   */
  serializeBoard(board) {
    const lines = [];
    if (board._frontmatter) {
      lines.push(board._frontmatter);
    } else {
      lines.push("---");
      lines.push("kanban-plugin: basic");
      lines.push("gpt-task-manager: true");
      lines.push("---");
      lines.push("");
    }
    for (const lane of board.lanes) {
      lines.push(`## ${lane.title}`);
      lines.push("");
      for (const card of lane.cards) {
        let cardLine = `- [${card.completed ? "x" : " "}] `;
        if (card.baseTaskPath) {
          cardLine += `[[${card.baseTaskPath}|${card.title}]]`;
        } else {
          cardLine += card.title;
        }
        if (card.dueDate) {
          cardLine += ` @{${card.dueDate}}`;
        }
        for (const tag of card.tags) {
          if (!cardLine.includes(`#${tag}`)) {
            cardLine += ` #${tag}`;
          }
        }
        if (card.metadata.priority) {
          cardLine += ` [priority::${card.metadata.priority}]`;
        }
        if (card.metadata.project) {
          cardLine += ` [project::${card.metadata.project}]`;
        }
        lines.push(cardLine);
      }
      lines.push("");
    }
    if (board.archive.length > 0) {
      lines.push("## Archive");
      lines.push("");
      for (const card of board.archive) {
        let cardLine = `- [x] ${card.title}`;
        if (card.dueDate) {
          cardLine += ` @{${card.dueDate}}`;
        }
        lines.push(cardLine);
      }
      lines.push("");
    }
    lines.push("%% kanban:settings");
    lines.push("```");
    lines.push(JSON.stringify(board.settings, null, 2));
    lines.push("```");
    lines.push("%%");
    return lines.join("\n");
  }
  /**
   * Ensure the Kanban boards folder exists
   */
  async ensureBoardsFolderExists() {
    const folderPath = (0, import_obsidian8.normalizePath)(this.settings.kanbanBoardsFolder);
    const folder = this.app.vault.getAbstractFileByPath(folderPath);
    if (!folder) {
      await this.app.vault.createFolder(folderPath);
    }
  }
  /**
   * Create or update a Kanban board file
   */
  async createOrUpdateBoard(boardName, tasks, options) {
    await this.ensureBoardsFolderExists();
    const board = this.createBoardFromTasks(tasks, boardName);
    const content = this.serializeBoard(board);
    const sanitizedName = boardName.replace(/[\\/:*?"<>|]/g, "");
    const filePath = (0, import_obsidian8.normalizePath)(`${this.settings.kanbanBoardsFolder}/${sanitizedName}.md`);
    const existingFile = this.app.vault.getAbstractFileByPath(filePath);
    if (existingFile instanceof import_obsidian8.TFile) {
      if ((options == null ? void 0 : options.overwrite) !== false) {
        await this.app.vault.modify(existingFile, content);
        return existingFile;
      }
      return existingFile;
    }
    return await this.app.vault.create(filePath, content);
  }
  /**
   * Open a Kanban board in the workspace
   */
  async openBoard(file) {
    const leaf = this.app.workspace.getLeaf(false);
    if (this.isKanbanPluginAvailable()) {
      await leaf.setViewState({
        type: "kanban",
        state: { file: file.path }
      });
    } else {
      await leaf.openFile(file);
    }
  }
  /**
   * Create and open a Kanban board for all tasks
   */
  async openAllTasksBoard() {
    const tasks = await this.queryTasks({ includeCompleted: false });
    if (tasks.length === 0) {
      new import_obsidian8.Notice("No active tasks found");
      return;
    }
    const file = await this.createOrUpdateBoard(
      this.settings.defaultKanbanBoardName,
      tasks,
      { overwrite: true }
    );
    await this.openBoard(file);
    new import_obsidian8.Notice(`Opened Kanban board with ${tasks.length} tasks`);
  }
  /**
   * Create and open a Kanban board for an Epic
   */
  async openEpicBoard(epicName) {
    const tasks = await this.queryTasks({
      epic: epicName,
      includeCompleted: true
    });
    if (tasks.length === 0) {
      new import_obsidian8.Notice(`No tasks found for Epic: ${epicName}`);
      return;
    }
    const boardName = `${epicName} Board`;
    const file = await this.createOrUpdateBoard(boardName, tasks, { overwrite: true });
    await this.openBoard(file);
    new import_obsidian8.Notice(`Opened Kanban board with ${tasks.length} tasks from Epic: ${epicName}`);
  }
  /**
   * Create and open a Kanban board for a Project
   */
  async openProjectBoard(projectName) {
    const tasks = await this.queryTasks({
      project: projectName,
      includeCompleted: true
    });
    if (tasks.length === 0) {
      new import_obsidian8.Notice(`No tasks found for Project: ${projectName}`);
      return;
    }
    const boardName = `${projectName} Board`;
    const file = await this.createOrUpdateBoard(boardName, tasks, { overwrite: true });
    await this.openBoard(file);
    new import_obsidian8.Notice(`Opened Kanban board with ${tasks.length} tasks from Project: ${projectName}`);
  }
  /**
   * Get available epics
   */
  async getEpics() {
    const epics = [];
    const folder = this.app.vault.getAbstractFileByPath(this.settings.epicsFolder);
    if (!(folder instanceof import_obsidian8.TFolder)) {
      return epics;
    }
    for (const child of folder.children) {
      if (child instanceof import_obsidian8.TFile && child.extension === "md") {
        epics.push(child.basename);
      }
    }
    return epics.sort();
  }
  /**
   * Get available projects
   */
  async getProjects() {
    const projects = [];
    const folder = this.app.vault.getAbstractFileByPath(this.settings.projectsFolder);
    if (!(folder instanceof import_obsidian8.TFolder)) {
      return projects;
    }
    const getAllProjects = (folder2) => {
      const names = [];
      for (const child of folder2.children) {
        if (child instanceof import_obsidian8.TFolder) {
          names.push(child.name);
          names.push(...getAllProjects(child));
        } else if (child instanceof import_obsidian8.TFile && child.extension === "md") {
          names.push(child.basename);
        }
      }
      return names;
    };
    return getAllProjects(folder).sort();
  }
  /**
   * Update task status in the task file
   */
  async updateTaskStatus(taskPath, newStatus) {
    try {
      const file = this.app.vault.getAbstractFileByPath(taskPath);
      if (!(file instanceof import_obsidian8.TFile)) {
        console.warn(`Task file not found: ${taskPath}`);
        return false;
      }
      let content = await this.app.vault.read(file);
      const statusRegex = /^(Status:)\s*.+$/mi;
      if (statusRegex.test(content)) {
        content = content.replace(statusRegex, `$1 ${newStatus}`);
      } else {
        const frontmatterEndMatch = content.match(/^---\s*\n([\s\S]*?)\n---/);
        if (frontmatterEndMatch) {
          const frontmatter = frontmatterEndMatch[1];
          const newFrontmatter = frontmatter + `
Status: ${newStatus}`;
          content = content.replace(frontmatterEndMatch[1], newFrontmatter);
        }
      }
      const updatedRegex = /^(Updated:)\s*.+$/mi;
      const now = /* @__PURE__ */ new Date();
      const timestamp = `"${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, "0")}-${String(now.getDate()).padStart(2, "0")} ${String(now.getHours()).padStart(2, "0")}:${String(now.getMinutes()).padStart(2, "0")}"`;
      if (updatedRegex.test(content)) {
        content = content.replace(updatedRegex, `$1 ${timestamp}`);
      }
      await this.app.vault.modify(file, content);
      return true;
    } catch (error) {
      console.error(`Failed to update task status: ${taskPath}`, error);
      return false;
    }
  }
};

// main.ts
var MAX_BREAKDOWN_TASKS = 20;
var QuickTaskModal = class extends import_obsidian9.Modal {
  constructor(app, onSubmit) {
    super(app);
    this.inputEl = null;
    this.onSubmit = onSubmit;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("gpt-task-manager-quick-modal");
    contentEl.createEl("h2", { text: t("quickTaskTitle") });
    contentEl.createEl("p", {
      text: t("quickTaskDescription"),
      cls: "modal-description"
    });
    this.inputEl = contentEl.createEl("textarea", {
      placeholder: "e.g., Create a landing page for the Freedom Runway project with high priority"
    });
    this.inputEl.style.width = "100%";
    this.inputEl.style.minHeight = "100px";
    this.inputEl.style.marginBottom = "16px";
    this.inputEl.style.padding = "12px";
    this.inputEl.style.fontSize = "14px";
    this.inputEl.style.borderRadius = "8px";
    this.inputEl.addEventListener("keydown", (event) => {
      if (event.key === "Enter" && !event.shiftKey) {
        event.preventDefault();
        this.submit();
      }
    });
    const buttonsEl = contentEl.createDiv({ cls: "modal-button-container" });
    const cancelBtn = buttonsEl.createEl("button", { text: t("cancel") });
    cancelBtn.onclick = () => this.close();
    const submitBtn = buttonsEl.createEl("button", { text: t("createWithAi"), cls: "mod-cta" });
    submitBtn.onclick = () => this.submit();
    this.inputEl.focus();
  }
  submit() {
    var _a;
    const input = (_a = this.inputEl) == null ? void 0 : _a.value.trim();
    if (input) {
      this.close();
      this.onSubmit(input);
    } else {
      new import_obsidian9.Notice(t("pleaseEnterDescription"));
    }
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var EpicSelectModal = class extends import_obsidian9.FuzzySuggestModal {
  constructor(app, epics, onChoose) {
    super(app);
    this.epics = epics;
    this.onChoose = onChoose;
    this.setPlaceholder("Select an epic to break down...");
  }
  getItems() {
    return this.epics;
  }
  getItemText(item) {
    const status = item.status ? ` [${item.status}]` : "";
    const project = item.project ? ` - ${item.project}` : "";
    return `${item.name}${status}${project}`;
  }
  onChooseItem(item, evt) {
    this.onChoose(item);
  }
};
var TaskReviewModal = class extends import_obsidian9.Modal {
  constructor(app, suggestion, epics, onConfirm, onCancel) {
    super(app);
    this.resolved = false;
    this.suggestion = suggestion;
    this.epics = epics;
    this.onConfirm = onConfirm;
    this.onCancel = onCancel;
    this.selectedEpic = suggestion.suggestedEpic;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("gpt-task-manager-review-modal");
    contentEl.createEl("h2", { text: t("reviewTask") });
    const formEl = contentEl.createDiv({ cls: "task-review-form" });
    const titleGroup = formEl.createDiv({ cls: "form-group" });
    titleGroup.createEl("label", { text: t("reviewTitle") });
    const titleInput = titleGroup.createEl("input", { type: "text", value: this.suggestion.title });
    titleInput.style.width = "100%";
    titleInput.addEventListener("change", () => {
      this.suggestion.title = titleInput.value;
    });
    const objectiveGroup = formEl.createDiv({ cls: "form-group" });
    objectiveGroup.createEl("label", { text: t("reviewObjective") });
    const objectiveInput = objectiveGroup.createEl("textarea", { text: this.suggestion.objective });
    objectiveInput.style.width = "100%";
    objectiveInput.rows = 3;
    objectiveInput.addEventListener("change", () => {
      this.suggestion.objective = objectiveInput.value;
    });
    const importanceGroup = formEl.createDiv({ cls: "form-group" });
    importanceGroup.createEl("label", { text: t("reviewImportance") });
    const importanceInput = importanceGroup.createEl("textarea", { text: this.suggestion.importance });
    importanceInput.style.width = "100%";
    importanceInput.rows = 2;
    importanceInput.addEventListener("change", () => {
      this.suggestion.importance = importanceInput.value;
    });
    const epicGroup = formEl.createDiv({ cls: "form-group" });
    epicGroup.createEl("label", { text: t("reviewEpic") });
    const epicSelect = epicGroup.createEl("select");
    epicSelect.style.width = "100%";
    const noneOption = epicSelect.createEl("option", { text: t("noEpic"), value: "" });
    for (const epic of this.epics) {
      const option = epicSelect.createEl("option", {
        text: `${epic.name} (${epic.status || "active"})`,
        value: epic.name
      });
      if (epic.name === this.suggestion.suggestedEpic) {
        option.selected = true;
      }
    }
    epicSelect.addEventListener("change", () => {
      this.selectedEpic = epicSelect.value || null;
    });
    const priorityGroup = formEl.createDiv({ cls: "form-group" });
    priorityGroup.createEl("label", { text: t("reviewPriority") });
    const prioritySelect = priorityGroup.createEl("select");
    prioritySelect.style.width = "100%";
    const priorities = [
      { value: "low", text: "Low" },
      { value: "medium", text: "Medium" },
      { value: "high", text: "High" },
      { value: "critical", text: "Critical" }
    ];
    for (const priority of priorities) {
      const option = prioritySelect.createEl("option", {
        text: priority.text,
        value: priority.value
      });
      if (priority.value === this.suggestion.priority) {
        option.selected = true;
      }
    }
    prioritySelect.addEventListener("change", () => {
      this.suggestion.priority = prioritySelect.value;
    });
    if (this.suggestion.subtasks.length > 0) {
      const subtasksGroup = formEl.createDiv({ cls: "form-group" });
      subtasksGroup.createEl("label", { text: `Suggested Subtasks (${this.suggestion.subtasks.length})` });
      const subtasksList = subtasksGroup.createEl("ul", { cls: "subtasks-preview" });
      for (const subtask of this.suggestion.subtasks) {
        subtasksList.createEl("li", { text: subtask });
      }
    }
    const buttonsEl = contentEl.createDiv({ cls: "modal-button-container" });
    const cancelBtn = buttonsEl.createEl("button", { text: t("cancel") });
    cancelBtn.onclick = () => {
      this.resolved = true;
      this.close();
      this.onCancel();
    };
    const confirmBtn = buttonsEl.createEl("button", { text: t("createTask"), cls: "mod-cta" });
    confirmBtn.onclick = () => {
      this.resolved = true;
      this.close();
      this.onConfirm(this.suggestion, this.selectedEpic);
    };
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
    if (!this.resolved) {
      this.resolved = true;
      this.onCancel();
    }
  }
};
var BreakdownReviewModal = class extends import_obsidian9.Modal {
  constructor(app, breakdown, epicName, onConfirm, onCancel) {
    super(app);
    this.resolved = false;
    this.breakdown = breakdown;
    this.epicName = epicName;
    this.onConfirm = onConfirm;
    this.onCancel = onCancel;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("gpt-task-manager-breakdown-modal");
    contentEl.createEl("h2", { text: `\u{1F4CA} Task Breakdown: ${this.epicName}` });
    contentEl.createEl("p", {
      text: `${this.breakdown.tasks.length} tasks will be created:`,
      cls: "modal-description"
    });
    const taskListEl = contentEl.createDiv({ cls: "breakdown-task-list" });
    for (let index = 0; index < this.breakdown.tasks.length; index++) {
      const task = this.breakdown.tasks[index];
      const taskEl = taskListEl.createDiv({ cls: "breakdown-task-item" });
      const headerEl = taskEl.createDiv({ cls: "task-header" });
      headerEl.createEl("span", { text: `${index + 1}. ${task.title}`, cls: "task-title" });
      headerEl.createEl("span", {
        text: task.priority,
        cls: `task-priority priority-${task.priority}`
      });
      if (task.objective) {
        taskEl.createEl("p", { text: task.objective, cls: "task-objective" });
      }
      if (task.dependsOn !== null) {
        taskEl.createEl("span", {
          text: `Depends on: Task ${task.dependsOn + 1}`,
          cls: "task-dependency"
        });
      }
    }
    const buttonsEl = contentEl.createDiv({ cls: "modal-button-container" });
    const cancelBtn = buttonsEl.createEl("button", { text: t("cancel") });
    cancelBtn.onclick = () => {
      this.resolved = true;
      this.close();
      this.onCancel();
    };
    const confirmBtn = buttonsEl.createEl("button", {
      text: t("confirmCreateTasks", { count: this.breakdown.tasks.length }),
      cls: "mod-cta"
    });
    confirmBtn.onclick = () => {
      this.resolved = true;
      this.close();
      this.onConfirm(this.breakdown);
    };
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
    if (!this.resolved) {
      this.resolved = true;
      this.onCancel();
    }
  }
};
var GptTaskManagerPlugin = class extends import_obsidian9.Plugin {
  constructor() {
    super(...arguments);
    this.settings = DEFAULT_SETTINGS;
    this.contextCache = null;
    this.activeCancellationToken = null;
    this.kanbanService = null;
  }
  async onload() {
    logger.info("Plugin", "Loading GPT Task Manager plugin...");
    await this.loadSettings();
    this.initializeInfrastructure();
    this.addSettingTab(new GptTaskManagerSettingTab(this.app, this));
    this.addRibbonIcon("plus-circle", "Quick Task (GPT)", () => {
      this.showQuickTaskModal();
    });
    this.addRibbonIcon("mic", "Voice Task", () => {
      this.startVoiceTask();
    });
    if (this.settings.enableKanbanIntegration) {
      this.addRibbonIcon("layout-dashboard", "Open Kanban Board", () => {
        this.openKanbanBoard();
      });
    }
    this.kanbanService = new KanbanIntegrationService(this.app, this.settings);
    this.addCommand({
      id: "gpt-task-quick-create",
      name: "Quick Task Creation (GPT Assisted)",
      callback: () => this.showQuickTaskModal()
    });
    this.addCommand({
      id: "gpt-task-voice-create",
      name: "Voice Task Creation",
      callback: () => this.startVoiceTask()
    });
    this.addCommand({
      id: "gpt-task-breakdown-epic",
      name: "Break Down Epic into Tasks",
      callback: () => this.showEpicBreakdownModal()
    });
    this.addCommand({
      id: "gpt-task-simple-create",
      name: "Simple Task Creation (No AI)",
      callback: () => this.showSimpleTaskModal()
    });
    this.addCommand({
      id: "gpt-task-from-selection",
      name: "Create Task from Selection (GPT)",
      editorCallback: (editor, view) => {
        this.createTaskFromSelection(editor);
      }
    });
    this.addCommand({
      id: "gpt-kanban-open-all-tasks",
      name: "Kanban: Open All Tasks Board",
      callback: () => this.openKanbanBoard()
    });
    this.addCommand({
      id: "gpt-kanban-open-epic-board",
      name: "Kanban: Open Board for Epic",
      callback: () => this.showEpicKanbanModal()
    });
    this.addCommand({
      id: "gpt-kanban-open-project-board",
      name: "Kanban: Open Board for Project",
      callback: () => this.showProjectKanbanModal()
    });
    this.addCommand({
      id: "gpt-kanban-refresh-board",
      name: "Kanban: Refresh Current Board",
      callback: () => this.refreshCurrentKanbanBoard()
    });
    logger.info("Plugin", "GPT Task Manager loaded successfully");
  }
  onunload() {
    logger.info("Plugin", "Unloading GPT Task Manager plugin...");
    if (this.contextCache) {
      this.contextCache.destroy();
      this.contextCache = null;
    }
    if (this.activeCancellationToken) {
      this.activeCancellationToken.cancel("Plugin unloading");
    }
  }
  async loadSettings() {
    const stored = await this.loadData();
    this.settings = Object.assign({}, DEFAULT_SETTINGS, stored);
  }
  async saveSettings() {
    await this.saveData(this.settings);
    this.initializeInfrastructure();
  }
  /**
   * Initialize infrastructure based on settings
   */
  initializeInfrastructure() {
    const logLevelMap = {
      debug: 0 /* DEBUG */,
      info: 1 /* INFO */,
      warn: 2 /* WARN */,
      error: 3 /* ERROR */,
      none: 4 /* NONE */
    };
    logger.setLogLevel(logLevelMap[this.settings.logLevel] || 1 /* INFO */);
    setLocale(this.settings.uiLocale);
    setRateLimitConfig(this.settings.rateLimitPerMinute, 6e4);
    if (this.settings.enableContextCache) {
      if (!this.contextCache) {
        this.contextCache = new ContextCache(this.app, {
          ttlMs: 6e4,
          // 1 minute cache
          maxEntries: 50,
          debounceMs: 500
        });
      }
    } else if (this.contextCache) {
      this.contextCache.destroy();
      this.contextCache = null;
    }
    if (this.kanbanService) {
      this.kanbanService.updateSettings(this.settings);
    }
    logger.debug("Plugin", "Infrastructure initialized", {
      logLevel: this.settings.logLevel,
      locale: this.settings.uiLocale,
      cacheEnabled: this.settings.enableContextCache,
      rateLimitPerMinute: this.settings.rateLimitPerMinute,
      kanbanEnabled: this.settings.enableKanbanIntegration
    });
  }
  /**
   * Create a new cancellation token for an operation
   */
  createCancellationToken() {
    if (this.activeCancellationToken) {
      this.activeCancellationToken.cancel("New operation started");
    }
    this.activeCancellationToken = new CancellationToken();
    return this.activeCancellationToken;
  }
  /**
   * Get user context (cached if enabled)
   * 
   * Uses atomic loading to ensure a consistent snapshot across goals, projects,
   * epics, and tasks. This avoids issues where the vault changes between
   * individual load calls.
   */
  getUserContext() {
    const cacheKey = `${this.settings.goalsFolder}|${this.settings.projectsFolder}|${this.settings.epicsFolder}|${this.settings.tasksFolder}`;
    if (this.contextCache && this.settings.enableContextCache) {
      return this.contextCache.getUserContext(
        cacheKey,
        () => loadUserContext(
          this.app,
          this.settings.goalsFolder,
          this.settings.projectsFolder,
          this.settings.epicsFolder,
          this.settings.tasksFolder
        )
      );
    }
    return loadUserContext(
      this.app,
      this.settings.goalsFolder,
      this.settings.projectsFolder,
      this.settings.epicsFolder,
      this.settings.tasksFolder
    );
  }
  /**
   * Show quick task input modal
   */
  showQuickTaskModal() {
    if (!this.settings.openAIApiKey) {
      showErrorNotice(t("errorNoApiKey"));
      return;
    }
    new QuickTaskModal(this.app, async (input) => {
      await this.processQuickTask(input);
    }).open();
  }
  /**
   * Process quick task input with GPT
   */
  async processQuickTask(input) {
    showNotice(t("progressProcessing"));
    const cancellationToken = this.createCancellationToken();
    try {
      const context = this.getUserContext();
      const formattedContext = formatContextForPrompt(context);
      const prompt = fillPromptTemplate(this.settings.taskCreationPrompt, {
        goals: formattedContext.goals,
        projects: formattedContext.projects,
        epics: formattedContext.epics,
        input
      });
      const result = await callGptApi(
        prompt,
        "You are a helpful task management assistant that creates well-structured tasks.",
        this.settings.openAIApiKey,
        this.settings.gptModel,
        this.settings.gptMaxTokens,
        this.settings.gptTemperature,
        cancellationToken,
        this.settings.apiTimeoutSeconds,
        this.settings.apiMaxRetries
      );
      if (result.cancelled) {
        showNotice(t("taskCreationCancelled"));
        return;
      }
      if (!result.success || !result.content) {
        showErrorNotice(result.errorMessage || "Unknown error");
        return;
      }
      const suggestion = parseTaskSuggestion(result.content);
      if (!suggestion) {
        showNotice(t("errorParsingFailed"));
        await this.createSimpleTask(input);
        return;
      }
      new TaskReviewModal(
        this.app,
        suggestion,
        context.epics,
        async (finalSuggestion, selectedEpic) => {
          await this.createTaskFromSuggestion(finalSuggestion, selectedEpic);
        },
        () => {
          showNotice(t("taskCreationCancelled"));
        }
      ).open();
    } catch (error) {
      logger.error("Plugin", "Quick task error", { error: error instanceof Error ? error.message : "Unknown" });
      showErrorNotice(error instanceof Error ? error.message : "Unknown error");
    }
  }
  /**
   * Create task from GPT suggestion with confirmation dialog
   */
  async createTaskFromSuggestion(suggestion, epicName) {
    try {
      const summary = buildSuggestionSummary(suggestion, epicName, this.settings);
      const confirmed = await showTaskConfirmation(
        this.app,
        [summary],
        "single",
        epicName
      );
      if (!confirmed) {
        new import_obsidian9.Notice("Task creation cancelled");
        return;
      }
      let epicMetadata = null;
      if (epicName) {
        epicMetadata = await getEpicMetadata(this.app, epicName, this.settings.epicsFolder);
      }
      const content = generateTaskFromSuggestion(suggestion, epicMetadata, this.settings);
      const file = await createTaskFile(
        this.app,
        content,
        suggestion.title,
        epicName,
        this.settings
      );
      new import_obsidian9.Notice(`\u2705 Created task: ${suggestion.title}`);
      await this.app.workspace.openLinkText(file.path, "", false);
    } catch (error) {
      console.error("[GPT Task Manager] Task creation error:", error);
      new import_obsidian9.Notice(`Failed to create task: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  /**
   * Start voice task recording
   */
  startVoiceTask() {
    if (!this.settings.openAIApiKey) {
      showErrorNotice(t("errorNoApiKey"));
      return;
    }
    if (!this.settings.enableVoiceInput) {
      showErrorNotice(t("errorVoiceDisabled"));
      return;
    }
    new VoiceRecordingModal(
      this.app,
      async (audioBlob) => {
        await this.processVoiceTask(audioBlob);
      },
      () => {
        showNotice(t("taskCreationCancelled"));
      }
    ).open();
  }
  /**
   * Process voice recording into task
   */
  async processVoiceTask(audioBlob) {
    showNotice(t("progressTranscribing"));
    const cancellationToken = this.createCancellationToken();
    try {
      const transcription = await transcribeAudio(
        audioBlob,
        this.settings.openAIApiKey,
        this.settings.whisperModel,
        this.settings.defaultLanguage === "auto" ? void 0 : this.settings.defaultLanguage,
        cancellationToken
      );
      if (!transcription) {
        showErrorNotice("Transcription returned empty result");
        return;
      }
      showNotice(`\u{1F4DD} Transcribed: "${transcription.substring(0, 50)}..."`);
      const voiceInput = parseVoiceTaskInput(transcription);
      if (this.settings.enableSmartSuggestions) {
        await this.processQuickTask(transcription);
      } else {
        await this.createSimpleTask(
          voiceInput.taskTitle || transcription,
          {
            epic: voiceInput.epic || void 0,
            project: voiceInput.project || void 0,
            priority: voiceInput.priority || void 0
          }
        );
      }
    } catch (error) {
      logger.error("Plugin", "Voice task error", { error: error instanceof Error ? error.message : "Unknown" });
      if (error instanceof Error && error.message.includes("cancelled")) {
        showNotice(t("taskCreationCancelled"));
      } else {
        showErrorNotice(error instanceof Error ? error.message : "Unknown error");
      }
    }
  }
  /**
   * Show epic breakdown modal
   */
  showEpicBreakdownModal() {
    if (!this.settings.openAIApiKey) {
      showErrorNotice(t("errorNoApiKey"));
      return;
    }
    const epics = loadEpics(this.app, this.settings.epicsFolder);
    if (epics.length === 0) {
      showErrorNotice(t("errorNoEpics"));
      return;
    }
    new EpicSelectModal(this.app, epics, async (epic) => {
      await this.breakdownEpic(epic);
    }).open();
  }
  /**
   * Break down an epic into tasks using GPT
   */
  async breakdownEpic(epic) {
    var _a;
    showNotice(t("breakdownCreating", { epic: epic.name }));
    const cancellationToken = this.createCancellationToken();
    try {
      const epicPath = epic.path;
      const epicFile = this.app.vault.getAbstractFileByPath(epicPath);
      let epicContent = "";
      if (epicFile instanceof import_obsidian9.TFile) {
        epicContent = await this.app.vault.read(epicFile);
      }
      const objectiveMatch = epicContent.match(/##  Objective[\s\S]*?> What this epic aims to achieve:\s*\n-\s*(.+)/);
      const objective = objectiveMatch ? objectiveMatch[1] : epic.description || "";
      const prompt = fillPromptTemplate(this.settings.taskBreakdownPrompt, {
        title: epic.name,
        description: epic.description || "No description provided",
        objective,
        goal: epic.goal,
        project: epic.project,
        area: epic.area
      });
      const result = await callGptApi(
        prompt,
        "You are an expert project manager that breaks down complex work into actionable tasks.",
        this.settings.openAIApiKey,
        this.settings.gptModel,
        this.settings.gptMaxTokens,
        this.settings.gptTemperature,
        cancellationToken,
        this.settings.apiTimeoutSeconds,
        this.settings.apiMaxRetries
      );
      if (result.cancelled) {
        showNotice(t("taskCreationCancelled"));
        return;
      }
      if (!result.success || !result.content) {
        showErrorNotice(result.errorMessage || "Unknown error");
        return;
      }
      let breakdown = parseTaskBreakdown(result.content);
      if (!breakdown || breakdown.tasks.length === 0) {
        showErrorNotice(t("errorBreakdownEmpty"));
        return;
      }
      if (breakdown.tasks.length > MAX_BREAKDOWN_TASKS) {
        showNotice(t("errorBreakdownTooLarge", {
          count: breakdown.tasks.length,
          max: MAX_BREAKDOWN_TASKS
        }));
        breakdown = {
          tasks: breakdown.tasks.slice(0, MAX_BREAKDOWN_TASKS)
        };
      }
      if (breakdown.tasks.length > 8) {
        const batchModal = new BatchConfirmationModal(
          this.app,
          breakdown.tasks.map((task) => ({ title: task.title })),
          epic.name
        );
        const selectedItems = await batchModal.waitForConfirmation();
        if (selectedItems.length === 0) {
          showNotice(t("taskCreationCancelled"));
          return;
        }
        const selectedTitles = new Set(selectedItems.map((item) => item.title));
        breakdown = {
          tasks: breakdown.tasks.filter((task) => selectedTitles.has(task.title))
        };
        const oldIndexToNewIndex = /* @__PURE__ */ new Map();
        let newIndex = 0;
        for (let oldIndex = 0; oldIndex < result.content.length; oldIndex++) {
          const task = (_a = parseTaskBreakdown(result.content)) == null ? void 0 : _a.tasks[oldIndex];
          if (task && selectedTitles.has(task.title)) {
            oldIndexToNewIndex.set(oldIndex, newIndex);
            newIndex++;
          }
        }
        breakdown.tasks = breakdown.tasks.map((task) => ({
          ...task,
          dependsOn: task.dependsOn !== null && oldIndexToNewIndex.has(task.dependsOn) ? oldIndexToNewIndex.get(task.dependsOn) : null
        }));
        await this.createBreakdownTasks(breakdown, epic);
        return;
      }
      new BreakdownReviewModal(
        this.app,
        breakdown,
        epic.name,
        async (finalBreakdown) => {
          await this.createBreakdownTasks(finalBreakdown, epic);
        },
        () => {
          showNotice(t("taskCreationCancelled"));
        }
      ).open();
    } catch (error) {
      logger.error("Plugin", "Epic breakdown error", { error: error instanceof Error ? error.message : "Unknown" });
      showErrorNotice(error instanceof Error ? error.message : "Unknown error");
    }
  }
  /**
   * Create tasks from breakdown with confirmation dialog
   */
  async createBreakdownTasks(breakdown, epic) {
    try {
      if (this.settings.showConfirmationDialogs) {
        const summaries = buildBreakdownSummaries(breakdown, epic.name, this.settings);
        const confirmed = await showTaskConfirmation(
          this.app,
          summaries,
          "breakdown",
          epic.name
        );
        if (!confirmed) {
          showNotice(t("taskCreationCancelled"));
          return;
        }
      }
      const epicMetadata = {
        area: epic.area,
        goal: epic.goal,
        project: epic.project
      };
      const files = await createTasksFromBreakdown(
        this.app,
        breakdown,
        epic.name,
        epicMetadata,
        this.settings
      );
      showSuccessNotice(t("taskCreated", { title: `${files.length} tasks for ${epic.name}` }));
      if (files.length > 0) {
        await this.app.workspace.openLinkText(files[0].path, "", false);
      }
    } catch (error) {
      logger.error("Plugin", "Breakdown task creation error", { error: error instanceof Error ? error.message : "Unknown" });
      showErrorNotice(error instanceof Error ? error.message : "Unknown error");
    }
  }
  /**
   * Show simple task creation modal (no AI)
   */
  showSimpleTaskModal() {
    new QuickTaskModal(this.app, async (input) => {
      await this.createSimpleTask(input);
    }).open();
  }
  /**
   * Create a simple task without GPT (with confirmation)
   * 
   * @param title - The task title
   * @param options - Optional metadata extracted from voice input or other sources
   *                  (epic, project, priority)
   */
  async createSimpleTask(title, options) {
    try {
      const epicName = (options == null ? void 0 : options.epic) || null;
      const priority = (options == null ? void 0 : options.priority) || this.settings.defaultPriority;
      let targetFolder = this.settings.tasksFolder;
      if (epicName) {
        const sanitizedEpicName = sanitizeFilename(epicName, "Untitled Epic");
        targetFolder = `${this.settings.tasksFolder}/active epic folder/${sanitizedEpicName}`;
      }
      const summary = {
        title,
        targetFolder,
        epic: epicName,
        priority,
        dependsOnTask: null
      };
      const confirmed = await showTaskConfirmation(
        this.app,
        [summary],
        "single",
        epicName
      );
      if (!confirmed) {
        new import_obsidian9.Notice("Task creation cancelled");
        return;
      }
      let epicMetadata = null;
      if (epicName) {
        epicMetadata = await getEpicMetadata(this.app, epicName, this.settings.epicsFolder);
      }
      const params = {
        title,
        objective: "",
        importance: "",
        area: (epicMetadata == null ? void 0 : epicMetadata.area) || "",
        goal: (epicMetadata == null ? void 0 : epicMetadata.goal) || "",
        project: (options == null ? void 0 : options.project) || (epicMetadata == null ? void 0 : epicMetadata.project) || "",
        epic: epicName || "",
        status: this.settings.defaultStatus,
        priority,
        tags: ["tasks"]
      };
      const content = generateTaskContent(params, this.settings);
      const file = await createTaskFile(
        this.app,
        content,
        title,
        epicName,
        this.settings
      );
      new import_obsidian9.Notice(`\u2705 Created task: ${title}`);
      await this.app.workspace.openLinkText(file.path, "", false);
    } catch (error) {
      console.error("[GPT Task Manager] Simple task error:", error);
      new import_obsidian9.Notice(`Failed to create task: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  /**
   * Create task from selected text
   */
  async createTaskFromSelection(editor) {
    const selection = editor.getSelection();
    if (!selection) {
      new import_obsidian9.Notice(t("pleaseSelectText"));
      return;
    }
    if (this.settings.enableSmartSuggestions && this.settings.openAIApiKey) {
      await this.processQuickTask(selection);
    } else {
      await this.createSimpleTask(selection);
    }
  }
  // ========== Kanban Integration Methods ==========
  /**
   * Open the default Kanban board with all tasks
   */
  async openKanbanBoard() {
    if (!this.settings.enableKanbanIntegration) {
      showErrorNotice(t("kanbanNotEnabled"));
      return;
    }
    if (!this.kanbanService) {
      this.kanbanService = new KanbanIntegrationService(this.app, this.settings);
    }
    try {
      showNotice(t("kanbanLoading"));
      await this.kanbanService.openAllTasksBoard();
    } catch (error) {
      logger.error("Plugin", "Failed to open Kanban board", { error: error instanceof Error ? error.message : "Unknown" });
      showErrorNotice(error instanceof Error ? error.message : "Failed to open Kanban board");
    }
  }
  /**
   * Show modal to select an Epic and open its Kanban board
   */
  async showEpicKanbanModal() {
    if (!this.settings.enableKanbanIntegration) {
      showErrorNotice(t("kanbanNotEnabled"));
      return;
    }
    if (!this.kanbanService) {
      this.kanbanService = new KanbanIntegrationService(this.app, this.settings);
    }
    try {
      const epics = await this.kanbanService.getEpics();
      if (epics.length === 0) {
        showErrorNotice(t("errorNoEpics"));
        return;
      }
      new EpicKanbanSelectModal(this.app, epics, async (epicName) => {
        showNotice(t("kanbanLoadingEpic", { epic: epicName }));
        await this.kanbanService.openEpicBoard(epicName);
      }).open();
    } catch (error) {
      logger.error("Plugin", "Failed to show epic Kanban modal", { error: error instanceof Error ? error.message : "Unknown" });
      showErrorNotice(error instanceof Error ? error.message : "Failed to load epics");
    }
  }
  /**
   * Show modal to select a Project and open its Kanban board
   */
  async showProjectKanbanModal() {
    if (!this.settings.enableKanbanIntegration) {
      showErrorNotice(t("kanbanNotEnabled"));
      return;
    }
    if (!this.kanbanService) {
      this.kanbanService = new KanbanIntegrationService(this.app, this.settings);
    }
    try {
      const projects = await this.kanbanService.getProjects();
      if (projects.length === 0) {
        showErrorNotice(t("kanbanNoProjects"));
        return;
      }
      new ProjectKanbanSelectModal(this.app, projects, async (projectName) => {
        showNotice(t("kanbanLoadingProject", { project: projectName }));
        await this.kanbanService.openProjectBoard(projectName);
      }).open();
    } catch (error) {
      logger.error("Plugin", "Failed to show project Kanban modal", { error: error instanceof Error ? error.message : "Unknown" });
      showErrorNotice(error instanceof Error ? error.message : "Failed to load projects");
    }
  }
  /**
   * Refresh the currently open Kanban board
   */
  async refreshCurrentKanbanBoard() {
    if (!this.settings.enableKanbanIntegration) {
      showErrorNotice(t("kanbanNotEnabled"));
      return;
    }
    const activeFile = this.app.workspace.getActiveFile();
    if (!activeFile) {
      showNotice(t("kanbanNoActiveBoard"));
      return;
    }
    const content = await this.app.vault.read(activeFile);
    if (!content.includes("kanban-plugin:") && !content.includes("gpt-task-manager: true")) {
      showNotice(t("kanbanNotABoard"));
      return;
    }
    if (!this.kanbanService) {
      this.kanbanService = new KanbanIntegrationService(this.app, this.settings);
    }
    try {
      const boardName = activeFile.basename.replace(" Board", "");
      const tasks = await this.kanbanService.queryTasks({ includeCompleted: true });
      await this.kanbanService.createOrUpdateBoard(activeFile.basename, tasks, { overwrite: true });
      showSuccessNotice(t("kanbanRefreshed"));
    } catch (error) {
      logger.error("Plugin", "Failed to refresh Kanban board", { error: error instanceof Error ? error.message : "Unknown" });
      showErrorNotice(error instanceof Error ? error.message : "Failed to refresh board");
    }
  }
  /**
   * Public method for external plugins to get the Kanban service
   */
  getKanbanService() {
    return this.kanbanService;
  }
};
var EpicKanbanSelectModal = class extends import_obsidian9.FuzzySuggestModal {
  constructor(app, epics, onChoose) {
    super(app);
    this.epics = epics;
    this.onChoose = onChoose;
    this.setPlaceholder("Select an Epic to view in Kanban...");
  }
  getItems() {
    return this.epics;
  }
  getItemText(item) {
    return item;
  }
  onChooseItem(item, evt) {
    this.onChoose(item);
  }
};
var ProjectKanbanSelectModal = class extends import_obsidian9.FuzzySuggestModal {
  constructor(app, projects, onChoose) {
    super(app);
    this.projects = projects;
    this.onChoose = onChoose;
    this.setPlaceholder("Select a Project to view in Kanban...");
  }
  getItems() {
    return this.projects;
  }
  getItemText(item) {
    return item;
  }
  onChooseItem(item, evt) {
    this.onChoose(item);
  }
};
