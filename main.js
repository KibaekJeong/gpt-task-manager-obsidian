/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => GptTaskManagerPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian6 = require("obsidian");

// src/settings.ts
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  openAIApiKey: "",
  gptModel: "gpt-4o-mini",
  whisperModel: "whisper-1",
  gptMaxTokens: 2e3,
  gptTemperature: 0.7,
  tasksFolder: "500 Plan & Reflect/520 Tasks",
  epicsFolder: "500 Plan & Reflect/510 Epics",
  goalsFolder: "300 Goals & Milestone/Goals",
  projectsFolder: "400 Projects",
  milestonesFolder: "300 Goals & Milestone/Milestones",
  templatesFolder: "900 Templates",
  taskTemplatePath: "900 Templates/4 Task Template.md",
  epicTemplatePath: "900 Templates/4 Epic Template.md",
  enableVoiceInput: true,
  enableSmartSuggestions: true,
  enableAutoBreakdown: true,
  defaultLanguage: "ko",
  defaultStatus: "backlog",
  defaultPriority: "medium",
  taskCreationPrompt: `You are an expert task manager assistant. Based on the user's input and their current goals/projects context, help create well-structured tasks.

USER CONTEXT:
Goals: {{goals}}
Projects: {{projects}}
Current Epics: {{epics}}

USER INPUT: {{input}}

Create a task with:
1. A clear, actionable title
2. Specific objectives (what needs to be accomplished)
3. Why it matters (connection to goals)
4. Suggested Epic/Project association
5. Priority recommendation (low/medium/high/critical)
6. Estimated complexity (simple/moderate/complex)

Respond in JSON format:
{
  "title": "Task title",
  "objective": "What needs to be accomplished",
  "importance": "Why it matters",
  "suggestedEpic": "Epic name or null",
  "suggestedProject": "Project name or null",
  "priority": "medium",
  "complexity": "moderate",
  "subtasks": ["subtask 1", "subtask 2"] // if complex
}`,
  taskBreakdownPrompt: `You are an expert project manager. Break down the following epic/task into smaller, actionable tasks.

EPIC/TASK: {{title}}
DESCRIPTION: {{description}}
OBJECTIVE: {{objective}}

Context:
- Goal: {{goal}}
- Project: {{project}}
- Area: {{area}}

Create 3-8 well-structured subtasks that:
1. Are specific and actionable
2. Can be completed in 1-4 hours each
3. Have clear dependencies (if any)
4. Lead to completing the parent task/epic

Respond in JSON format:
{
  "tasks": [
    {
      "title": "Task title",
      "objective": "What this task accomplishes",
      "priority": "medium",
      "dependsOn": null // or task index
    }
  ]
}`,
  prioritizationPrompt: `You are a productivity expert. Analyze the following tasks and suggest optimal prioritization.

TASKS:
{{tasks}}

USER'S CURRENT FOCUS:
- Active Goals: {{goals}}
- Deadlines: {{deadlines}}
- Available Time: {{availableTime}}

Provide prioritization recommendations considering:
1. Urgency and deadlines
2. Alignment with current goals
3. Dependencies between tasks
4. Effort vs impact ratio

Respond in JSON format:
{
  "prioritizedTasks": [
    {
      "title": "Task title",
      "suggestedPriority": "high",
      "reasoning": "Why this priority",
      "suggestedOrder": 1
    }
  ],
  "insights": "Overall productivity insights"
}`
};
var GptTaskManagerSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.addClass("gpt-task-manager-settings");
    containerEl.createEl("h1", { text: "GPT Task Manager Settings" });
    containerEl.createEl("h2", { text: "\u{1F511} API Configuration" });
    new import_obsidian.Setting(containerEl).setName("OpenAI API Key").setDesc("Your OpenAI API key for GPT and Whisper.").addText(
      (text) => text.setPlaceholder("sk-...").setValue(this.plugin.settings.openAIApiKey).onChange(async (value) => {
        this.plugin.settings.openAIApiKey = value;
        await this.plugin.saveSettings();
      })
    ).then((setting) => {
      const inputEl = setting.controlEl.querySelector("input");
      if (inputEl) {
        inputEl.type = "password";
        inputEl.style.width = "300px";
      }
    });
    new import_obsidian.Setting(containerEl).setName("GPT Model").setDesc("The OpenAI model to use for task assistance (gpt-4o-mini, gpt-4o, gpt-4-turbo).").addDropdown(
      (dropdown) => dropdown.addOption("gpt-4o-mini", "GPT-4o Mini (Fast, Cheap)").addOption("gpt-4o", "GPT-4o (Powerful)").addOption("gpt-4-turbo", "GPT-4 Turbo").addOption("gpt-3.5-turbo", "GPT-3.5 Turbo (Legacy)").setValue(this.plugin.settings.gptModel).onChange(async (value) => {
        this.plugin.settings.gptModel = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("GPT Max Tokens").setDesc("Maximum tokens for GPT responses (500-4000).").addText(
      (text) => text.setPlaceholder("2000").setValue(String(this.plugin.settings.gptMaxTokens)).onChange(async (value) => {
        const parsed = parseInt(value, 10);
        this.plugin.settings.gptMaxTokens = isNaN(parsed) ? 2e3 : Math.max(500, Math.min(4e3, parsed));
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("GPT Temperature").setDesc("Creativity level (0.0-1.0). Lower = more focused, Higher = more creative.").addText(
      (text) => text.setPlaceholder("0.7").setValue(String(this.plugin.settings.gptTemperature)).onChange(async (value) => {
        const parsed = parseFloat(value);
        this.plugin.settings.gptTemperature = isNaN(parsed) ? 0.7 : Math.max(0, Math.min(1, parsed));
        await this.plugin.saveSettings();
      })
    );
    containerEl.createEl("h2", { text: "\u{1F4C1} Vault Paths" });
    new import_obsidian.Setting(containerEl).setName("Tasks Folder").setDesc("Path to your tasks folder (e.g., 500 Plan & Reflect/520 Tasks).").addText(
      (text) => text.setPlaceholder("500 Plan & Reflect/520 Tasks").setValue(this.plugin.settings.tasksFolder).onChange(async (value) => {
        this.plugin.settings.tasksFolder = (0, import_obsidian.normalizePath)(value.trim());
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Epics Folder").setDesc("Path to your epics folder.").addText(
      (text) => text.setPlaceholder("500 Plan & Reflect/510 Epics").setValue(this.plugin.settings.epicsFolder).onChange(async (value) => {
        this.plugin.settings.epicsFolder = (0, import_obsidian.normalizePath)(value.trim());
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Goals Folder").setDesc("Path to your goals folder.").addText(
      (text) => text.setPlaceholder("300 Goals & Milestone/Goals").setValue(this.plugin.settings.goalsFolder).onChange(async (value) => {
        this.plugin.settings.goalsFolder = (0, import_obsidian.normalizePath)(value.trim());
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Projects Folder").setDesc("Path to your projects folder.").addText(
      (text) => text.setPlaceholder("400 Projects").setValue(this.plugin.settings.projectsFolder).onChange(async (value) => {
        this.plugin.settings.projectsFolder = (0, import_obsidian.normalizePath)(value.trim());
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Task Template Path").setDesc("Path to your task template file.").addText(
      (text) => text.setPlaceholder("900 Templates/4 Task Template.md").setValue(this.plugin.settings.taskTemplatePath).onChange(async (value) => {
        this.plugin.settings.taskTemplatePath = (0, import_obsidian.normalizePath)(value.trim());
        await this.plugin.saveSettings();
      })
    );
    containerEl.createEl("h2", { text: "\u26A1 Features" });
    new import_obsidian.Setting(containerEl).setName("Enable Voice Input").setDesc("Allow creating tasks via voice recording (requires microphone access).").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.enableVoiceInput).onChange(async (value) => {
        this.plugin.settings.enableVoiceInput = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Enable Smart Suggestions").setDesc("Use GPT to suggest task details based on your goals and context.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.enableSmartSuggestions).onChange(async (value) => {
        this.plugin.settings.enableSmartSuggestions = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Enable Auto Breakdown").setDesc("Automatically suggest breaking down complex tasks into subtasks.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.enableAutoBreakdown).onChange(async (value) => {
        this.plugin.settings.enableAutoBreakdown = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Default Language").setDesc("Default language for voice transcription and GPT responses.").addDropdown(
      (dropdown) => dropdown.addOption("ko", "\uD55C\uAD6D\uC5B4 (Korean)").addOption("en", "English").addOption("auto", "Auto-detect").setValue(this.plugin.settings.defaultLanguage).onChange(async (value) => {
        this.plugin.settings.defaultLanguage = value;
        await this.plugin.saveSettings();
      })
    );
    containerEl.createEl("h2", { text: "\u{1F4CB} Task Defaults" });
    new import_obsidian.Setting(containerEl).setName("Default Status").setDesc("Default status for new tasks.").addDropdown(
      (dropdown) => dropdown.addOption("backlog", "Backlog").addOption("todo", "To Do").addOption("in-progress", "In Progress").setValue(this.plugin.settings.defaultStatus).onChange(async (value) => {
        this.plugin.settings.defaultStatus = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Default Priority").setDesc("Default priority for new tasks.").addDropdown(
      (dropdown) => dropdown.addOption("low", "Low").addOption("medium", "Medium").addOption("high", "High").addOption("critical", "Critical").setValue(this.plugin.settings.defaultPriority).onChange(async (value) => {
        this.plugin.settings.defaultPriority = value;
        await this.plugin.saveSettings();
      })
    );
    containerEl.createEl("h2", { text: "\u{1F916} GPT Prompts" });
    containerEl.createEl("p", {
      text: "Customize the prompts used for GPT-powered features. Use {{placeholders}} for dynamic content.",
      cls: "setting-item-description"
    });
    new import_obsidian.Setting(containerEl).setName("Task Creation Prompt").setDesc("Prompt used when creating new tasks with GPT assistance.").addTextArea((text) => {
      text.setPlaceholder("Enter your task creation prompt...").setValue(this.plugin.settings.taskCreationPrompt).onChange(async (value) => {
        this.plugin.settings.taskCreationPrompt = value;
        await this.plugin.saveSettings();
      });
      text.inputEl.rows = 10;
      text.inputEl.style.width = "100%";
      text.inputEl.style.fontFamily = "monospace";
      text.inputEl.style.fontSize = "12px";
    });
    new import_obsidian.Setting(containerEl).setName("Task Breakdown Prompt").setDesc("Prompt used when breaking down tasks/epics into subtasks.").addTextArea((text) => {
      text.setPlaceholder("Enter your task breakdown prompt...").setValue(this.plugin.settings.taskBreakdownPrompt).onChange(async (value) => {
        this.plugin.settings.taskBreakdownPrompt = value;
        await this.plugin.saveSettings();
      });
      text.inputEl.rows = 10;
      text.inputEl.style.width = "100%";
      text.inputEl.style.fontFamily = "monospace";
      text.inputEl.style.fontSize = "12px";
    });
    containerEl.createEl("h2", { text: "\u{1F504} Reset" });
    new import_obsidian.Setting(containerEl).setName("Reset to Defaults").setDesc("Reset all settings to their default values.").addButton(
      (button) => button.setButtonText("Reset All Settings").setWarning().onClick(async () => {
        const apiKey = this.plugin.settings.openAIApiKey;
        this.plugin.settings = { ...DEFAULT_SETTINGS, openAIApiKey: apiKey };
        await this.plugin.saveSettings();
        this.display();
      })
    );
  }
};

// src/gpt-service.ts
var import_obsidian2 = require("obsidian");
async function callGptApi(prompt, systemPrompt, apiKey, model, maxTokens, temperature) {
  var _a, _b, _c, _d, _e;
  if (!apiKey) {
    return { success: false, content: null, errorMessage: "No API key configured" };
  }
  try {
    console.log(`[GPT Task Manager] Calling GPT API with model: ${model}`);
    const response = await (0, import_obsidian2.requestUrl)({
      url: "https://api.openai.com/v1/chat/completions",
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${apiKey}`
      },
      body: JSON.stringify({
        model,
        messages: [
          {
            role: "system",
            content: systemPrompt
          },
          {
            role: "user",
            content: prompt
          }
        ],
        max_tokens: maxTokens,
        temperature
      }),
      throw: false
    });
    if (response.status !== 200) {
      let errorMessage = `API error (${response.status})`;
      const errorBody = response.text || response.json;
      if (typeof errorBody === "string") {
        try {
          const parsed = JSON.parse(errorBody);
          errorMessage = ((_a = parsed == null ? void 0 : parsed.error) == null ? void 0 : _a.message) || errorMessage;
        } catch (e) {
          if (errorBody.length < 200) {
            errorMessage = errorBody;
          }
        }
      } else if ((_b = errorBody == null ? void 0 : errorBody.error) == null ? void 0 : _b.message) {
        errorMessage = errorBody.error.message;
      }
      console.error(`[GPT Task Manager] GPT API error: ${response.status}`, errorBody);
      return { success: false, content: null, errorMessage };
    }
    const data = response.json;
    const content = (_e = (_d = (_c = data == null ? void 0 : data.choices) == null ? void 0 : _c[0]) == null ? void 0 : _d.message) == null ? void 0 : _e.content;
    if (!content) {
      return { success: false, content: null, errorMessage: "Empty response from API" };
    }
    console.log(`[GPT Task Manager] GPT response received: ${content.length} chars`);
    return { success: true, content, errorMessage: null };
  } catch (error) {
    const errorMsg = error instanceof Error ? error.message : "Unknown error";
    console.error("[GPT Task Manager] GPT API call failed:", error);
    return { success: false, content: null, errorMessage: errorMsg };
  }
}
function extractJsonFromResponse(response) {
  const codeBlockMatch = response.match(/```(?:json)?\s*([\s\S]*?)```/);
  if (codeBlockMatch) {
    return codeBlockMatch[1].trim();
  }
  const jsonMatch = response.match(/\{[\s\S]*\}/);
  if (jsonMatch) {
    return jsonMatch[0];
  }
  return response;
}
function generateFallbackTitle() {
  const now = /* @__PURE__ */ new Date();
  return `Task-${now.getFullYear()}${String(now.getMonth() + 1).padStart(2, "0")}${String(now.getDate()).padStart(2, "0")}-${String(now.getHours()).padStart(2, "0")}${String(now.getMinutes()).padStart(2, "0")}`;
}
function ensureValidTitle(title, fallbackSource) {
  const trimmedTitle = (title || "").trim();
  if (trimmedTitle.length > 0) {
    return trimmedTitle;
  }
  const trimmedFallback = (fallbackSource || "").trim();
  if (trimmedFallback.length > 0) {
    return trimmedFallback.substring(0, 50);
  }
  return generateFallbackTitle();
}
function parseTaskSuggestion(response) {
  try {
    const jsonStr = extractJsonFromResponse(response);
    const parsed = JSON.parse(jsonStr);
    return {
      title: ensureValidTitle(parsed.title, parsed.objective),
      objective: parsed.objective || "",
      importance: parsed.importance || "",
      suggestedEpic: parsed.suggestedEpic || null,
      suggestedProject: parsed.suggestedProject || null,
      priority: parsed.priority || "medium",
      complexity: parsed.complexity || "moderate",
      subtasks: Array.isArray(parsed.subtasks) ? parsed.subtasks : []
    };
  } catch (error) {
    console.error("[GPT Task Manager] Failed to parse task suggestion:", error);
    return null;
  }
}
function parseTaskBreakdown(response) {
  try {
    const jsonStr = extractJsonFromResponse(response);
    const parsed = JSON.parse(jsonStr);
    if (!Array.isArray(parsed.tasks)) {
      return null;
    }
    return {
      tasks: parsed.tasks.map((task, taskIndex) => {
        var _a;
        return {
          title: ensureValidTitle(task.title, task.objective) || `Subtask-${taskIndex + 1}`,
          objective: task.objective || "",
          priority: task.priority || "medium",
          dependsOn: (_a = task.dependsOn) != null ? _a : null
        };
      })
    };
  } catch (error) {
    console.error("[GPT Task Manager] Failed to parse task breakdown:", error);
    return null;
  }
}
function fillPromptTemplate(template, values) {
  let result = template;
  for (const [key, value] of Object.entries(values)) {
    result = result.replace(
      new RegExp(`\\{\\{${key}\\}\\}`, "g"),
      () => value
    );
  }
  return result;
}

// src/voice.ts
var import_obsidian3 = require("obsidian");
var VoiceRecordingModal = class extends import_obsidian3.Modal {
  constructor(app, onComplete, onCancel) {
    super(app);
    this.mediaRecorder = null;
    this.audioChunks = [];
    this.stream = null;
    this.timerInterval = null;
    this.startTime = 0;
    this.timerEl = null;
    this.statusEl = null;
    this.startBtn = null;
    this.stopBtn = null;
    this.recordingDot = null;
    this.onComplete = onComplete;
    this.onCancel = onCancel;
  }
  async onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("gpt-task-manager-recording-modal");
    contentEl.createEl("h3", { text: "\u{1F3A4} Voice Task Capture" });
    const indicatorEl = contentEl.createDiv({ cls: "recording-indicator" });
    this.recordingDot = indicatorEl.createDiv({ cls: "recording-dot" });
    this.statusEl = indicatorEl.createSpan({ text: "Ready to record" });
    this.timerEl = contentEl.createDiv({ cls: "recording-timer", text: "00:00" });
    const instructionsEl = contentEl.createDiv({ cls: "recording-instructions" });
    instructionsEl.createEl("p", { text: "Speak your task naturally. Examples:" });
    const examplesList = instructionsEl.createEl("ul");
    examplesList.createEl("li", { text: '"Create login page for the app"' });
    examplesList.createEl("li", { text: '"High priority: Fix payment bug by Friday"' });
    examplesList.createEl("li", { text: '"Add user profile settings to Freedom Runway project"' });
    const buttonsEl = contentEl.createDiv({ cls: "recording-buttons" });
    this.startBtn = buttonsEl.createEl("button", {
      text: "\u{1F399}\uFE0F Start Recording",
      cls: "mod-cta"
    });
    this.startBtn.onclick = () => {
      this.initiateRecording();
    };
    this.stopBtn = buttonsEl.createEl("button", {
      text: "\u23F9\uFE0F Stop & Process",
      cls: "mod-warning"
    });
    this.stopBtn.style.display = "none";
    this.stopBtn.onclick = () => this.stopRecording();
    const cancelBtn = buttonsEl.createEl("button", { text: "Cancel" });
    cancelBtn.onclick = () => this.cancelRecording();
  }
  async initiateRecording() {
    if (this.startBtn)
      this.startBtn.style.display = "none";
    if (this.stopBtn)
      this.stopBtn.style.display = "inline-block";
    if (this.statusEl)
      this.statusEl.textContent = "Recording...";
    if (this.recordingDot)
      this.recordingDot.addClass("active");
    await this.startRecording();
  }
  async startRecording() {
    try {
      this.stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      const mimeType = this.getSupportedMimeType();
      const options = {};
      if (mimeType) {
        options.mimeType = mimeType;
      }
      this.mediaRecorder = new MediaRecorder(this.stream, options);
      this.audioChunks = [];
      this.mediaRecorder.ondataavailable = (event) => {
        if (event.data.size > 0) {
          this.audioChunks.push(event.data);
        }
      };
      this.mediaRecorder.onstop = async () => {
        var _a;
        const mimeType2 = ((_a = this.mediaRecorder) == null ? void 0 : _a.mimeType) || "audio/webm";
        const audioBlob = new Blob(this.audioChunks, { type: mimeType2 });
        this.cleanup();
        try {
          await this.onComplete(audioBlob);
        } catch (error) {
          console.error("[GPT Task Manager] Recording processing failed:", error);
          new import_obsidian3.Notice("Processing failed");
        }
        this.close();
      };
      this.mediaRecorder.onerror = () => {
        console.error("[GPT Task Manager] MediaRecorder error");
        new import_obsidian3.Notice("Recording error occurred");
        this.cancelRecording();
      };
      this.mediaRecorder.start(1e3);
      this.startTime = Date.now();
      this.startTimer();
    } catch (error) {
      console.error("[GPT Task Manager] Failed to start recording:", error);
      new import_obsidian3.Notice("Failed to access microphone. Please check permissions.");
      this.close();
      this.onCancel();
    }
  }
  getSupportedMimeType() {
    const mimeTypes = [
      "audio/mp4",
      "audio/webm;codecs=opus",
      "audio/webm",
      "audio/ogg;codecs=opus",
      "audio/ogg",
      "audio/mpeg"
    ];
    for (const mimeType of mimeTypes) {
      if (MediaRecorder.isTypeSupported(mimeType)) {
        return mimeType;
      }
    }
    return null;
  }
  startTimer() {
    this.timerInterval = window.setInterval(() => {
      const elapsed = Math.floor((Date.now() - this.startTime) / 1e3);
      const minutes = Math.floor(elapsed / 60).toString().padStart(2, "0");
      const seconds = (elapsed % 60).toString().padStart(2, "0");
      if (this.timerEl) {
        this.timerEl.textContent = `${minutes}:${seconds}`;
      }
    }, 1e3);
  }
  stopRecording() {
    if (this.mediaRecorder && this.mediaRecorder.state === "recording") {
      if (this.statusEl)
        this.statusEl.textContent = "Processing...";
      if (this.stopBtn) {
        this.stopBtn.disabled = true;
        this.stopBtn.textContent = "Processing...";
      }
      if (this.recordingDot)
        this.recordingDot.removeClass("active");
      this.mediaRecorder.stop();
    }
  }
  cancelRecording() {
    this.cleanup();
    this.close();
    this.onCancel();
  }
  cleanup() {
    if (this.timerInterval) {
      window.clearInterval(this.timerInterval);
      this.timerInterval = null;
    }
    if (this.stream) {
      this.stream.getTracks().forEach((track) => track.stop());
      this.stream = null;
    }
  }
  onClose() {
    this.cleanup();
    const { contentEl } = this;
    contentEl.empty();
  }
};
async function transcribeAudio(audioBlob, apiKey, model = "whisper-1", language) {
  var _a;
  try {
    const arrayBuffer = await audioBlob.arrayBuffer();
    const mimeType = audioBlob.type || "audio/webm";
    const extension = getExtensionFromMimeType(mimeType);
    const filename = `recording.${extension}`;
    const boundary = "----WebKitFormBoundary" + Math.random().toString(36).substring(2);
    const bodyParts = [];
    bodyParts.push(
      `--${boundary}\r
Content-Disposition: form-data; name="file"; filename="${filename}"\r
Content-Type: ${mimeType}\r
\r
`
    );
    bodyParts.push(arrayBuffer);
    bodyParts.push("\r\n");
    bodyParts.push(
      `--${boundary}\r
Content-Disposition: form-data; name="model"\r
\r
${model}\r
`
    );
    if (language && language !== "auto") {
      bodyParts.push(
        `--${boundary}\r
Content-Disposition: form-data; name="language"\r
\r
${language}\r
`
      );
    }
    bodyParts.push(
      `--${boundary}\r
Content-Disposition: form-data; name="response_format"\r
\r
text\r
`
    );
    bodyParts.push(`--${boundary}--\r
`);
    const body = await combineMultipartBody(bodyParts);
    const response = await (0, import_obsidian3.requestUrl)({
      url: "https://api.openai.com/v1/audio/transcriptions",
      method: "POST",
      headers: {
        "Authorization": `Bearer ${apiKey}`,
        "Content-Type": `multipart/form-data; boundary=${boundary}`
      },
      body,
      throw: false
    });
    if (response.status !== 200) {
      let errorDetail = "";
      try {
        const errorBody = JSON.parse(response.text);
        errorDetail = ((_a = errorBody.error) == null ? void 0 : _a.message) || errorBody.message || response.text;
      } catch (e) {
        errorDetail = response.text.substring(0, 200);
      }
      throw new Error(`Whisper API error (${response.status}): ${errorDetail}`);
    }
    return response.text.trim();
  } catch (error) {
    console.error("[GPT Task Manager] Transcription failed:", error);
    throw error;
  }
}
function getExtensionFromMimeType(mimeType) {
  const mimeToExt = {
    "audio/webm": "webm",
    "audio/webm;codecs=opus": "webm",
    "audio/ogg": "ogg",
    "audio/ogg;codecs=opus": "ogg",
    "audio/mp4": "m4a",
    "audio/mpeg": "mp3",
    "audio/wav": "wav"
  };
  return mimeToExt[mimeType] || "webm";
}
async function combineMultipartBody(parts) {
  const encoder = new TextEncoder();
  const buffers = [];
  for (const part of parts) {
    if (typeof part === "string") {
      buffers.push(encoder.encode(part).buffer);
    } else {
      buffers.push(part);
    }
  }
  let totalLength = 0;
  for (const buf of buffers) {
    totalLength += buf.byteLength;
  }
  const combined = new Uint8Array(totalLength);
  let offset = 0;
  for (const buf of buffers) {
    combined.set(new Uint8Array(buf), offset);
    offset += buf.byteLength;
  }
  return combined.buffer;
}
function parseVoiceTaskInput(transcription) {
  const result = {
    rawText: transcription,
    taskTitle: "",
    description: "",
    epic: "",
    project: "",
    priority: ""
  };
  const cleanedText = transcription.trim();
  const priorityPatterns = [
    { pattern: /(?:high|높은|urgent|긴급)\s*priority/i, priority: "high" },
    { pattern: /priority[:\s]*(high|높음|urgent|긴급)/i, priority: "high" },
    { pattern: /(?:critical|크리티컬|매우\s*중요)/i, priority: "critical" },
    { pattern: /(?:low|낮은)\s*priority/i, priority: "low" },
    { pattern: /priority[:\s]*(low|낮음)/i, priority: "low" }
  ];
  for (const { pattern, priority } of priorityPatterns) {
    if (pattern.test(cleanedText)) {
      result.priority = priority;
      break;
    }
  }
  const projectPatterns = [
    /(?:for|in|to)\s+(?:the\s+)?(.+?)\s+(?:project|프로젝트)/i,
    /(?:project|프로젝트)[:\s]+(.+?)(?:\.|,|$)/i
  ];
  for (const pattern of projectPatterns) {
    const match = cleanedText.match(pattern);
    if (match) {
      result.project = match[1].trim();
      break;
    }
  }
  const epicPatterns = [
    /(?:for|in|to)\s+(?:the\s+)?(.+?)\s+(?:epic|에픽)/i,
    /(?:epic|에픽)[:\s]+(.+?)(?:\.|,|$)/i
  ];
  for (const pattern of epicPatterns) {
    const match = cleanedText.match(pattern);
    if (match) {
      result.epic = match[1].trim();
      break;
    }
  }
  let taskText = cleanedText.replace(/(?:high|low|critical|높은|낮은|긴급|urgent)\s*priority[:\s]*/gi, "").replace(/priority[:\s]*(?:high|low|critical|medium|높음|낮음|중간)/gi, "").replace(/(?:for|in|to)\s+(?:the\s+)?.+?\s+(?:project|epic|프로젝트|에픽)/gi, "").replace(/(?:project|epic|프로젝트|에픽)[:\s]+.+?(?:\.|,|$)/gi, "").trim();
  taskText = taskText.replace(/\s+/g, " ").replace(/^[,.\s]+|[,.\s]+$/g, "").trim();
  result.taskTitle = taskText;
  return result;
}

// src/context-loader.ts
var import_obsidian4 = require("obsidian");
function loadGoals(app, goalsFolder) {
  const goals = [];
  const folder = app.vault.getAbstractFileByPath(goalsFolder);
  if (!folder || !(folder instanceof import_obsidian4.TFolder)) {
    return goals;
  }
  for (const child of folder.children) {
    if (child instanceof import_obsidian4.TFile && child.extension === "md") {
      const cache = app.metadataCache.getFileCache(child);
      if (!(cache == null ? void 0 : cache.frontmatter))
        continue;
      const frontmatter = cache.frontmatter;
      const type = extractFrontmatterString(frontmatter.Type);
      if (type.toLowerCase().includes("goal")) {
        goals.push({
          name: child.basename,
          path: child.path,
          area: extractFrontmatterString(frontmatter.Area),
          status: extractFrontmatterString(frontmatter.Status),
          milestones: []
        });
      }
    }
  }
  return goals;
}
function loadProjects(app, projectsFolder) {
  const projects = [];
  const folder = app.vault.getAbstractFileByPath(projectsFolder);
  if (!folder || !(folder instanceof import_obsidian4.TFolder)) {
    return projects;
  }
  const processFolder = (currentFolder) => {
    for (const child of currentFolder.children) {
      if (child instanceof import_obsidian4.TFile && child.extension === "md") {
        const cache = app.metadataCache.getFileCache(child);
        if (!(cache == null ? void 0 : cache.frontmatter))
          continue;
        const frontmatter = cache.frontmatter;
        const type = extractFrontmatterString(frontmatter.Type);
        if (type.toLowerCase().includes("project")) {
          projects.push({
            name: child.basename,
            path: child.path,
            area: extractFrontmatterString(frontmatter.Area),
            goal: extractFrontmatterString(frontmatter.Goal),
            status: extractFrontmatterString(frontmatter.Status)
          });
        }
      } else if (child instanceof import_obsidian4.TFolder) {
        processFolder(child);
      }
    }
  };
  processFolder(folder);
  return projects;
}
function loadEpics(app, epicsFolder) {
  const epics = [];
  const folder = app.vault.getAbstractFileByPath(epicsFolder);
  if (!folder || !(folder instanceof import_obsidian4.TFolder)) {
    return epics;
  }
  for (const child of folder.children) {
    if (child instanceof import_obsidian4.TFile && child.extension === "md") {
      const cache = app.metadataCache.getFileCache(child);
      if (!(cache == null ? void 0 : cache.frontmatter))
        continue;
      const frontmatter = cache.frontmatter;
      const type = extractFrontmatterString(frontmatter.Type);
      if (type.toLowerCase().includes("epic")) {
        epics.push({
          name: child.basename,
          path: child.path,
          area: extractFrontmatterString(frontmatter.Area),
          goal: extractFrontmatterString(frontmatter.Goal),
          project: extractFrontmatterString(frontmatter.Project),
          milestone: extractFrontmatterString(frontmatter.Milestone),
          status: extractFrontmatterString(frontmatter.Status),
          description: extractFrontmatterString(frontmatter.Description)
        });
      }
    }
  }
  return epics;
}
function loadActiveTasks(app, tasksFolder) {
  const tasks = [];
  const folder = app.vault.getAbstractFileByPath(tasksFolder);
  if (!folder || !(folder instanceof import_obsidian4.TFolder)) {
    return tasks;
  }
  const processFolder = (currentFolder) => {
    for (const child of currentFolder.children) {
      if (child instanceof import_obsidian4.TFile && child.extension === "md") {
        const cache = app.metadataCache.getFileCache(child);
        if (!(cache == null ? void 0 : cache.frontmatter))
          continue;
        const frontmatter = cache.frontmatter;
        const type = extractFrontmatterString(frontmatter.Type);
        const status = extractFrontmatterString(frontmatter.Status);
        if (type.toLowerCase().includes("task") && !status.toLowerCase().includes("completed")) {
          tasks.push({
            name: child.basename,
            path: child.path,
            area: extractFrontmatterString(frontmatter.Area),
            goal: extractFrontmatterString(frontmatter.Goal),
            project: extractFrontmatterString(frontmatter.Project),
            epic: extractFrontmatterString(frontmatter.Epic),
            status,
            priority: extractFrontmatterString(frontmatter.Priority),
            due: extractFrontmatterString(frontmatter.Due)
          });
        }
      } else if (child instanceof import_obsidian4.TFolder) {
        processFolder(child);
      }
    }
  };
  processFolder(folder);
  return tasks;
}
function loadUserContext(app, goalsFolder, projectsFolder, epicsFolder, tasksFolder) {
  return {
    goals: loadGoals(app, goalsFolder),
    projects: loadProjects(app, projectsFolder),
    epics: loadEpics(app, epicsFolder),
    activeTasks: loadActiveTasks(app, tasksFolder)
  };
}
function formatContextForPrompt(context) {
  const goals = context.goals.map((goal) => `- ${goal.name} (${goal.status || "active"}) - Area: ${goal.area || "none"}`).join("\n") || "No goals defined";
  const projects = context.projects.map((project) => `- ${project.name} (${project.status || "active"}) - Goal: ${project.goal || "none"}`).join("\n") || "No projects defined";
  const epics = context.epics.map((epic) => `- ${epic.name} (${epic.status || "backlog"}) - Project: ${epic.project || "none"}, Goal: ${epic.goal || "none"}`).join("\n") || "No epics defined";
  const tasks = context.activeTasks.slice(0, 20).map((task) => `- ${task.name} (${task.status || "backlog"}, ${task.priority || "medium"}) - Epic: ${task.epic || "none"}`).join("\n") || "No active tasks";
  return { goals, projects, epics, tasks };
}
function extractFrontmatterString(value) {
  if (!value)
    return "";
  if (typeof value === "string") {
    return value.replace(/\[\[([^\]|]+)(?:\|[^\]]+)?\]\]/g, "$1").trim();
  }
  if (Array.isArray(value)) {
    return value.map((item) => extractFrontmatterString(item)).filter(Boolean).join(", ");
  }
  return String(value);
}
async function getEpicMetadata(app, epicName, epicsFolder) {
  const epicPath = `${epicsFolder}/${epicName}.md`;
  const epicFile = app.vault.getAbstractFileByPath(epicPath);
  if (!epicFile || !(epicFile instanceof import_obsidian4.TFile)) {
    return null;
  }
  const cache = app.metadataCache.getFileCache(epicFile);
  if (!(cache == null ? void 0 : cache.frontmatter)) {
    return null;
  }
  const frontmatter = cache.frontmatter;
  return {
    area: extractFrontmatterString(frontmatter.Area),
    goal: extractFrontmatterString(frontmatter.Goal),
    project: extractFrontmatterString(frontmatter.Project),
    milestone: extractFrontmatterString(frontmatter.Milestone)
  };
}

// src/task-creator.ts
var import_obsidian5 = require("obsidian");
async function ensureFolderExists(app, folderPath) {
  const normalizedPath = (0, import_obsidian5.normalizePath)(folderPath);
  const existingFolder = app.vault.getAbstractFileByPath(normalizedPath);
  if (existingFolder && existingFolder instanceof import_obsidian5.TFolder) {
    return;
  }
  try {
    await app.vault.createFolder(normalizedPath);
  } catch (error) {
    console.log(`[GPT Task Manager] Folder creation note: ${folderPath}`, error);
  }
}
function sanitizeFilename(filename, fallbackDefault = "Untitled Task") {
  const sanitized = filename.replace(/[\\/:*?"<>|]/g, "-").replace(/\s+/g, " ").trim().substring(0, 100);
  if (!sanitized || sanitized.length === 0) {
    const rawTrimmed = filename.trim().substring(0, 100);
    if (rawTrimmed && rawTrimmed.length > 0) {
      return rawTrimmed.replace(/[\\/:]/g, "-");
    }
    return fallbackDefault;
  }
  return sanitized;
}
function generateTaskContent(params, settings) {
  const timestamp = /* @__PURE__ */ new Date();
  const createdAt = formatDateTime(timestamp);
  const updatedAt = formatDateTime(timestamp);
  const formatLink = (value) => {
    if (!value)
      return "Empty";
    if (value.startsWith("[[") && value.endsWith("]]")) {
      return `"${value}"`;
    }
    return `"[[${value}]]"`;
  };
  const formatString = (value) => {
    if (!value)
      return "";
    return value.replace(/"/g, '\\"').replace(/\n/g, " ");
  };
  const formatTags = (tags) => {
    const YAML_INDENT = "  ";
    if (!tags || tags.length === 0) {
      return `${YAML_INDENT}- tasks`;
    }
    return tags.map((tag) => `${YAML_INDENT}- ${tag.startsWith("#") ? tag.substring(1) : tag}`).join("\n");
  };
  const frontmatterLines = [
    "---",
    'Type: "[[Tasks]]"',
    `Area: ${formatLink(params.area)}`,
    `Goal: ${formatLink(params.goal)}`,
    `Project: ${formatLink(params.project)}`,
    `Epic: ${formatLink(params.epic)}`,
    `Status: ${params.status || settings.defaultStatus}`,
    `Priority: ${params.priority || settings.defaultPriority}`,
    `Due: ${params.due || ""}`,
    `Created: "${createdAt}"`,
    `Updated: "${updatedAt}"`,
    "tags:",
    formatTags(params.tags),
    "Cover: ",
    `Description: "${formatString(params.objective)}"`,
    "Topics: ",
    `Parent: ${params.parent ? formatLink(params.parent) : "Empty"}`,
    "---"
  ];
  const frontmatter = frontmatterLines.join("\n");
  const body = `
## \u{1F504} Sync
- [ ] ${params.title}

## \u{1F3AF} Objective
> What needs to be accomplished:
- ${params.objective || ""}

> Why it matters:
- ${params.importance || ""}


## \u2699\uFE0F Progress Log

> **Updates / checkpoints:**
> Date - 


## \u{1F9E0} Notes / Insights
>


## \u{1F4A1} Reflection
> What was learned or decided:
- 

> What to improve next time:
- 
  
  

---
### \u{1F517} Related Notes
- 
`;
  return frontmatter + body;
}
function generateTaskFromSuggestion(suggestion, epicMetadata, settings) {
  const params = {
    title: suggestion.title,
    objective: suggestion.objective,
    importance: suggestion.importance,
    area: (epicMetadata == null ? void 0 : epicMetadata.area) || "",
    goal: (epicMetadata == null ? void 0 : epicMetadata.goal) || "",
    project: suggestion.suggestedProject || (epicMetadata == null ? void 0 : epicMetadata.project) || "",
    epic: suggestion.suggestedEpic || "",
    priority: suggestion.priority,
    tags: ["tasks"]
  };
  return generateTaskContent(params, settings);
}
async function createTaskFile(app, content, title, epicName, settings) {
  const sanitizedTitle = sanitizeFilename(title, `Task-${Date.now()}`);
  let taskPath;
  await ensureFolderExists(app, settings.tasksFolder);
  if (epicName) {
    const sanitizedEpicName = sanitizeFilename(epicName, "Untitled Epic");
    const epicFolder = `${settings.tasksFolder}/active epic folder/${sanitizedEpicName}`;
    await ensureFolderExists(app, `${settings.tasksFolder}/active epic folder`);
    await ensureFolderExists(app, epicFolder);
    taskPath = `${epicFolder}/${sanitizedTitle}.md`;
  } else {
    taskPath = `${settings.tasksFolder}/${sanitizedTitle}.md`;
  }
  const normalizedPath = (0, import_obsidian5.normalizePath)(taskPath);
  const existingFile = app.vault.getAbstractFileByPath(normalizedPath);
  if (existingFile instanceof import_obsidian5.TFile) {
    let counter = 1;
    let newPath = taskPath;
    while (app.vault.getAbstractFileByPath(newPath)) {
      newPath = taskPath.replace(".md", ` (${counter}).md`);
      counter++;
    }
    taskPath = newPath;
  }
  const file = await app.vault.create((0, import_obsidian5.normalizePath)(taskPath), content);
  return file;
}
async function createTasksFromBreakdown(app, breakdown, epicName, epicMetadata, settings) {
  const createdFiles = [];
  const indexToBasename = /* @__PURE__ */ new Map();
  await ensureFolderExists(app, settings.tasksFolder);
  if (epicName) {
    const sanitizedEpicName = sanitizeFilename(epicName, "Untitled Epic");
    await ensureFolderExists(app, `${settings.tasksFolder}/active epic folder`);
    await ensureFolderExists(app, `${settings.tasksFolder}/active epic folder/${sanitizedEpicName}`);
  }
  for (let taskIndex = 0; taskIndex < breakdown.tasks.length; taskIndex++) {
    const task = breakdown.tasks[taskIndex];
    let parentBasename = void 0;
    if (task.dependsOn !== null && task.dependsOn !== void 0) {
      const dependsOnIndex = task.dependsOn;
      if (dependsOnIndex >= 0 && dependsOnIndex < taskIndex && indexToBasename.has(dependsOnIndex)) {
        parentBasename = indexToBasename.get(dependsOnIndex);
      }
    }
    const params = {
      title: task.title,
      objective: task.objective,
      area: (epicMetadata == null ? void 0 : epicMetadata.area) || "",
      goal: (epicMetadata == null ? void 0 : epicMetadata.goal) || "",
      project: (epicMetadata == null ? void 0 : epicMetadata.project) || "",
      epic: epicName,
      priority: task.priority,
      parent: parentBasename,
      tags: ["tasks"]
    };
    const content = generateTaskContent(params, settings);
    try {
      const file = await createTaskFile(app, content, task.title, epicName, settings);
      createdFiles.push(file);
      indexToBasename.set(taskIndex, file.basename);
    } catch (error) {
      console.error(`[GPT Task Manager] Failed to create task: ${task.title}`, error);
      new import_obsidian5.Notice(`Failed to create task: ${task.title}`);
    }
  }
  return createdFiles;
}
function buildBreakdownSummaries(breakdown, epicName, settings) {
  const summaries = [];
  const sanitizedEpicName = sanitizeFilename(epicName, "Untitled Epic");
  const targetFolder = `${settings.tasksFolder}/active epic folder/${sanitizedEpicName}`;
  const indexToTitle = /* @__PURE__ */ new Map();
  breakdown.tasks.forEach((task, index) => {
    indexToTitle.set(index, task.title);
  });
  for (let taskIndex = 0; taskIndex < breakdown.tasks.length; taskIndex++) {
    const task = breakdown.tasks[taskIndex];
    let dependsOnTask = null;
    if (task.dependsOn !== null && task.dependsOn !== void 0) {
      const dependsOnIndex = task.dependsOn;
      if (dependsOnIndex >= 0 && dependsOnIndex < breakdown.tasks.length && indexToTitle.has(dependsOnIndex)) {
        dependsOnTask = indexToTitle.get(dependsOnIndex) || null;
      }
    }
    summaries.push({
      title: task.title,
      targetFolder,
      epic: epicName,
      priority: task.priority || settings.defaultPriority,
      dependsOnTask
    });
  }
  return summaries;
}
function buildSuggestionSummary(suggestion, epicName, settings) {
  let targetFolder;
  if (epicName) {
    const sanitizedEpicName = sanitizeFilename(epicName, "Untitled Epic");
    targetFolder = `${settings.tasksFolder}/active epic folder/${sanitizedEpicName}`;
  } else {
    targetFolder = settings.tasksFolder;
  }
  return {
    title: suggestion.title,
    targetFolder,
    epic: epicName,
    priority: suggestion.priority || settings.defaultPriority,
    dependsOnTask: null
  };
}
function formatDateTime(date) {
  const year = date.getFullYear();
  const month = String(date.getMonth() + 1).padStart(2, "0");
  const day = String(date.getDate()).padStart(2, "0");
  const hours = String(date.getHours()).padStart(2, "0");
  const minutes = String(date.getMinutes()).padStart(2, "0");
  return `${year}-${month}-${day} ${hours}:${minutes}`;
}
var TaskConfirmationModal = class extends import_obsidian5.Modal {
  constructor(app, summaries, operationType, epicName, onConfirm, onCancel) {
    super(app);
    this.summaries = summaries;
    this.operationType = operationType;
    this.epicName = epicName;
    this.onConfirm = onConfirm;
    this.onCancel = onCancel;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("gpt-task-manager-confirmation-modal");
    const headerText = this.operationType === "breakdown" ? `\u{1F4CB} Confirm Task Creation (${this.summaries.length} tasks)` : "\u{1F4CB} Confirm Task Creation";
    contentEl.createEl("h2", { text: headerText });
    const descText = this.operationType === "breakdown" ? "The following tasks will be created:" : "The following task will be created:";
    contentEl.createEl("p", { text: descText, cls: "modal-description" });
    const listEl = contentEl.createDiv({ cls: "confirmation-task-list" });
    for (let summaryIndex = 0; summaryIndex < this.summaries.length; summaryIndex++) {
      const summary = this.summaries[summaryIndex];
      const itemEl = listEl.createDiv({ cls: "confirmation-task-item" });
      const titleRow = itemEl.createDiv({ cls: "task-title-row" });
      if (this.operationType === "breakdown") {
        titleRow.createEl("span", {
          text: `${summaryIndex + 1}. `,
          cls: "task-number"
        });
      }
      titleRow.createEl("span", { text: summary.title, cls: "task-title" });
      const detailsEl = itemEl.createDiv({ cls: "task-details" });
      detailsEl.createEl("span", {
        text: summary.priority,
        cls: `priority-badge priority-${summary.priority}`
      });
      if (summary.epic) {
        detailsEl.createEl("span", {
          text: `Epic: ${summary.epic}`,
          cls: "task-epic"
        });
      }
      if (summary.dependsOnTask) {
        detailsEl.createEl("span", {
          text: `\u2192 Depends on: ${summary.dependsOnTask}`,
          cls: "task-dependency"
        });
      }
      const folderEl = itemEl.createDiv({ cls: "task-folder" });
      folderEl.createEl("span", {
        text: `\u{1F4C1} ${summary.targetFolder}`,
        cls: "folder-path"
      });
    }
    const buttonsEl = contentEl.createDiv({ cls: "modal-button-container" });
    const cancelBtn = buttonsEl.createEl("button", { text: "Cancel" });
    cancelBtn.onclick = () => {
      this.close();
      this.onCancel();
    };
    const confirmText = this.operationType === "breakdown" ? `\u2713 Create ${this.summaries.length} Tasks` : "\u2713 Create Task";
    const confirmBtn = buttonsEl.createEl("button", {
      text: confirmText,
      cls: "mod-cta"
    });
    confirmBtn.onclick = () => {
      this.close();
      this.onConfirm();
    };
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
function showTaskConfirmation(app, summaries, operationType, epicName) {
  return new Promise((resolve) => {
    new TaskConfirmationModal(
      app,
      summaries,
      operationType,
      epicName,
      () => resolve(true),
      () => resolve(false)
    ).open();
  });
}

// main.ts
var QuickTaskModal = class extends import_obsidian6.Modal {
  constructor(app, onSubmit) {
    super(app);
    this.inputEl = null;
    this.onSubmit = onSubmit;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("gpt-task-manager-quick-modal");
    contentEl.createEl("h2", { text: "\u{1F680} Quick Task Creation" });
    contentEl.createEl("p", {
      text: "Describe your task naturally. GPT will help structure it based on your goals and projects.",
      cls: "modal-description"
    });
    this.inputEl = contentEl.createEl("textarea", {
      placeholder: "e.g., Create a landing page for the Freedom Runway project with high priority"
    });
    this.inputEl.style.width = "100%";
    this.inputEl.style.minHeight = "100px";
    this.inputEl.style.marginBottom = "16px";
    this.inputEl.style.padding = "12px";
    this.inputEl.style.fontSize = "14px";
    this.inputEl.style.borderRadius = "8px";
    this.inputEl.addEventListener("keydown", (event) => {
      if (event.key === "Enter" && !event.shiftKey) {
        event.preventDefault();
        this.submit();
      }
    });
    const buttonsEl = contentEl.createDiv({ cls: "modal-button-container" });
    const cancelBtn = buttonsEl.createEl("button", { text: "Cancel" });
    cancelBtn.onclick = () => this.close();
    const submitBtn = buttonsEl.createEl("button", { text: "\u2728 Create with AI", cls: "mod-cta" });
    submitBtn.onclick = () => this.submit();
    this.inputEl.focus();
  }
  submit() {
    var _a;
    const input = (_a = this.inputEl) == null ? void 0 : _a.value.trim();
    if (input) {
      this.close();
      this.onSubmit(input);
    } else {
      new import_obsidian6.Notice("Please enter a task description");
    }
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var EpicSelectModal = class extends import_obsidian6.FuzzySuggestModal {
  constructor(app, epics, onChoose) {
    super(app);
    this.epics = epics;
    this.onChoose = onChoose;
    this.setPlaceholder("Select an epic to break down...");
  }
  getItems() {
    return this.epics;
  }
  getItemText(item) {
    const status = item.status ? ` [${item.status}]` : "";
    const project = item.project ? ` - ${item.project}` : "";
    return `${item.name}${status}${project}`;
  }
  onChooseItem(item, evt) {
    this.onChoose(item);
  }
};
var TaskReviewModal = class extends import_obsidian6.Modal {
  constructor(app, suggestion, epics, onConfirm, onCancel) {
    super(app);
    this.suggestion = suggestion;
    this.epics = epics;
    this.onConfirm = onConfirm;
    this.onCancel = onCancel;
    this.selectedEpic = suggestion.suggestedEpic;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("gpt-task-manager-review-modal");
    contentEl.createEl("h2", { text: "\u{1F4CB} Review Task" });
    const formEl = contentEl.createDiv({ cls: "task-review-form" });
    const titleGroup = formEl.createDiv({ cls: "form-group" });
    titleGroup.createEl("label", { text: "Title" });
    const titleInput = titleGroup.createEl("input", { type: "text", value: this.suggestion.title });
    titleInput.style.width = "100%";
    titleInput.addEventListener("change", () => {
      this.suggestion.title = titleInput.value;
    });
    const objectiveGroup = formEl.createDiv({ cls: "form-group" });
    objectiveGroup.createEl("label", { text: "Objective" });
    const objectiveInput = objectiveGroup.createEl("textarea", { text: this.suggestion.objective });
    objectiveInput.style.width = "100%";
    objectiveInput.rows = 3;
    objectiveInput.addEventListener("change", () => {
      this.suggestion.objective = objectiveInput.value;
    });
    const importanceGroup = formEl.createDiv({ cls: "form-group" });
    importanceGroup.createEl("label", { text: "Why it matters" });
    const importanceInput = importanceGroup.createEl("textarea", { text: this.suggestion.importance });
    importanceInput.style.width = "100%";
    importanceInput.rows = 2;
    importanceInput.addEventListener("change", () => {
      this.suggestion.importance = importanceInput.value;
    });
    const epicGroup = formEl.createDiv({ cls: "form-group" });
    epicGroup.createEl("label", { text: "Epic" });
    const epicSelect = epicGroup.createEl("select");
    epicSelect.style.width = "100%";
    const noneOption = epicSelect.createEl("option", { text: "-- No Epic --", value: "" });
    for (const epic of this.epics) {
      const option = epicSelect.createEl("option", {
        text: `${epic.name} (${epic.status || "active"})`,
        value: epic.name
      });
      if (epic.name === this.suggestion.suggestedEpic) {
        option.selected = true;
      }
    }
    epicSelect.addEventListener("change", () => {
      this.selectedEpic = epicSelect.value || null;
    });
    const priorityGroup = formEl.createDiv({ cls: "form-group" });
    priorityGroup.createEl("label", { text: "Priority" });
    const prioritySelect = priorityGroup.createEl("select");
    prioritySelect.style.width = "100%";
    const priorities = [
      { value: "low", text: "Low" },
      { value: "medium", text: "Medium" },
      { value: "high", text: "High" },
      { value: "critical", text: "Critical" }
    ];
    for (const priority of priorities) {
      const option = prioritySelect.createEl("option", {
        text: priority.text,
        value: priority.value
      });
      if (priority.value === this.suggestion.priority) {
        option.selected = true;
      }
    }
    prioritySelect.addEventListener("change", () => {
      this.suggestion.priority = prioritySelect.value;
    });
    if (this.suggestion.subtasks.length > 0) {
      const subtasksGroup = formEl.createDiv({ cls: "form-group" });
      subtasksGroup.createEl("label", { text: `Suggested Subtasks (${this.suggestion.subtasks.length})` });
      const subtasksList = subtasksGroup.createEl("ul", { cls: "subtasks-preview" });
      for (const subtask of this.suggestion.subtasks) {
        subtasksList.createEl("li", { text: subtask });
      }
    }
    const buttonsEl = contentEl.createDiv({ cls: "modal-button-container" });
    const cancelBtn = buttonsEl.createEl("button", { text: "Cancel" });
    cancelBtn.onclick = () => {
      this.close();
      this.onCancel();
    };
    const confirmBtn = buttonsEl.createEl("button", { text: "\u2713 Create Task", cls: "mod-cta" });
    confirmBtn.onclick = () => {
      this.close();
      this.onConfirm(this.suggestion, this.selectedEpic);
    };
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var BreakdownReviewModal = class extends import_obsidian6.Modal {
  constructor(app, breakdown, epicName, onConfirm, onCancel) {
    super(app);
    this.breakdown = breakdown;
    this.epicName = epicName;
    this.onConfirm = onConfirm;
    this.onCancel = onCancel;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("gpt-task-manager-breakdown-modal");
    contentEl.createEl("h2", { text: `\u{1F4CA} Task Breakdown: ${this.epicName}` });
    contentEl.createEl("p", {
      text: `${this.breakdown.tasks.length} tasks will be created:`,
      cls: "modal-description"
    });
    const taskListEl = contentEl.createDiv({ cls: "breakdown-task-list" });
    for (let index = 0; index < this.breakdown.tasks.length; index++) {
      const task = this.breakdown.tasks[index];
      const taskEl = taskListEl.createDiv({ cls: "breakdown-task-item" });
      const headerEl = taskEl.createDiv({ cls: "task-header" });
      headerEl.createEl("span", { text: `${index + 1}. ${task.title}`, cls: "task-title" });
      headerEl.createEl("span", {
        text: task.priority,
        cls: `task-priority priority-${task.priority}`
      });
      if (task.objective) {
        taskEl.createEl("p", { text: task.objective, cls: "task-objective" });
      }
      if (task.dependsOn !== null) {
        taskEl.createEl("span", {
          text: `Depends on: Task ${task.dependsOn + 1}`,
          cls: "task-dependency"
        });
      }
    }
    const buttonsEl = contentEl.createDiv({ cls: "modal-button-container" });
    const cancelBtn = buttonsEl.createEl("button", { text: "Cancel" });
    cancelBtn.onclick = () => {
      this.close();
      this.onCancel();
    };
    const confirmBtn = buttonsEl.createEl("button", {
      text: `\u2713 Create ${this.breakdown.tasks.length} Tasks`,
      cls: "mod-cta"
    });
    confirmBtn.onclick = () => {
      this.close();
      this.onConfirm(this.breakdown);
    };
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var GptTaskManagerPlugin = class extends import_obsidian6.Plugin {
  constructor() {
    super(...arguments);
    this.settings = DEFAULT_SETTINGS;
  }
  async onload() {
    console.log("[GPT Task Manager] Loading plugin...");
    await this.loadSettings();
    this.addSettingTab(new GptTaskManagerSettingTab(this.app, this));
    this.addRibbonIcon("plus-circle", "Quick Task (GPT)", () => {
      this.showQuickTaskModal();
    });
    this.addRibbonIcon("mic", "Voice Task", () => {
      this.startVoiceTask();
    });
    this.addCommand({
      id: "gpt-task-quick-create",
      name: "Quick Task Creation (GPT Assisted)",
      callback: () => this.showQuickTaskModal()
    });
    this.addCommand({
      id: "gpt-task-voice-create",
      name: "Voice Task Creation",
      callback: () => this.startVoiceTask()
    });
    this.addCommand({
      id: "gpt-task-breakdown-epic",
      name: "Break Down Epic into Tasks",
      callback: () => this.showEpicBreakdownModal()
    });
    this.addCommand({
      id: "gpt-task-simple-create",
      name: "Simple Task Creation (No AI)",
      callback: () => this.showSimpleTaskModal()
    });
    this.addCommand({
      id: "gpt-task-from-selection",
      name: "Create Task from Selection (GPT)",
      editorCallback: (editor, view) => {
        this.createTaskFromSelection(editor);
      }
    });
    console.log("[GPT Task Manager] Plugin loaded successfully");
  }
  onunload() {
    console.log("[GPT Task Manager] Unloading plugin...");
  }
  async loadSettings() {
    const stored = await this.loadData();
    this.settings = Object.assign({}, DEFAULT_SETTINGS, stored);
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  /**
   * Show quick task input modal
   */
  showQuickTaskModal() {
    if (!this.settings.openAIApiKey) {
      new import_obsidian6.Notice("Please set your OpenAI API key in settings first.");
      return;
    }
    new QuickTaskModal(this.app, async (input) => {
      await this.processQuickTask(input);
    }).open();
  }
  /**
   * Process quick task input with GPT
   */
  async processQuickTask(input) {
    new import_obsidian6.Notice("\u{1F916} Processing with GPT...");
    try {
      const context = loadUserContext(
        this.app,
        this.settings.goalsFolder,
        this.settings.projectsFolder,
        this.settings.epicsFolder,
        this.settings.tasksFolder
      );
      const formattedContext = formatContextForPrompt(context);
      const prompt = fillPromptTemplate(this.settings.taskCreationPrompt, {
        goals: formattedContext.goals,
        projects: formattedContext.projects,
        epics: formattedContext.epics,
        input
      });
      const result = await callGptApi(
        prompt,
        "You are a helpful task management assistant that creates well-structured tasks.",
        this.settings.openAIApiKey,
        this.settings.gptModel,
        this.settings.gptMaxTokens,
        this.settings.gptTemperature
      );
      if (!result.success || !result.content) {
        new import_obsidian6.Notice(`GPT Error: ${result.errorMessage || "Unknown error"}`);
        return;
      }
      const suggestion = parseTaskSuggestion(result.content);
      if (!suggestion) {
        new import_obsidian6.Notice("Failed to parse GPT response. Creating simple task.");
        await this.createSimpleTask(input);
        return;
      }
      new TaskReviewModal(
        this.app,
        suggestion,
        context.epics,
        async (finalSuggestion, selectedEpic) => {
          await this.createTaskFromSuggestion(finalSuggestion, selectedEpic);
        },
        () => {
          new import_obsidian6.Notice("Task creation cancelled");
        }
      ).open();
    } catch (error) {
      console.error("[GPT Task Manager] Quick task error:", error);
      new import_obsidian6.Notice(`Error: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  /**
   * Create task from GPT suggestion with confirmation dialog
   */
  async createTaskFromSuggestion(suggestion, epicName) {
    try {
      const summary = buildSuggestionSummary(suggestion, epicName, this.settings);
      const confirmed = await showTaskConfirmation(
        this.app,
        [summary],
        "single",
        epicName
      );
      if (!confirmed) {
        new import_obsidian6.Notice("Task creation cancelled");
        return;
      }
      let epicMetadata = null;
      if (epicName) {
        epicMetadata = await getEpicMetadata(this.app, epicName, this.settings.epicsFolder);
      }
      const content = generateTaskFromSuggestion(suggestion, epicMetadata, this.settings);
      const file = await createTaskFile(
        this.app,
        content,
        suggestion.title,
        epicName,
        this.settings
      );
      new import_obsidian6.Notice(`\u2705 Created task: ${suggestion.title}`);
      await this.app.workspace.openLinkText(file.path, "", false);
    } catch (error) {
      console.error("[GPT Task Manager] Task creation error:", error);
      new import_obsidian6.Notice(`Failed to create task: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  /**
   * Start voice task recording
   */
  startVoiceTask() {
    if (!this.settings.openAIApiKey) {
      new import_obsidian6.Notice("Please set your OpenAI API key in settings first.");
      return;
    }
    if (!this.settings.enableVoiceInput) {
      new import_obsidian6.Notice("Voice input is disabled. Enable it in settings.");
      return;
    }
    new VoiceRecordingModal(
      this.app,
      async (audioBlob) => {
        await this.processVoiceTask(audioBlob);
      },
      () => {
        new import_obsidian6.Notice("Recording cancelled");
      }
    ).open();
  }
  /**
   * Process voice recording into task
   */
  async processVoiceTask(audioBlob) {
    new import_obsidian6.Notice("\u{1F3A4} Transcribing...");
    try {
      const transcription = await transcribeAudio(
        audioBlob,
        this.settings.openAIApiKey,
        this.settings.whisperModel,
        this.settings.defaultLanguage === "auto" ? void 0 : this.settings.defaultLanguage
      );
      if (!transcription) {
        new import_obsidian6.Notice("Transcription returned empty result");
        return;
      }
      new import_obsidian6.Notice(`\u{1F4DD} Transcribed: "${transcription.substring(0, 50)}..."`);
      const voiceInput = parseVoiceTaskInput(transcription);
      if (this.settings.enableSmartSuggestions) {
        await this.processQuickTask(transcription);
      } else {
        await this.createSimpleTask(voiceInput.taskTitle || transcription);
      }
    } catch (error) {
      console.error("[GPT Task Manager] Voice task error:", error);
      new import_obsidian6.Notice(`Error: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  /**
   * Show epic breakdown modal
   */
  showEpicBreakdownModal() {
    if (!this.settings.openAIApiKey) {
      new import_obsidian6.Notice("Please set your OpenAI API key in settings first.");
      return;
    }
    const epics = loadEpics(this.app, this.settings.epicsFolder);
    if (epics.length === 0) {
      new import_obsidian6.Notice("No epics found in your vault.");
      return;
    }
    new EpicSelectModal(this.app, epics, async (epic) => {
      await this.breakdownEpic(epic);
    }).open();
  }
  /**
   * Break down an epic into tasks using GPT
   */
  async breakdownEpic(epic) {
    new import_obsidian6.Notice(`\u{1F916} Breaking down: ${epic.name}...`);
    try {
      const epicPath = epic.path;
      const epicFile = this.app.vault.getAbstractFileByPath(epicPath);
      let epicContent = "";
      if (epicFile instanceof import_obsidian6.TFile) {
        epicContent = await this.app.vault.read(epicFile);
      }
      const objectiveMatch = epicContent.match(/## 🎯 Objective[\s\S]*?> What this epic aims to achieve:\s*\n-\s*(.+)/);
      const objective = objectiveMatch ? objectiveMatch[1] : epic.description || "";
      const prompt = fillPromptTemplate(this.settings.taskBreakdownPrompt, {
        title: epic.name,
        description: epic.description || "No description provided",
        objective,
        goal: epic.goal,
        project: epic.project,
        area: epic.area
      });
      const result = await callGptApi(
        prompt,
        "You are an expert project manager that breaks down complex work into actionable tasks.",
        this.settings.openAIApiKey,
        this.settings.gptModel,
        this.settings.gptMaxTokens,
        this.settings.gptTemperature
      );
      if (!result.success || !result.content) {
        new import_obsidian6.Notice(`GPT Error: ${result.errorMessage || "Unknown error"}`);
        return;
      }
      const breakdown = parseTaskBreakdown(result.content);
      if (!breakdown || breakdown.tasks.length === 0) {
        new import_obsidian6.Notice("Failed to parse task breakdown from GPT response.");
        return;
      }
      new BreakdownReviewModal(
        this.app,
        breakdown,
        epic.name,
        async (finalBreakdown) => {
          await this.createBreakdownTasks(finalBreakdown, epic);
        },
        () => {
          new import_obsidian6.Notice("Breakdown cancelled");
        }
      ).open();
    } catch (error) {
      console.error("[GPT Task Manager] Epic breakdown error:", error);
      new import_obsidian6.Notice(`Error: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  /**
   * Create tasks from breakdown with confirmation dialog
   */
  async createBreakdownTasks(breakdown, epic) {
    try {
      const summaries = buildBreakdownSummaries(breakdown, epic.name, this.settings);
      const confirmed = await showTaskConfirmation(
        this.app,
        summaries,
        "breakdown",
        epic.name
      );
      if (!confirmed) {
        new import_obsidian6.Notice("Task breakdown cancelled");
        return;
      }
      const epicMetadata = {
        area: epic.area,
        goal: epic.goal,
        project: epic.project
      };
      const files = await createTasksFromBreakdown(
        this.app,
        breakdown,
        epic.name,
        epicMetadata,
        this.settings
      );
      new import_obsidian6.Notice(`\u2705 Created ${files.length} tasks for ${epic.name}`);
      if (files.length > 0) {
        await this.app.workspace.openLinkText(files[0].path, "", false);
      }
    } catch (error) {
      console.error("[GPT Task Manager] Breakdown task creation error:", error);
      new import_obsidian6.Notice(`Error: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  /**
   * Show simple task creation modal (no AI)
   */
  showSimpleTaskModal() {
    new QuickTaskModal(this.app, async (input) => {
      await this.createSimpleTask(input);
    }).open();
  }
  /**
   * Create a simple task without GPT (with confirmation)
   */
  async createSimpleTask(title) {
    try {
      const summary = {
        title,
        targetFolder: this.settings.tasksFolder,
        epic: null,
        priority: this.settings.defaultPriority,
        dependsOnTask: null
      };
      const confirmed = await showTaskConfirmation(
        this.app,
        [summary],
        "single",
        null
      );
      if (!confirmed) {
        new import_obsidian6.Notice("Task creation cancelled");
        return;
      }
      const params = {
        title,
        objective: "",
        importance: "",
        status: this.settings.defaultStatus,
        priority: this.settings.defaultPriority,
        tags: ["tasks"]
      };
      const content = generateTaskContent(params, this.settings);
      const file = await createTaskFile(
        this.app,
        content,
        title,
        null,
        this.settings
      );
      new import_obsidian6.Notice(`\u2705 Created task: ${title}`);
      await this.app.workspace.openLinkText(file.path, "", false);
    } catch (error) {
      console.error("[GPT Task Manager] Simple task error:", error);
      new import_obsidian6.Notice(`Failed to create task: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  /**
   * Create task from selected text
   */
  async createTaskFromSelection(editor) {
    const selection = editor.getSelection();
    if (!selection) {
      new import_obsidian6.Notice("Please select some text first");
      return;
    }
    if (this.settings.enableSmartSuggestions && this.settings.openAIApiKey) {
      await this.processQuickTask(selection);
    } else {
      await this.createSimpleTask(selection);
    }
  }
};
